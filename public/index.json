[{"content":"셸(Shell) 유저가 리눅스 시스템을 이용할 수 있는 인터페이스입니다. 터미널 실행 단축키 ctrl + alt + T (윈도우, 리눅스 기준) control + option + T (맥 기준) 셸 프롬프트(Shell Prompt) 셸이 입력 받을 준비가 되었을 때 1 user@user-VirtualBox:~$ id 명령어: 현재 유저의 유저 ID와 해당 유저가 속해 있는 그룹 ID. 1 2 3 user@user-VirtualBox:~$ id uid=1000(user) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),134(lxd),135(sambashare) user@user-VirtualBox:~$ 기초적인 명령어 sudo apt update apt 명령어로 설치 가능한 소프트웨어 패키지 목록을 업데이트합니다. 그리고 각 소프트웨어 별로 어떤 버전을 설치할 수 있는지도 업데이트 합니다. sudo apt upgrade 리눅스에 설치된 소프트웨어 패키지의 버전을 업그레이드합니다. id 리눅스는 권한을 기반으로 파일을 읽고 쓸 수 있기 때문에 주로 자신이 해당하는 권한을 가지고 있는지 확인하기 위해서 사용하는 명령어입니다. pwd Print Working Directory의 줄임말로 현재 작업 중인 디렉토리의 경로를 출력합니다. ls List의 줄임말로 디렉토리의 내용을 출력하는 명령어입니다.\n-l 플래그를 추가한 형태인 ls -l을 실행하면 더 자세한 내용을 출력합니다.\n현재 디렉토리 뿐만 아니라 임의 디렉토리의 내용을 출력하는 것도 가능합니다. 루트 디렉토리인 / 디렉토리의 내용을 출력하는 ls -l /으로 출력 가능합니다.\ncd Change Directory의 줄임말로 작업 중인 디렉토리를 변경하는 명령어입니다. 구분 기호/명령어 설명 예시 절대 경로 / 시작 루트 디렉토리(/)를 시작으로 모든 경로를 전부 적어서 표현하는 방식 /home/user 상대 경로 .. 등 현재 디렉토리를 기준으로 상위 또는 하위 디렉토리로 뻗어 나가는 방식 cd .. (현재 위치에서 부모 디렉토리로 이동) 홈 디렉토리 ~ 현재 로그인한 유저의 홈 디렉토리 cd ~ (내 홈 폴더로 이동) 이전 경로 - 직전에 위치했던 디렉토리 (바로 전 경로) cd - (이전 작업 위치로 복귀) mkdir Make Directory의 줄임말로 디렉토리를 생성하는 명령어입니다.\n/home/user 디렉토리에 위치할 때 mkdir new_dir 명령어로 new_dir 디렉토리를 생성하면, new_dir가 새롭게 추가됩니다.\ntouch touch 명령어는 비어있는 새로운 파일을 만드는 데 사용합니다. 앞서 생성한 new_dir 디렉토리로 이동 후 ls -l 명령어를 실행하면 아무런 파일도 존재하지 않습니다.\n이때 touch new_file 명령어를 실행한 후 ls -l을 실행하면, new_file 파일이 생성되었습니다.\nmv Move의 줄임말로 파일이나 디렉토리의 위치를 옮길 때 사용하는 명령어입니다. 파일이나 디렉토리의 이름을 변경할 때도 사용할 수 있습니다. 1 mv [예전 이름] [변경할 이름] 파일을 옮길 수도 있습니다. 1 2 3 4 5 6 7 8 9 10 11 user@user-VirtualBox:~/new_dir$ ls old_file user@user-VirtualBox:~/new_dir$ ls .. Desktop Downloads new_dir Public Templates Documents Music Pictures snap Videos user@user-VirtualBox:~/new_dir$ mv old_file .. user@user-VirtualBox:~/new_dir$ ls user@user-VirtualBox:~/new_dir$ ls .. Desktop Downloads new_dir Pictures snap Videos Documents Music old_file Public Templates user@user-VirtualBox:~/new_dir$ rm Remove의 줄임말로 파일이나 디렉토리를 삭제하는 명령어입니다. 디렉토리 삭제는 -r 플래그를 추가한 rm -r로 수행할 수 있습니다. cat 파일의 내용을 출력하는 명령어입니다. cat 파일경로 형식으로 사용할 수 있습니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 user@user-VirtualBox:~/new_dir$ cat /etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin ... (생략) user:x:1000:1000:user,,,:/home/user:/bin/bash fwupd-refresh:x:128:136:fwupd-refresh user,,,:/run/systemd:/usr/sbin/nologin vboxadd:x:999:1::/var/run/vboxadd:/bin/false user@user-VirtualBox:~/new_dir$ file 파일의 유형을 출력하는 명령어입니다. 1 2 3 user@user-VirtualBox:~$ file /bin/ls /bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=897f49cafa98c11d63e619e7e40352f855249c13, for GNU/Linux 3.2.0, stripped user@user-VirtualBox:~$ echo 셸에 유저가 입력한 텍스트를 출력합니다. 1 2 3 user@user-VirtualBox:~/new_dir$ echo \u0026#34;Hello world!\u0026#34; Hello world! user@user-VirtualBox:~/new_dir$ ehco 명령어를 사용해서 파일을 생성할 수도 있습니다. echo 명령문 끝에 \u0026gt; 파일명을 이어 붙여 실행하면 파일명 이름을 가지는 파일을 생성하고 echo 뒤에 입력한 내용을 파일 내용으로 저장합니다. 1 2 3 4 5 6 7 8 9 user@user-VirtualBox:~/new_dir$ ls -l total 0 user@user-VirtualBox:~/new_dir$ echo \u0026#34;Hello world!\u0026#34; \u0026gt; hello user@user-VirtualBox:~/new_dir$ ls -l total 4 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello user@user-VirtualBox:~/new_dir$ cat hello Hello world! user@user-VirtualBox:~/new_dir$ cp Copy의 줄임말로 파일이나 디렉토리를 복사하는 명령어입니다. 다음은 위에서 생성한 hello 파일을 world라는 이름으로 복사하는 모습입니다. 디렉토리를 복사할 때는 -r 플래그를 붙인 형태인 cp -r을 사용합니다. 1 2 3 4 5 6 7 8 9 10 11 user@user-VirtualBox:~/new_dir$ ls -l total 4 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello user@user-VirtualBox:~/new_dir$ cp hello world user@user-VirtualBox:~/new_dir$ ls -l total 8 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello -rw-rw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ cat world Hello world! user@user-VirtualBox:~/new_dir$ grep 전체에서 특정 문자열을 찾을 때 사용합니다. grep 문자열 파일 형식으로 사용할 수 있습니다. 다음은 grep root /etc/passwd를 수행하여 /etc/passwd 파일에서 root 문자열이 포함된 행을 출력하는 모습입니다. 1 2 3 user@user-VirtualBox:~/new_dir$ grep root /etc/passwd root:x:0:0:root:/root:/bin/bash nm-openvpn:x:121:127:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin man Manual의 줄임말로 특정 명령어의 매뉴얼을 보여주는 명령어입니다. man [명령어]로 수행할 수 있습니다. curl client URL의 줄임말로 서버에 데이터를 보내거나 서버로부터 받는 데이터 전송 명령어입니다. curl [옵션] URL 형식으로 사용할 수 있으며, HTTP, HTTPS, FTP 등 다양한 프로토콜을 지원합니다. curl 명령어의 주요 옵션들 -o file: 전송 받은 데이터를 파일에 저장합니다. -i: 결과 값에 HTTP 응답 헤더를 포함합니다. -X \u0026quot;method\u0026quot;: HTTP 요청 메소드를 지정합니다. -d \u0026quot;key=value\u0026quot;: HTTP POST 메소드로 데이터를 전송합니다. curl을 이용한 명령어 실행 결과 전송 curl은 워게임 문제를 풀 때도 유용하게 사용됩니다. 예를 들어 풀이자가 명령어 실행 결과를 볼 수 없는 경우, 결과를 curl 명령어에 포함하여 풀이자의 웹 서버로 전송하면 확인이 가능합니다. 1 $ curl \u0026#34;[웹사이트]\u0026#34; -d \u0026#34;`cat [파일]`\u0026#34; 와일드카드 **와일드카드(wildcards)**는 리눅스에서 임의의 다른 문자를 나타낼 수 있는 특수 문자들을 의미합니다. 주로 명령어를 다른 문자열로 대체하기 위해 사용합니다. ? a-z, 0-9 범위 내 임의의 1개 문자로 대체됩니다. * a-z, 0-9 범위 내 임의의 0개 이상 문자로 대체됩니다. [] [문자1-문자2] 혹은 [문자1, 문자2, …] 형태로 범위를 지정합니다. 범위 내 모든 문자로 대체될 수 있습니다. 리다이렉션 **리다이렉션(redirection)**은 모니터에 나타나는 표준 출력 혹은 키보드로 입력하는 표준 입력을 다른 곳으로 변경하는 작업입니다. 주로 어떤 명령어의 결과를 파일로 저장하거나, 다른 명령어의 입력으로 전달하는 형태로 리다이렉션합니다. 명령어 \u0026gt; 파일 명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 덮어씁니다. 명령어 \u0026gt;\u0026gt; 파일 명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 이어서 씁니다. 명령어 \u0026lt; 파일 명령어 표준 입력을 파일로 변경합니다. 파일로부터 표준 입력을 받아 명령어를 수행합니다. 파이프 **파이프(pipe)**는 리다이렉션의 한 형태로, 명령어 결과 표준 출력을 다른 명령어의 표준 입력으로 보낼 때 사용합니다. 파이프는 | 문자로 나타냅니다. 권한 유저(user)와 그룹(group) 리눅스에서 유저와 그룹은 리눅스의 권한 시스템을 설명하기 위해 빠뜨릴 수 없는 개념입니다. 리눅스의 각 유저는 이름과 고유한 사용자 ID(UID) 를 가지고 있습니다. 그룹은 말 그대로 여러 유저가 속할 수 있는 그룹으로, 이 역시 그룹 이름과 고유한 그룹 ID(GID) 를 가지고 있습니다.\n파일이나 디렉토리와 같은 시스템 자원에 유저가 접근하면 유저의 UID와 해당 유저가 속한 그룹의 GID를 확인하여 정당한 권한을 가지고 있는지를 판단해 접근을 제어합니다.\n/etc/passwd 는 리눅스의 유저 정보를 담고 있는 텍스트 파일입니다. 각 사용자의 이름, 사용자 ID, 속해있는 그룹 ID 등의 정보를 포함하고 있습니다. cat 명령어로 /etc/passwd 파일의 내용을 확인할 수 있습니다.\n/etc/group 은 리눅스의 그룹 정보를 저장하는 텍스트 파일입니다. 각 그룹의 이름, 그룹 ID, 그룹에 속한 유저 목록 등의 정보를 포함하고 있습니다. cat 명령어로 /etc/group 파일의 내용을 확인할 수 있습니다.\n파일 및 디렉토리 권한 리눅스는 사용자가 파일과 디렉토리에 접근하는 행위에 대해 권한으로 제어합니다. 각 파일과 디렉토리는 **소유자(owner)**와 소유 그룹(group) 을 가지고 있습니다. 소유자는 파일 또는 디렉토리의 권한을 수정할 수 있는 능력을 가지고 있습니다. 소유자는 이를 통해 소유자 또는 소유 그룹에 포함된 유저가 해당 파일 또는 디렉토리에 대해서 얼마만큼 접근 권한을 가질 것인지 설정할 수 있습니다. 다음과 같이 세 종류의 접근 권한이 있습니다.\n읽기(Read): 파일 또는 디렉토리의 내용을 볼 수 있게 허용합니다.\n쓰기(Write): 파일 또는 디렉토리의 내용을 수정하거나 삭제하는 것을 허용합니다.\n실행(Execute): 파일이 프로그램인 경우 실행할 수 있게 허용합니다. 디렉토리의 경우, 디렉토리의 내용에 접근할 수 있도록 허용합니다.\n파일이나 디렉토리의 권한을 보기 위해 ls -l를 사용합니다. 해당 명령어는 디렉토리의 내용을 권한 정보와 함께 출력합니다. 다음은 ls -l 명령어 예시 결과입니다.\n1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ---------- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ 다음은 dir 디렉토리의 예시입니다. 첫 번째 열은 권한 플래그를 나타내고 세 번째 열은 소유자를 나타냅니다. 네 번째 열은 소유 그룹을 나타냅니다. 결과의 첫 번째 행을 가져와 자세히 살펴보겠습니다.\n1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir dir의 권한 플래그는 drwxrwxr-x이고, 소유자는 user이며 소유 그룹은 user 입니다. 각각에 대해 자세히 알아보겠습니다.\n첫 번째 열 drwxrwxr-x : 권한 플래그 1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir 위 결과에서 첫 번째 열이 각 파일 또는 디렉토리의 권한 플래그를 나타냅니다. 권한 플래그는 다음과 같이 4개의 부분으로 나뉠 수 있습니다: d rwx rwx r-x\nd rwx rwx r-x\n먼저 위에서 bold 처리한 첫 번째 문자는 파일의 타입을 나타냅니다. d 는 디렉토리, - 는 일반 파일, l 은 바로가기와 같은 링크 파일을 나타냅니다.\n그 다음 문자들은 권한 플래그입니다. 문자 3개씩 3개의 덩어리로 나뉩니다.\nd rwx rwx r-x\n위에서 bold 처리한 3개의 문자는 파일 또는 디렉토리의 소유자의 권한을 나타냅니다.\nd rwx rwx r-x\n위에서 bold 처리한 3개의 문자는 파일 또는 디렉토리의 소유 그룹에 포함된 유저들의 권한을 나타냅니다.\nd rwx rwx r-x\n위에서 bold 처리한 3개의 문자는 파일 또는 디렉토리의 소유자 및 소유 그룹에 포함된 유저들을 제외한, 나머지 유저들의 권한을 나타냅니다.\n권한을 나타내는 각 문자에 대한 설명은 다음과 같습니다.\nr: 소유자(또는 소유 그룹에 포함된 유저들 또는 그외 유저)가 파일 또는 디렉토리에 읽기(Read) 권한을 가집니다.\nw: 소유자(또는 소유 그룹에 포함된 유저들 또는 그외 유저)가 파일 또는 디렉토리에 쓰기(Write) 권한을 가집니다.\nx: 소유자(또는 소유 그룹에 포함된 유저들 또는 그외 유저)가 파일 또는 디렉토리에 실행(Execute) 권한을 가집니다.\n권한을 나타내는 3개 문자는 2진수나 10진수로도 표현이 가능합니다. 예를 들어 rwx 는 2진수로 111이며, 10진수로는 7입니다. r-- 은 2진수로 100이며, 10진수로는 4입니다.\n세 번째 열 user : 소유자 1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir 위 결과에서 세 번째 열이 파일 또는 디렉토리의 소유자를 나타냅니다.\n소유자는 파일 또는 디렉토리에 대한 제어권을 가지고 있습니다. 소유자는 파일 또는 디렉토리의 권한 플래그를 변경할 수 있고 파일의 소유자 또는 소유 그룹을 변경할 수도 있습니다. 위 dir 디렉토리의 소유자가 user 유저임을 알 수 있습니다.\n네 번째 열 user : 소유 그룹 리눅스에는 여러 사용자를 하나의 집합으로 관리할 수 있는 그룹 기능이 있습니다. 소유 그룹은 그룹 단위로 파일 또는 디렉토리에 권한을 부여할 때 사용합니다. 특정 파일 또는 디렉토리에 대한 접근 권한을 편리하게 그룹 단위로 부여하거나 제한할 수 있어 자주 활용되는 기능입니다.\n결론 앞서 배운 것들을 종합하여 아래의 ls -l 결과를 해석해보겠습니다.\n1 -rwxrw-r-- 1 user user 13 12월 2 13:08 world 우선 소유자는 user 이며 소유 그룹은 user 입니다.\n권한 플래그는 다음과 같습니다.\nrwx rw- r--\n파일 타입을 나타내는 첫 번째 문자가 - 이므로 world는 일반 파일입니다. 소유자 권한 플래그는 rwx 이므로 user 유저는 world 파일을 읽고 쓰고 실행할 수 있습니다. 소유 그룹 권한 플래그는 rw- 이므로 user 그룹에 속한 유저들은 world 파일을 읽고 쓸 수는 있지만 실행할 수는 없습니다. user 유저가 아니면서 user 그룹에 속하지 않은 유저들은 r-- 권한을 가지므로 world 파일을 읽을 수만 있고 쓰거나 실행할 수는 없습니다. 파일 및 디렉토리 권한 명령어 chmod chmod는 파일 권한을 변경하는 명령어입니다. root 유저 혹은 파일의 소유자만 실행할 수 있습니다. chmod 권한 파일명 형식으로 사용합니다. 권한을 표현할 때는 권한 플래그를 10진수로 표현하거나 기존의 권한에 문자를 더하거나 뺍니다.\n다음은 ls -l 명령어 결과입니다. hello 파일에 아무 권한도 부여되지 않은 상태입니다.\nDetails 1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ---------- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ world 파일과 동일하게, 소유자는 읽고 쓰고 실행할 수 있고, 소유 그룹은 읽고 쓸 수 있고, 일반 유저는 읽을 수만 있도록 hello 파일 권한을 수정하겠습니다.\n소유자 권한은 rwx이므로 111=7, 소유 그룹 권한은 rw-이므로 110=6, 일반 유저 권한은 **r\u0026ndash;**이므로 100=4입니다. chmod 764 hello를 실행하면 권한이 아래와 같이 변경됩니다.\nDetails 1 2 3 4 5 6 7 user@user-VirtualBox:~/new_dir$ chmod 764 hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxrw-r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ 이번에는 hello 파일 소유 그룹에 실행 권한을 부여하겠습니다. 다음과 같이 chmod g+x hello 명령어를 실행하면 권한이 변경됩니다. 권한을 제거하고 싶으면 chmod g-wx hello와 같은 형식으로 입력합니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 12 user@user-VirtualBox:~/new_dir$ chmod g+x hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxrwxr-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ chmod g-wx hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world chown chown은 파일 소유자 혹은 소유 그룹을 변경하는 명령어입니다. root 유저만 실행할 수 있습니다. chown 사용자명[.그룹명] 파일명 형식으로 사용합니다. 소유 그룹만 변경하고 싶은 경우 chgrp 명령어를 사용합니다.\nhello 파일의 소유자를 user에서 root로 변경하겠습니다. 명령어를 root 권한으로 실행하려면 맨 앞에 sudo를 붙여줍니다.\nsudo chown root hello 명령어를 실행하면 소유자가 변경됩니다. 이제 user 유저는 hello 파일을 수정할 수 없습니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ sudo chown root hello [sudo] password for user: user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ echo \u0026#34;hello\u0026#34; \u0026gt; hello bash: hello: Permission denied user@user-VirtualBox:~/new_dir$ 특수 권한 앞서 배운 r, w, x 권한 외에 특수한 권한 3가지를 소개하겠습니다.\nsetuid: 일반 사용자가 파일을 실행하면 파일 소유자 권한으로 실행됩니다. 예를 들어, /bin/passwd 파일은 소유자가 root이지만 setuid가 설정되어 있어 일반 사용자가 root 권한으로 실행하고 비밀번호도 변경할 수 있습니다. setuid는 소유자의 실행 권한에 x 대신 s 문자로 나타냅니다. 대문자 S로 표시되는 경우에는 setuid가 걸려 있으나, 실행 권한이 없는 경우입니다. /bin/passwd의 권한 플래그는 다음과 같습니다. 소유자의 실행 권한이 s로 설정된 것을 볼 수 있습니다.\n1 2 user@user-VirtualBox:/bin$ ls -l passwd -rwsr-xr-x 1 root root 59976 11월 24 21:05 passwd setgid: 일반 사용자가 파일을 실행하면 파일 소유 그룹 권한으로 실행됩니다. setgid는 소유 그룹의 실행 권한에 x 대신 s 문자로 나타냅니다. 마찬가지로 실행 권한이 없으나 setgid가 걸려 있는 경우 대문자 S로 표시됩니다. sticky bit: 디렉토리에 sticky bit를 설정하면 파일 및 디렉토리 소유자와 root 사용자 외에 일반 사용자가 파일을 삭제할 수 없습니다. 주로 공용 디렉토리에 사용합니다. 일반 사용자의 실행 권한에 x 대신 t 문자로 나타냅니다. 이 역시 마찬가지로 실행 권한이 없는 경우에는 대문자 T로 표시됩니다. 특수 권한을 지정할 때는 권한 플래그 맨 앞에 숫자를 붙여 나타냅니다. setuid는 4, setgid는 2, sticky bit는 1입니다.\n다음은 chmod 4755 world 명령어로 world 파일에 실행 권한과 setuid를 설정하는 모습입니다. setuid만 설정하는 경우 chmod u+s world도 가능합니다.\nsetgid는 chmod g+s world, sticky bit는 chmod o+t world로 설정할 수 있습니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ chmod 4775 world user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwsrwxr-x 1 user user 13 12월 2 13:08 world 디렉토리 구조 루트 디렉토리 / 루트 디렉토리는 리눅스의 최상위 디렉토리를 말하며, 절대 경로는 / 입니다.\ncd /; ls -l 또는 ls -l /를 실행하면 루트 디렉토리에 존재하는 파일과 디렉토리들을 볼 수 있습니다. 명령어 실행 결과는 다음과 같습니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 user@user-VirtualBox:~$ ls -l / total 3991632 lrwxrwxrwx 1 root root 7 11월 30 18:15 bin -\u0026gt; usr/bin drwxr-xr-x 4 root root 4096 12월 1 14:10 boot drwxrwxr-x 2 root root 4096 11월 30 18:25 cdrom drwxr-xr-x 19 root root 4180 12월 1 14:25 dev drwxr-xr-x 130 root root 12288 12월 1 14:09 etc drwxr-xr-x 3 root root 4096 11월 30 18:27 home lrwxrwxrwx 1 root root 7 11월 30 18:15 lib -\u0026gt; usr/lib lrwxrwxrwx 1 root root 9 11월 30 18:15 lib32 -\u0026gt; usr/lib32 lrwxrwxrwx 1 root root 9 11월 30 18:15 lib64 -\u0026gt; usr/lib64 lrwxrwxrwx 1 root root 10 11월 30 18:15 libx32 -\u0026gt; usr/libx32 drwx------ 2 root root 16384 11월 30 18:14 lost+found drwxr-xr-x 3 root root 4096 11월 30 19:49 media drwxr-xr-x 2 root root 4096 8월 9 20:48 mnt drwxr-xr-x 3 root root 4096 11월 30 19:55 opt dr-xr-xr-x 257 root root 0 12월 1 14:11 proc drwx------ 4 root root 4096 12월 1 14:17 root drwxr-xr-x 33 root root 900 12월 1 14:12 run lrwxrwxrwx 1 root root 8 11월 30 18:15 sbin -\u0026gt; usr/sbin drwxr-xr-x 11 root root 4096 8월 9 20:55 snap drwxr-xr-x 2 root root 4096 8월 9 20:48 srv -rw------- 1 root root 4087349248 11월 30 18:15 swapfile dr-xr-xr-x 13 root root 0 12월 1 14:11 sys drwxrwxrwt 20 root root 4096 12월 1 14:17 tmp drwxr-xr-x 14 root root 4096 8월 9 20:48 usr drwxr-xr-x 14 root root 4096 8월 9 20:54 var user@user-VirtualBox:~$ 위 ls 명령어 실행 결과에서 볼 수 있듯이 루트 디렉토리 안에 많은 디렉토리가 존재합니다. 이중 몇 가지 중요한 디렉토리들을 알아보겠습니다.\n/bin 일반 유저가 사용할 수 있는 기본적인 명령어나 프로그램을 담고 있는 디렉토리입니다. /boot 시스템 부팅에 필요한 파일들을 담고 있는 디렉토리입니다. /dev 리눅스에서는 컴퓨터에 부착된 물리적인 장치들을 디바이스 드라이버를 거쳐 파일 형태로 접근 가능합니다. 그러한 장치들을 나타내는 파일들을 담고 있는 디렉토리입니다. /etc 운영체제나 운영체제 위에서 동작하는 서비스의 설정 파일들을 담고 있는 디렉토리입니다. /home 각 일반 유저의 홈 디렉토리를 담고 있는 디렉토리입니다. 일반 유저들은 각기 자신만의 홈 디렉토리를 가지고 있습니다. 예를 들어 dream 유저의 홈 디렉토리는 /home/dream 입니다. /lib 시스템에 필요한 라이브러리 파일들을 담고 있는 디렉토리입니다. /bin 이나 /sbin 에 존재하는 프로그램이 필요로 하는 동적 라이브러리 파일이 /lib 디렉토리에 존재합니다. /opt 소프트웨어 패키지들을 담는 디렉토리입니다. /proc 리눅스 커널 자원에 접근할 수 있는 파일과 프로세스를 나타내는 파일을 담고 있습니다. /root root 유저의 홈 디렉토리입니다. /sbin /bin 디렉토리와 마찬가지로 기본적인 유저 명령어나 프로그램을 가지고 있는 디렉토리입니다. /sbin은 root 유저가 사용할 수 있는 명령어나 프로그램을 가지고 있습니다. /tmp 유저나 프로그램이 임시로 파일을 생성해야할 때 사용할 수 있는 디렉토리입니다. 본 디렉토리에 오래 존재했던 파일들은 자동으로 삭제되므로 주의하여 사용해야 합니다.\n/usr 사용자 바이너리, 문서, 라이브러리, 헤더 파일 등을 담고 있는 디렉토리입니다.\n/var 프로그램이나 시스템이 실시간으로 가변적인 파일을 사용하고 저장해야 할 때 활용하는 디렉토리입니다. 예를 들어 /var/log에는 다양한 로그 파일이 저장됩니다.\n물론 모든 디렉토리의 모든 파일을 외울 수만 있다면 리눅스를 사용하는데 있어서 많은 도움이 됩니다. 하지만 처음부터 모든 디렉토리의 모든 파일을 다 외워야 하는 것은 아닙니다. 공부할수록 자주 접하는 디렉토리나 파일이 생기게 되고, 그런 것들을 시작으로 자연스럽게 기억하고 이해하게 될 것입니다.\n문제풀이 ls -\u0026gt; cat hint.txt -\u0026gt; cat /dream/hack/hello/flag.txt -\u0026gt; cat app.py -\u0026gt; cat ./dream/hack/hello/f*ag.txt DH{671ce26c70829e716fae26c7c71a33823feb479f2562891f64605bf68f60ae54}\n","permalink":"http://localhost:1313/posts/2026-01-08/","summary":"리눅스 사용법 정리글","title":"리눅스 사용법 한 눈에 살펴보기"},{"content":"1. 개요 (Intro) 안녕하세요, AlwaysHyeon의 보안 블로그입니다. 이 글은 GitHub Pages와 Hugo PaperMod 테마가 정상적으로 연동되었는지 확인하기 위한 테스트 포스트입니다.\n테스트 환경 Generator: Hugo Theme: PaperMod Hosting: GitHub Pages 2. 기능 테스트 (Feature Test) 2.1. 코드 하이라이팅 (Code Block) Python 코드가 예쁘게 나오는지 확인합니다.\n1 2 3 4 5 6 7 8 import os def check_security(): print(\u0026#34;System Secure... maybe?\u0026#34;) return True if __name__ == \u0026#34;__main__\u0026#34;: check_security() ","permalink":"http://localhost:1313/posts/test-post/","summary":"Hugo PaperMod 테마 적용 테스트 글입니다. 마크다운 문법과 코드 하이라이팅이 잘 적용되는지 확인합니다.","title":"블로그 테스트 및 첫 번째 글 (Hello World)"},{"content":"셸(Shell) 유저가 리눅스 시스템을 이용할 수 있는 인터페이스입니다. 터미널 실행 단축키 ctrl + alt + T (윈도우, 리눅스 기준) control + option + T (맥 기준) 셸 프롬프트(Shell Prompt) 셸이 입력 받을 준비가 되었을 때 1 user@user-VirtualBox:~$ id 명령어: 현재 유저의 유저 ID와 해당 유저가 속해 있는 그룹 ID. 1 2 3 user@user-VirtualBox:~$ id uid=1000(user) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),134(lxd),135(sambashare) user@user-VirtualBox:~$ 기초적인 명령어 sudo apt update apt 명령어로 설치 가능한 소프트웨어 패키지 목록을 업데이트합니다. 그리고 각 소프트웨어 별로 어떤 버전을 설치할 수 있는지도 업데이트 합니다. sudo apt upgrade 리눅스에 설치된 소프트웨어 패키지의 버전을 업그레이드합니다. id 리눅스는 권한을 기반으로 파일을 읽고 쓸 수 있기 때문에 주로 자신이 해당하는 권한을 가지고 있는지 확인하기 위해서 사용하는 명령어입니다. pwd Print Working Directory의 줄임말로 현재 작업 중인 디렉토리의 경로를 출력합니다. ls List의 줄임말로 디렉토리의 내용을 출력하는 명령어입니다.\n-l 플래그를 추가한 형태인 ls -l을 실행하면 더 자세한 내용을 출력합니다.\n현재 디렉토리 뿐만 아니라 임의 디렉토리의 내용을 출력하는 것도 가능합니다. 루트 디렉토리인 / 디렉토리의 내용을 출력하는 ls -l /으로 출력 가능합니다.\ncd Change Directory의 줄임말로 작업 중인 디렉토리를 변경하는 명령어입니다. 구분 기호/명령어 설명 예시 절대 경로 / 시작 루트 디렉토리(/)를 시작으로 모든 경로를 전부 적어서 표현하는 방식 /home/user 상대 경로 .. 등 현재 디렉토리를 기준으로 상위 또는 하위 디렉토리로 뻗어 나가는 방식 cd .. (현재 위치에서 부모 디렉토리로 이동) 홈 디렉토리 ~ 현재 로그인한 유저의 홈 디렉토리 cd ~ (내 홈 폴더로 이동) 이전 경로 - 직전에 위치했던 디렉토리 (바로 전 경로) cd - (이전 작업 위치로 복귀) mkdir Make Directory의 줄임말로 디렉토리를 생성하는 명령어입니다.\n/home/user 디렉토리에 위치할 때 mkdir new_dir 명령어로 new_dir 디렉토리를 생성하면, new_dir가 새롭게 추가됩니다.\ntouch touch 명령어는 비어있는 새로운 파일을 만드는 데 사용합니다. 앞서 생성한 new_dir 디렉토리로 이동 후 ls -l 명령어를 실행하면 아무런 파일도 존재하지 않습니다.\n이때 touch new_file 명령어를 실행한 후 ls -l을 실행하면, new_file 파일이 생성되었습니다.\nmv Move의 줄임말로 파일이나 디렉토리의 위치를 옮길 때 사용하는 명령어입니다. 파일이나 디렉토리의 이름을 변경할 때도 사용할 수 있습니다. 1 mv [예전 이름] [변경할 이름] 파일을 옮길 수도 있습니다. 1 2 3 4 5 6 7 8 9 10 11 user@user-VirtualBox:~/new_dir$ ls old_file user@user-VirtualBox:~/new_dir$ ls .. Desktop Downloads new_dir Public Templates Documents Music Pictures snap Videos user@user-VirtualBox:~/new_dir$ mv old_file .. user@user-VirtualBox:~/new_dir$ ls user@user-VirtualBox:~/new_dir$ ls .. Desktop Downloads new_dir Pictures snap Videos Documents Music old_file Public Templates user@user-VirtualBox:~/new_dir$ rm Remove의 줄임말로 파일이나 디렉토리를 삭제하는 명령어입니다. 디렉토리 삭제는 -r 플래그를 추가한 rm -r로 수행할 수 있습니다. cat 파일의 내용을 출력하는 명령어입니다. cat 파일경로 형식으로 사용할 수 있습니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 user@user-VirtualBox:~/new_dir$ cat /etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin ... (생략) user:x:1000:1000:user,,,:/home/user:/bin/bash fwupd-refresh:x:128:136:fwupd-refresh user,,,:/run/systemd:/usr/sbin/nologin vboxadd:x:999:1::/var/run/vboxadd:/bin/false user@user-VirtualBox:~/new_dir$ file 파일의 유형을 출력하는 명령어입니다. 1 2 3 user@user-VirtualBox:~$ file /bin/ls /bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=897f49cafa98c11d63e619e7e40352f855249c13, for GNU/Linux 3.2.0, stripped user@user-VirtualBox:~$ echo 셸에 유저가 입력한 텍스트를 출력합니다. 1 2 3 user@user-VirtualBox:~/new_dir$ echo \u0026#34;Hello world!\u0026#34; Hello world! user@user-VirtualBox:~/new_dir$ ehco 명령어를 사용해서 파일을 생성할 수도 있습니다. echo 명령문 끝에 \u0026gt; 파일명을 이어 붙여 실행하면 파일명 이름을 가지는 파일을 생성하고 echo 뒤에 입력한 내용을 파일 내용으로 저장합니다. 1 2 3 4 5 6 7 8 9 user@user-VirtualBox:~/new_dir$ ls -l total 0 user@user-VirtualBox:~/new_dir$ echo \u0026#34;Hello world!\u0026#34; \u0026gt; hello user@user-VirtualBox:~/new_dir$ ls -l total 4 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello user@user-VirtualBox:~/new_dir$ cat hello Hello world! user@user-VirtualBox:~/new_dir$ cp Copy의 줄임말로 파일이나 디렉토리를 복사하는 명령어입니다. 다음은 위에서 생성한 hello 파일을 world라는 이름으로 복사하는 모습입니다. 디렉토리를 복사할 때는 -r 플래그를 붙인 형태인 cp -r을 사용합니다. 1 2 3 4 5 6 7 8 9 10 11 user@user-VirtualBox:~/new_dir$ ls -l total 4 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello user@user-VirtualBox:~/new_dir$ cp hello world user@user-VirtualBox:~/new_dir$ ls -l total 8 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello -rw-rw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ cat world Hello world! user@user-VirtualBox:~/new_dir$ grep 전체에서 특정 문자열을 찾을 때 사용합니다. grep 문자열 파일 형식으로 사용할 수 있습니다. 다음은 grep root /etc/passwd를 수행하여 /etc/passwd 파일에서 root 문자열이 포함된 행을 출력하는 모습입니다. 1 2 3 user@user-VirtualBox:~/new_dir$ grep root /etc/passwd root:x:0:0:root:/root:/bin/bash nm-openvpn:x:121:127:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin man Manual의 줄임말로 특정 명령어의 매뉴얼을 보여주는 명령어입니다. man [명령어]로 수행할 수 있습니다. curl client URL의 줄임말로 서버에 데이터를 보내거나 서버로부터 받는 데이터 전송 명령어입니다. curl [옵션] URL 형식으로 사용할 수 있으며, HTTP, HTTPS, FTP 등 다양한 프로토콜을 지원합니다. curl 명령어의 주요 옵션들 -o file: 전송 받은 데이터를 파일에 저장합니다. -i: 결과 값에 HTTP 응답 헤더를 포함합니다. -X \u0026quot;method\u0026quot;: HTTP 요청 메소드를 지정합니다. -d \u0026quot;key=value\u0026quot;: HTTP POST 메소드로 데이터를 전송합니다. curl을 이용한 명령어 실행 결과 전송 curl은 워게임 문제를 풀 때도 유용하게 사용됩니다. 예를 들어 풀이자가 명령어 실행 결과를 볼 수 없는 경우, 결과를 curl 명령어에 포함하여 풀이자의 웹 서버로 전송하면 확인이 가능합니다. 1 $ curl \u0026#34;[웹사이트]\u0026#34; -d \u0026#34;`cat [파일]`\u0026#34; 와일드카드 **와일드카드(wildcards)**는 리눅스에서 임의의 다른 문자를 나타낼 수 있는 특수 문자들을 의미합니다. 주로 명령어를 다른 문자열로 대체하기 위해 사용합니다. ? a-z, 0-9 범위 내 임의의 1개 문자로 대체됩니다. * a-z, 0-9 범위 내 임의의 0개 이상 문자로 대체됩니다. [] [문자1-문자2] 혹은 [문자1, 문자2, …] 형태로 범위를 지정합니다. 범위 내 모든 문자로 대체될 수 있습니다. 리다이렉션 **리다이렉션(redirection)**은 모니터에 나타나는 표준 출력 혹은 키보드로 입력하는 표준 입력을 다른 곳으로 변경하는 작업입니다. 주로 어떤 명령어의 결과를 파일로 저장하거나, 다른 명령어의 입력으로 전달하는 형태로 리다이렉션합니다. 명령어 \u0026gt; 파일 명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 덮어씁니다. 명령어 \u0026gt;\u0026gt; 파일 명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 이어서 씁니다. 명령어 \u0026lt; 파일 명령어 표준 입력을 파일로 변경합니다. 파일로부터 표준 입력을 받아 명령어를 수행합니다. 파이프 **파이프(pipe)**는 리다이렉션의 한 형태로, 명령어 결과 표준 출력을 다른 명령어의 표준 입력으로 보낼 때 사용합니다. 파이프는 | 문자로 나타냅니다. 권한 유저(user)와 그룹(group) 리눅스에서 유저와 그룹은 리눅스의 권한 시스템을 설명하기 위해 빠뜨릴 수 없는 개념입니다. 리눅스의 각 유저는 이름과 고유한 사용자 ID(UID) 를 가지고 있습니다. 그룹은 말 그대로 여러 유저가 속할 수 있는 그룹으로, 이 역시 그룹 이름과 고유한 그룹 ID(GID) 를 가지고 있습니다.\n파일이나 디렉토리와 같은 시스템 자원에 유저가 접근하면 유저의 UID와 해당 유저가 속한 그룹의 GID를 확인하여 정당한 권한을 가지고 있는지를 판단해 접근을 제어합니다.\n/etc/passwd 는 리눅스의 유저 정보를 담고 있는 텍스트 파일입니다. 각 사용자의 이름, 사용자 ID, 속해있는 그룹 ID 등의 정보를 포함하고 있습니다. cat 명령어로 /etc/passwd 파일의 내용을 확인할 수 있습니다.\n/etc/group 은 리눅스의 그룹 정보를 저장하는 텍스트 파일입니다. 각 그룹의 이름, 그룹 ID, 그룹에 속한 유저 목록 등의 정보를 포함하고 있습니다. cat 명령어로 /etc/group 파일의 내용을 확인할 수 있습니다.\n파일 및 디렉토리 권한 리눅스는 사용자가 파일과 디렉토리에 접근하는 행위에 대해 권한으로 제어합니다. 각 파일과 디렉토리는 **소유자(owner)**와 소유 그룹(group) 을 가지고 있습니다. 소유자는 파일 또는 디렉토리의 권한을 수정할 수 있는 능력을 가지고 있습니다. 소유자는 이를 통해 소유자 또는 소유 그룹에 포함된 유저가 해당 파일 또는 디렉토리에 대해서 얼마만큼 접근 권한을 가질 것인지 설정할 수 있습니다. 다음과 같이 세 종류의 접근 권한이 있습니다.\n읽기(Read): 파일 또는 디렉토리의 내용을 볼 수 있게 허용합니다.\n쓰기(Write): 파일 또는 디렉토리의 내용을 수정하거나 삭제하는 것을 허용합니다.\n실행(Execute): 파일이 프로그램인 경우 실행할 수 있게 허용합니다. 디렉토리의 경우, 디렉토리의 내용에 접근할 수 있도록 허용합니다.\n파일이나 디렉토리의 권한을 보기 위해 ls -l를 사용합니다. 해당 명령어는 디렉토리의 내용을 권한 정보와 함께 출력합니다. 다음은 ls -l 명령어 예시 결과입니다.\n1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ---------- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ 다음은 dir 디렉토리의 예시입니다. 첫 번째 열은 권한 플래그를 나타내고 세 번째 열은 소유자를 나타냅니다. 네 번째 열은 소유 그룹을 나타냅니다. 결과의 첫 번째 행을 가져와 자세히 살펴보겠습니다.\n1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir dir의 권한 플래그는 drwxrwxr-x이고, 소유자는 user이며 소유 그룹은 user 입니다. 각각에 대해 자세히 알아보겠습니다.\n첫 번째 열 drwxrwxr-x : 권한 플래그 1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir 위 결과에서 첫 번째 열이 각 파일 또는 디렉토리의 권한 플래그를 나타냅니다. 권한 플래그는 다음과 같이 4개의 부분으로 나뉠 수 있습니다: d rwx rwx r-x\nd rwx rwx r-x\n먼저 위에서 bold 처리한 첫 번째 문자는 파일의 타입을 나타냅니다. d 는 디렉토리, - 는 일반 파일, l 은 바로가기와 같은 링크 파일을 나타냅니다.\n그 다음 문자들은 권한 플래그입니다. 문자 3개씩 3개의 덩어리로 나뉩니다.\nd rwx rwx r-x\n위에서 bold 처리한 3개의 문자는 파일 또는 디렉토리의 소유자의 권한을 나타냅니다.\nd rwx rwx r-x\n위에서 bold 처리한 3개의 문자는 파일 또는 디렉토리의 소유 그룹에 포함된 유저들의 권한을 나타냅니다.\nd rwx rwx r-x\n위에서 bold 처리한 3개의 문자는 파일 또는 디렉토리의 소유자 및 소유 그룹에 포함된 유저들을 제외한, 나머지 유저들의 권한을 나타냅니다.\n권한을 나타내는 각 문자에 대한 설명은 다음과 같습니다.\nr: 소유자(또는 소유 그룹에 포함된 유저들 또는 그외 유저)가 파일 또는 디렉토리에 읽기(Read) 권한을 가집니다.\nw: 소유자(또는 소유 그룹에 포함된 유저들 또는 그외 유저)가 파일 또는 디렉토리에 쓰기(Write) 권한을 가집니다.\nx: 소유자(또는 소유 그룹에 포함된 유저들 또는 그외 유저)가 파일 또는 디렉토리에 실행(Execute) 권한을 가집니다.\n권한을 나타내는 3개 문자는 2진수나 10진수로도 표현이 가능합니다. 예를 들어 rwx 는 2진수로 111이며, 10진수로는 7입니다. r-- 은 2진수로 100이며, 10진수로는 4입니다.\n세 번째 열 user : 소유자 1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir 위 결과에서 세 번째 열이 파일 또는 디렉토리의 소유자를 나타냅니다.\n소유자는 파일 또는 디렉토리에 대한 제어권을 가지고 있습니다. 소유자는 파일 또는 디렉토리의 권한 플래그를 변경할 수 있고 파일의 소유자 또는 소유 그룹을 변경할 수도 있습니다. 위 dir 디렉토리의 소유자가 user 유저임을 알 수 있습니다.\n네 번째 열 user : 소유 그룹 리눅스에는 여러 사용자를 하나의 집합으로 관리할 수 있는 그룹 기능이 있습니다. 소유 그룹은 그룹 단위로 파일 또는 디렉토리에 권한을 부여할 때 사용합니다. 특정 파일 또는 디렉토리에 대한 접근 권한을 편리하게 그룹 단위로 부여하거나 제한할 수 있어 자주 활용되는 기능입니다.\n결론 앞서 배운 것들을 종합하여 아래의 ls -l 결과를 해석해보겠습니다.\n1 -rwxrw-r-- 1 user user 13 12월 2 13:08 world 우선 소유자는 user 이며 소유 그룹은 user 입니다.\n권한 플래그는 다음과 같습니다.\nrwx rw- r--\n파일 타입을 나타내는 첫 번째 문자가 - 이므로 world는 일반 파일입니다. 소유자 권한 플래그는 rwx 이므로 user 유저는 world 파일을 읽고 쓰고 실행할 수 있습니다. 소유 그룹 권한 플래그는 rw- 이므로 user 그룹에 속한 유저들은 world 파일을 읽고 쓸 수는 있지만 실행할 수는 없습니다. user 유저가 아니면서 user 그룹에 속하지 않은 유저들은 r-- 권한을 가지므로 world 파일을 읽을 수만 있고 쓰거나 실행할 수는 없습니다. 파일 및 디렉토리 권한 명령어 chmod chmod는 파일 권한을 변경하는 명령어입니다. root 유저 혹은 파일의 소유자만 실행할 수 있습니다. chmod 권한 파일명 형식으로 사용합니다. 권한을 표현할 때는 권한 플래그를 10진수로 표현하거나 기존의 권한에 문자를 더하거나 뺍니다.\n다음은 ls -l 명령어 결과입니다. hello 파일에 아무 권한도 부여되지 않은 상태입니다.\nDetails 1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ---------- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ world 파일과 동일하게, 소유자는 읽고 쓰고 실행할 수 있고, 소유 그룹은 읽고 쓸 수 있고, 일반 유저는 읽을 수만 있도록 hello 파일 권한을 수정하겠습니다.\n소유자 권한은 rwx이므로 111=7, 소유 그룹 권한은 rw-이므로 110=6, 일반 유저 권한은 **r\u0026ndash;**이므로 100=4입니다. chmod 764 hello를 실행하면 권한이 아래와 같이 변경됩니다.\nDetails 1 2 3 4 5 6 7 user@user-VirtualBox:~/new_dir$ chmod 764 hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxrw-r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ 이번에는 hello 파일 소유 그룹에 실행 권한을 부여하겠습니다. 다음과 같이 chmod g+x hello 명령어를 실행하면 권한이 변경됩니다. 권한을 제거하고 싶으면 chmod g-wx hello와 같은 형식으로 입력합니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 12 user@user-VirtualBox:~/new_dir$ chmod g+x hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxrwxr-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ chmod g-wx hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world chown chown은 파일 소유자 혹은 소유 그룹을 변경하는 명령어입니다. root 유저만 실행할 수 있습니다. chown 사용자명[.그룹명] 파일명 형식으로 사용합니다. 소유 그룹만 변경하고 싶은 경우 chgrp 명령어를 사용합니다.\nhello 파일의 소유자를 user에서 root로 변경하겠습니다. 명령어를 root 권한으로 실행하려면 맨 앞에 sudo를 붙여줍니다.\nsudo chown root hello 명령어를 실행하면 소유자가 변경됩니다. 이제 user 유저는 hello 파일을 수정할 수 없습니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ sudo chown root hello [sudo] password for user: user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ echo \u0026#34;hello\u0026#34; \u0026gt; hello bash: hello: Permission denied user@user-VirtualBox:~/new_dir$ 특수 권한 앞서 배운 r, w, x 권한 외에 특수한 권한 3가지를 소개하겠습니다.\nsetuid: 일반 사용자가 파일을 실행하면 파일 소유자 권한으로 실행됩니다. 예를 들어, /bin/passwd 파일은 소유자가 root이지만 setuid가 설정되어 있어 일반 사용자가 root 권한으로 실행하고 비밀번호도 변경할 수 있습니다. setuid는 소유자의 실행 권한에 x 대신 s 문자로 나타냅니다. 대문자 S로 표시되는 경우에는 setuid가 걸려 있으나, 실행 권한이 없는 경우입니다. /bin/passwd의 권한 플래그는 다음과 같습니다. 소유자의 실행 권한이 s로 설정된 것을 볼 수 있습니다.\n1 2 user@user-VirtualBox:/bin$ ls -l passwd -rwsr-xr-x 1 root root 59976 11월 24 21:05 passwd setgid: 일반 사용자가 파일을 실행하면 파일 소유 그룹 권한으로 실행됩니다. setgid는 소유 그룹의 실행 권한에 x 대신 s 문자로 나타냅니다. 마찬가지로 실행 권한이 없으나 setgid가 걸려 있는 경우 대문자 S로 표시됩니다. sticky bit: 디렉토리에 sticky bit를 설정하면 파일 및 디렉토리 소유자와 root 사용자 외에 일반 사용자가 파일을 삭제할 수 없습니다. 주로 공용 디렉토리에 사용합니다. 일반 사용자의 실행 권한에 x 대신 t 문자로 나타냅니다. 이 역시 마찬가지로 실행 권한이 없는 경우에는 대문자 T로 표시됩니다. 특수 권한을 지정할 때는 권한 플래그 맨 앞에 숫자를 붙여 나타냅니다. setuid는 4, setgid는 2, sticky bit는 1입니다.\n다음은 chmod 4755 world 명령어로 world 파일에 실행 권한과 setuid를 설정하는 모습입니다. setuid만 설정하는 경우 chmod u+s world도 가능합니다.\nsetgid는 chmod g+s world, sticky bit는 chmod o+t world로 설정할 수 있습니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ chmod 4775 world user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwsrwxr-x 1 user user 13 12월 2 13:08 world 디렉토리 구조 루트 디렉토리 / 루트 디렉토리는 리눅스의 최상위 디렉토리를 말하며, 절대 경로는 / 입니다.\ncd /; ls -l 또는 ls -l /를 실행하면 루트 디렉토리에 존재하는 파일과 디렉토리들을 볼 수 있습니다. 명령어 실행 결과는 다음과 같습니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 user@user-VirtualBox:~$ ls -l / total 3991632 lrwxrwxrwx 1 root root 7 11월 30 18:15 bin -\u0026gt; usr/bin drwxr-xr-x 4 root root 4096 12월 1 14:10 boot drwxrwxr-x 2 root root 4096 11월 30 18:25 cdrom drwxr-xr-x 19 root root 4180 12월 1 14:25 dev drwxr-xr-x 130 root root 12288 12월 1 14:09 etc drwxr-xr-x 3 root root 4096 11월 30 18:27 home lrwxrwxrwx 1 root root 7 11월 30 18:15 lib -\u0026gt; usr/lib lrwxrwxrwx 1 root root 9 11월 30 18:15 lib32 -\u0026gt; usr/lib32 lrwxrwxrwx 1 root root 9 11월 30 18:15 lib64 -\u0026gt; usr/lib64 lrwxrwxrwx 1 root root 10 11월 30 18:15 libx32 -\u0026gt; usr/libx32 drwx------ 2 root root 16384 11월 30 18:14 lost+found drwxr-xr-x 3 root root 4096 11월 30 19:49 media drwxr-xr-x 2 root root 4096 8월 9 20:48 mnt drwxr-xr-x 3 root root 4096 11월 30 19:55 opt dr-xr-xr-x 257 root root 0 12월 1 14:11 proc drwx------ 4 root root 4096 12월 1 14:17 root drwxr-xr-x 33 root root 900 12월 1 14:12 run lrwxrwxrwx 1 root root 8 11월 30 18:15 sbin -\u0026gt; usr/sbin drwxr-xr-x 11 root root 4096 8월 9 20:55 snap drwxr-xr-x 2 root root 4096 8월 9 20:48 srv -rw------- 1 root root 4087349248 11월 30 18:15 swapfile dr-xr-xr-x 13 root root 0 12월 1 14:11 sys drwxrwxrwt 20 root root 4096 12월 1 14:17 tmp drwxr-xr-x 14 root root 4096 8월 9 20:48 usr drwxr-xr-x 14 root root 4096 8월 9 20:54 var user@user-VirtualBox:~$ 위 ls 명령어 실행 결과에서 볼 수 있듯이 루트 디렉토리 안에 많은 디렉토리가 존재합니다. 이중 몇 가지 중요한 디렉토리들을 알아보겠습니다.\n/bin\n일반 유저가 사용할 수 있는 기본적인 명령어나 프로그램을 담고 있는 디렉토리입니다. /boot\n시스템 부팅에 필요한 파일들을 담고 있는 디렉토리입니다. /dev\n리눅스에서는 컴퓨터에 부착된 물리적인 장치들을 디바이스 드라이버를 거쳐 파일 형태로 접근 가능합니다. 그러한 장치들을 나타내는 파일들을 담고 있는 디렉토리입니다. /etc\n운영체제나 운영체제 위에서 동작하는 서비스의 설정 파일들을 담고 있는 디렉토리입니다. /home\n각 일반 유저의 홈 디렉토리를 담고 있는 디렉토리입니다. 일반 유저들은 각기 자신만의 홈 디렉토리를 가지고 있습니다. 예를 들어 dream 유저의 홈 디렉토리는 /home/dream 입니다. /lib\n시스템에 필요한 라이브러리 파일들을 담고 있는 디렉토리입니다. /bin 이나 /sbin 에 존재하는 프로그램이 필요로 하는 동적 라이브러리 파일이 /lib 디렉토리에 존재합니다. /opt\n소프트웨어 패키지들을 담는 디렉토리입니다. /proc\n리눅스 커널 자원에 접근할 수 있는 파일과 프로세스를 나타내는 파일을 담고 있습니다. /root\nroot 유저의 홈 디렉토리입니다. /sbin\n/bin 디렉토리와 마찬가지로 기본적인 유저 명령어나 프로그램을 가지고 있는 디렉토리입니다. /sbin은 root 유저가 사용할 수 있는 명령어나 프로그램을 가지고 있습니다. /tmp\n유저나 프로그램이 임시로 파일을 생성해야할 때 사용할 수 있는 디렉토리입니다. 본 디렉토리에 오래 존재했던 파일들은 자동으로 삭제되므로 주의하여 사용해야 합니다. /usr\n사용자 바이너리, 문서, 라이브러리, 헤더 파일 등을 담고 있는 디렉토리입니다. /var\n프로그램이나 시스템이 실시간으로 가변적인 파일을 사용하고 저장해야 할 때 활용하는 디렉토리입니다. 예를 들어 /var/log에는 다양한 로그 파일이 저장됩니다. 물론 모든 디렉토리의 모든 파일을 외울 수만 있다면 리눅스를 사용하는데 있어서 많은 도움이 됩니다. 하지만 처음부터 모든 디렉토리의 모든 파일을 다 외워야 하는 것은 아닙니다. 공부할수록 자주 접하는 디렉토리나 파일이 생기게 되고, 그런 것들을 시작으로 자연스럽게 기억하고 이해하게 될 것입니다.\n문제풀이 ls -\u0026gt; cat hint.txt -\u0026gt; cat /dream/hack/hello/flag.txt -\u0026gt; cat app.py -\u0026gt; cat ./dream/hack/hello/f*ag.txt DH{671ce26c70829e716fae26c7c71a33823feb479f2562891f64605bf68f60ae54}\n","permalink":"http://localhost:1313/posts/2026-01-08/","summary":"리눅스 사용법 정리글","title":"리눅스 사용법 한 눈에 살펴보기"},{"content":"1. 개요 (Intro) 안녕하세요, AlwaysHyeon의 보안 블로그입니다. 이 글은 GitHub Pages와 Hugo PaperMod 테마가 정상적으로 연동되었는지 확인하기 위한 테스트 포스트입니다.\n테스트 환경 Generator: Hugo Theme: PaperMod Hosting: GitHub Pages 2. 기능 테스트 (Feature Test) 2.1. 코드 하이라이팅 (Code Block) Python 코드가 예쁘게 나오는지 확인합니다.\n1 2 3 4 5 6 7 8 import os def check_security(): print(\u0026#34;System Secure... maybe?\u0026#34;) return True if __name__ == \u0026#34;__main__\u0026#34;: check_security() ","permalink":"http://localhost:1313/posts/test-post/","summary":"Hugo PaperMod 테마 적용 테스트 글입니다. 마크다운 문법과 코드 하이라이팅이 잘 적용되는지 확인합니다.","title":"블로그 테스트 및 첫 번째 글 (Hello World)"},{"content":"셸(Shell) 유저가 리눅스 시스템을 이용할 수 있는 인터페이스입니다. 터미널 실행 단축키 ctrl + alt + T (윈도우, 리눅스 기준) control + option + T (맥 기준) 셸 프롬프트(Shell Prompt) 셸이 입력 받을 준비가 되었을 때 1 user@user-VirtualBox:~$ id 명령어: 현재 유저의 유저 ID와 해당 유저가 속해 있는 그룹 ID. 1 2 3 user@user-VirtualBox:~$ id uid=1000(user) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),134(lxd),135(sambashare) user@user-VirtualBox:~$ 기초적인 명령어 sudo apt update apt 명령어로 설치 가능한 소프트웨어 패키지 목록을 업데이트합니다. 그리고 각 소프트웨어 별로 어떤 버전을 설치할 수 있는지도 업데이트 합니다. sudo apt upgrade 리눅스에 설치된 소프트웨어 패키지의 버전을 업그레이드합니다. id 리눅스는 권한을 기반으로 파일을 읽고 쓸 수 있기 때문에 주로 자신이 해당하는 권한을 가지고 있는지 확인하기 위해서 사용하는 명령어입니다. pwd Print Working Directory의 줄임말로 현재 작업 중인 디렉토리의 경로를 출력합니다. ls List의 줄임말로 디렉토리의 내용을 출력하는 명령어입니다.\n-l 플래그를 추가한 형태인 ls -l을 실행하면 더 자세한 내용을 출력합니다.\n현재 디렉토리 뿐만 아니라 임의 디렉토리의 내용을 출력하는 것도 가능합니다. 루트 디렉토리인 / 디렉토리의 내용을 출력하는 ls -l /으로 출력 가능합니다.\ncd Change Directory의 줄임말로 작업 중인 디렉토리를 변경하는 명령어입니다. 구분 기호/명령어 설명 예시 절대 경로 / 시작 루트 디렉토리(/)를 시작으로 모든 경로를 전부 적어서 표현하는 방식 /home/user 상대 경로 .. 등 현재 디렉토리를 기준으로 상위 또는 하위 디렉토리로 뻗어 나가는 방식 cd .. (현재 위치에서 부모 디렉토리로 이동) 홈 디렉토리 ~ 현재 로그인한 유저의 홈 디렉토리 cd ~ (내 홈 폴더로 이동) 이전 경로 - 직전에 위치했던 디렉토리 (바로 전 경로) cd - (이전 작업 위치로 복귀) mkdir Make Directory의 줄임말로 디렉토리를 생성하는 명령어입니다.\n/home/user 디렉토리에 위치할 때 mkdir new_dir 명령어로 new_dir 디렉토리를 생성하면, new_dir가 새롭게 추가됩니다.\ntouch touch 명령어는 비어있는 새로운 파일을 만드는 데 사용합니다. 앞서 생성한 new_dir 디렉토리로 이동 후 ls -l 명령어를 실행하면 아무런 파일도 존재하지 않습니다.\n이때 touch new_file 명령어를 실행한 후 ls -l을 실행하면, new_file 파일이 생성되었습니다.\nmv Move의 줄임말로 파일이나 디렉토리의 위치를 옮길 때 사용하는 명령어입니다. 파일이나 디렉토리의 이름을 변경할 때도 사용할 수 있습니다. 1 mv [예전 이름] [변경할 이름] 파일을 옮길 수도 있습니다. 1 2 3 4 5 6 7 8 9 10 11 user@user-VirtualBox:~/new_dir$ ls old_file user@user-VirtualBox:~/new_dir$ ls .. Desktop Downloads new_dir Public Templates Documents Music Pictures snap Videos user@user-VirtualBox:~/new_dir$ mv old_file .. user@user-VirtualBox:~/new_dir$ ls user@user-VirtualBox:~/new_dir$ ls .. Desktop Downloads new_dir Pictures snap Videos Documents Music old_file Public Templates user@user-VirtualBox:~/new_dir$ rm Remove의 줄임말로 파일이나 디렉토리를 삭제하는 명령어입니다. 디렉토리 삭제는 -r 플래그를 추가한 rm -r로 수행할 수 있습니다. cat 파일의 내용을 출력하는 명령어입니다. cat 파일경로 형식으로 사용할 수 있습니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 user@user-VirtualBox:~/new_dir$ cat /etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin ... (생략) user:x:1000:1000:user,,,:/home/user:/bin/bash fwupd-refresh:x:128:136:fwupd-refresh user,,,:/run/systemd:/usr/sbin/nologin vboxadd:x:999:1::/var/run/vboxadd:/bin/false user@user-VirtualBox:~/new_dir$ file 파일의 유형을 출력하는 명령어입니다. 1 2 3 user@user-VirtualBox:~$ file /bin/ls /bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=897f49cafa98c11d63e619e7e40352f855249c13, for GNU/Linux 3.2.0, stripped user@user-VirtualBox:~$ echo 셸에 유저가 입력한 텍스트를 출력합니다. 1 2 3 user@user-VirtualBox:~/new_dir$ echo \u0026#34;Hello world!\u0026#34; Hello world! user@user-VirtualBox:~/new_dir$ ehco 명령어를 사용해서 파일을 생성할 수도 있습니다. echo 명령문 끝에 \u0026gt; 파일명을 이어 붙여 실행하면 파일명 이름을 가지는 파일을 생성하고 echo 뒤에 입력한 내용을 파일 내용으로 저장합니다. 1 2 3 4 5 6 7 8 9 user@user-VirtualBox:~/new_dir$ ls -l total 0 user@user-VirtualBox:~/new_dir$ echo \u0026#34;Hello world!\u0026#34; \u0026gt; hello user@user-VirtualBox:~/new_dir$ ls -l total 4 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello user@user-VirtualBox:~/new_dir$ cat hello Hello world! user@user-VirtualBox:~/new_dir$ cp Copy의 줄임말로 파일이나 디렉토리를 복사하는 명령어입니다. 다음은 위에서 생성한 hello 파일을 world라는 이름으로 복사하는 모습입니다. 디렉토리를 복사할 때는 -r 플래그를 붙인 형태인 cp -r을 사용합니다. 1 2 3 4 5 6 7 8 9 10 11 user@user-VirtualBox:~/new_dir$ ls -l total 4 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello user@user-VirtualBox:~/new_dir$ cp hello world user@user-VirtualBox:~/new_dir$ ls -l total 8 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello -rw-rw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ cat world Hello world! user@user-VirtualBox:~/new_dir$ grep 전체에서 특정 문자열을 찾을 때 사용합니다. grep 문자열 파일 형식으로 사용할 수 있습니다. 다음은 grep root /etc/passwd를 수행하여 /etc/passwd 파일에서 root 문자열이 포함된 행을 출력하는 모습입니다. 1 2 3 user@user-VirtualBox:~/new_dir$ grep root /etc/passwd root:x:0:0:root:/root:/bin/bash nm-openvpn:x:121:127:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin man Manual의 줄임말로 특정 명령어의 매뉴얼을 보여주는 명령어입니다. man [명령어]로 수행할 수 있습니다. curl client URL의 줄임말로 서버에 데이터를 보내거나 서버로부터 받는 데이터 전송 명령어입니다. curl [옵션] URL 형식으로 사용할 수 있으며, HTTP, HTTPS, FTP 등 다양한 프로토콜을 지원합니다. curl 명령어의 주요 옵션들 -o file: 전송 받은 데이터를 파일에 저장합니다. -i: 결과 값에 HTTP 응답 헤더를 포함합니다. -X \u0026quot;method\u0026quot;: HTTP 요청 메소드를 지정합니다. -d \u0026quot;key=value\u0026quot;: HTTP POST 메소드로 데이터를 전송합니다. curl을 이용한 명령어 실행 결과 전송 curl은 워게임 문제를 풀 때도 유용하게 사용됩니다. 예를 들어 풀이자가 명령어 실행 결과를 볼 수 없는 경우, 결과를 curl 명령어에 포함하여 풀이자의 웹 서버로 전송하면 확인이 가능합니다. 1 $ curl \u0026#34;[웹사이트]\u0026#34; -d \u0026#34;`cat [파일]`\u0026#34; 와일드카드 **와일드카드(wildcards)**는 리눅스에서 임의의 다른 문자를 나타낼 수 있는 특수 문자들을 의미합니다. 주로 명령어를 다른 문자열로 대체하기 위해 사용합니다. ? a-z, 0-9 범위 내 임의의 1개 문자로 대체됩니다. * a-z, 0-9 범위 내 임의의 0개 이상 문자로 대체됩니다. [] [문자1-문자2] 혹은 [문자1, 문자2, …] 형태로 범위를 지정합니다. 범위 내 모든 문자로 대체될 수 있습니다. 리다이렉션 **리다이렉션(redirection)**은 모니터에 나타나는 표준 출력 혹은 키보드로 입력하는 표준 입력을 다른 곳으로 변경하는 작업입니다. 주로 어떤 명령어의 결과를 파일로 저장하거나, 다른 명령어의 입력으로 전달하는 형태로 리다이렉션합니다. 명령어 \u0026gt; 파일 명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 덮어씁니다. 명령어 \u0026gt;\u0026gt; 파일 명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 이어서 씁니다. 명령어 \u0026lt; 파일 명령어 표준 입력을 파일로 변경합니다. 파일로부터 표준 입력을 받아 명령어를 수행합니다. 파이프 **파이프(pipe)**는 리다이렉션의 한 형태로, 명령어 결과 표준 출력을 다른 명령어의 표준 입력으로 보낼 때 사용합니다. 파이프는 | 문자로 나타냅니다. 권한 유저(user)와 그룹(group) 리눅스에서 유저와 그룹은 리눅스의 권한 시스템을 설명하기 위해 빠뜨릴 수 없는 개념입니다. 리눅스의 각 유저는 이름과 고유한 사용자 ID(UID) 를 가지고 있습니다. 그룹은 말 그대로 여러 유저가 속할 수 있는 그룹으로, 이 역시 그룹 이름과 고유한 그룹 ID(GID) 를 가지고 있습니다.\n파일이나 디렉토리와 같은 시스템 자원에 유저가 접근하면 유저의 UID와 해당 유저가 속한 그룹의 GID를 확인하여 정당한 권한을 가지고 있는지를 판단해 접근을 제어합니다.\n/etc/passwd 는 리눅스의 유저 정보를 담고 있는 텍스트 파일입니다. 각 사용자의 이름, 사용자 ID, 속해있는 그룹 ID 등의 정보를 포함하고 있습니다. cat 명령어로 /etc/passwd 파일의 내용을 확인할 수 있습니다.\n/etc/group 은 리눅스의 그룹 정보를 저장하는 텍스트 파일입니다. 각 그룹의 이름, 그룹 ID, 그룹에 속한 유저 목록 등의 정보를 포함하고 있습니다. cat 명령어로 /etc/group 파일의 내용을 확인할 수 있습니다.\n파일 및 디렉토리 권한 리눅스는 사용자가 파일과 디렉토리에 접근하는 행위에 대해 권한으로 제어합니다. 각 파일과 디렉토리는 **소유자(owner)**와 소유 그룹(group) 을 가지고 있습니다. 소유자는 파일 또는 디렉토리의 권한을 수정할 수 있는 능력을 가지고 있습니다. 소유자는 이를 통해 소유자 또는 소유 그룹에 포함된 유저가 해당 파일 또는 디렉토리에 대해서 얼마만큼 접근 권한을 가질 것인지 설정할 수 있습니다. 다음과 같이 세 종류의 접근 권한이 있습니다.\n읽기(Read): 파일 또는 디렉토리의 내용을 볼 수 있게 허용합니다.\n쓰기(Write): 파일 또는 디렉토리의 내용을 수정하거나 삭제하는 것을 허용합니다.\n실행(Execute): 파일이 프로그램인 경우 실행할 수 있게 허용합니다. 디렉토리의 경우, 디렉토리의 내용에 접근할 수 있도록 허용합니다.\n파일이나 디렉토리의 권한을 보기 위해 ls -l를 사용합니다. 해당 명령어는 디렉토리의 내용을 권한 정보와 함께 출력합니다. 다음은 ls -l 명령어 예시 결과입니다.\n1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ---------- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ 다음은 dir 디렉토리의 예시입니다. 첫 번째 열은 권한 플래그를 나타내고 세 번째 열은 소유자를 나타냅니다. 네 번째 열은 소유 그룹을 나타냅니다. 결과의 첫 번째 행을 가져와 자세히 살펴보겠습니다.\n1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir dir의 권한 플래그는 drwxrwxr-x이고, 소유자는 user이며 소유 그룹은 user 입니다. 각각에 대해 자세히 알아보겠습니다.\n첫 번째 열 drwxrwxr-x : 권한 플래그 1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir 위 결과에서 첫 번째 열이 각 파일 또는 디렉토리의 권한 플래그를 나타냅니다. 권한 플래그는 다음과 같이 4개의 부분으로 나뉠 수 있습니다: d rwx rwx r-x\nd rwx rwx r-x\n먼저 위에서 bold 처리한 첫 번째 문자는 파일의 타입을 나타냅니다. d 는 디렉토리, - 는 일반 파일, l 은 바로가기와 같은 링크 파일을 나타냅니다.\n그 다음 문자들은 권한 플래그입니다. 문자 3개씩 3개의 덩어리로 나뉩니다.\nd rwx rwx r-x\n위에서 bold 처리한 3개의 문자는 파일 또는 디렉토리의 소유자의 권한을 나타냅니다.\nd rwx rwx r-x\n위에서 bold 처리한 3개의 문자는 파일 또는 디렉토리의 소유 그룹에 포함된 유저들의 권한을 나타냅니다.\nd rwx rwx r-x\n위에서 bold 처리한 3개의 문자는 파일 또는 디렉토리의 소유자 및 소유 그룹에 포함된 유저들을 제외한, 나머지 유저들의 권한을 나타냅니다.\n권한을 나타내는 각 문자에 대한 설명은 다음과 같습니다.\nr: 소유자(또는 소유 그룹에 포함된 유저들 또는 그외 유저)가 파일 또는 디렉토리에 읽기(Read) 권한을 가집니다.\nw: 소유자(또는 소유 그룹에 포함된 유저들 또는 그외 유저)가 파일 또는 디렉토리에 쓰기(Write) 권한을 가집니다.\nx: 소유자(또는 소유 그룹에 포함된 유저들 또는 그외 유저)가 파일 또는 디렉토리에 실행(Execute) 권한을 가집니다.\n권한을 나타내는 3개 문자는 2진수나 10진수로도 표현이 가능합니다. 예를 들어 rwx 는 2진수로 111이며, 10진수로는 7입니다. r-- 은 2진수로 100이며, 10진수로는 4입니다.\n세 번째 열 user : 소유자 1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir 위 결과에서 세 번째 열이 파일 또는 디렉토리의 소유자를 나타냅니다.\n소유자는 파일 또는 디렉토리에 대한 제어권을 가지고 있습니다. 소유자는 파일 또는 디렉토리의 권한 플래그를 변경할 수 있고 파일의 소유자 또는 소유 그룹을 변경할 수도 있습니다. 위 dir 디렉토리의 소유자가 user 유저임을 알 수 있습니다.\n네 번째 열 user : 소유 그룹 리눅스에는 여러 사용자를 하나의 집합으로 관리할 수 있는 그룹 기능이 있습니다. 소유 그룹은 그룹 단위로 파일 또는 디렉토리에 권한을 부여할 때 사용합니다. 특정 파일 또는 디렉토리에 대한 접근 권한을 편리하게 그룹 단위로 부여하거나 제한할 수 있어 자주 활용되는 기능입니다.\n결론 앞서 배운 것들을 종합하여 아래의 ls -l 결과를 해석해보겠습니다.\n1 -rwxrw-r-- 1 user user 13 12월 2 13:08 world 우선 소유자는 user 이며 소유 그룹은 user 입니다.\n권한 플래그는 다음과 같습니다.\nrwx rw- r--\n파일 타입을 나타내는 첫 번째 문자가 - 이므로 world는 일반 파일입니다. 소유자 권한 플래그는 rwx 이므로 user 유저는 world 파일을 읽고 쓰고 실행할 수 있습니다. 소유 그룹 권한 플래그는 rw- 이므로 user 그룹에 속한 유저들은 world 파일을 읽고 쓸 수는 있지만 실행할 수는 없습니다. user 유저가 아니면서 user 그룹에 속하지 않은 유저들은 r-- 권한을 가지므로 world 파일을 읽을 수만 있고 쓰거나 실행할 수는 없습니다. 파일 및 디렉토리 권한 명령어 chmod chmod는 파일 권한을 변경하는 명령어입니다. root 유저 혹은 파일의 소유자만 실행할 수 있습니다. chmod 권한 파일명 형식으로 사용합니다. 권한을 표현할 때는 권한 플래그를 10진수로 표현하거나 기존의 권한에 문자를 더하거나 뺍니다.\n다음은 ls -l 명령어 결과입니다. hello 파일에 아무 권한도 부여되지 않은 상태입니다.\nDetails 1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ---------- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ world 파일과 동일하게, 소유자는 읽고 쓰고 실행할 수 있고, 소유 그룹은 읽고 쓸 수 있고, 일반 유저는 읽을 수만 있도록 hello 파일 권한을 수정하겠습니다.\n소유자 권한은 rwx이므로 111=7, 소유 그룹 권한은 rw-이므로 110=6, 일반 유저 권한은 **r\u0026ndash;**이므로 100=4입니다. chmod 764 hello를 실행하면 권한이 아래와 같이 변경됩니다.\nDetails 1 2 3 4 5 6 7 user@user-VirtualBox:~/new_dir$ chmod 764 hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxrw-r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ 이번에는 hello 파일 소유 그룹에 실행 권한을 부여하겠습니다. 다음과 같이 chmod g+x hello 명령어를 실행하면 권한이 변경됩니다. 권한을 제거하고 싶으면 chmod g-wx hello와 같은 형식으로 입력합니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 12 user@user-VirtualBox:~/new_dir$ chmod g+x hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxrwxr-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ chmod g-wx hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world chown chown은 파일 소유자 혹은 소유 그룹을 변경하는 명령어입니다. root 유저만 실행할 수 있습니다. chown 사용자명[.그룹명] 파일명 형식으로 사용합니다. 소유 그룹만 변경하고 싶은 경우 chgrp 명령어를 사용합니다.\nhello 파일의 소유자를 user에서 root로 변경하겠습니다. 명령어를 root 권한으로 실행하려면 맨 앞에 sudo를 붙여줍니다.\nsudo chown root hello 명령어를 실행하면 소유자가 변경됩니다. 이제 user 유저는 hello 파일을 수정할 수 없습니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ sudo chown root hello [sudo] password for user: user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ echo \u0026#34;hello\u0026#34; \u0026gt; hello bash: hello: Permission denied user@user-VirtualBox:~/new_dir$ 특수 권한 앞서 배운 r, w, x 권한 외에 특수한 권한 3가지를 소개하겠습니다.\nsetuid: 일반 사용자가 파일을 실행하면 파일 소유자 권한으로 실행됩니다. 예를 들어, /bin/passwd 파일은 소유자가 root이지만 setuid가 설정되어 있어 일반 사용자가 root 권한으로 실행하고 비밀번호도 변경할 수 있습니다. setuid는 소유자의 실행 권한에 x 대신 s 문자로 나타냅니다. 대문자 S로 표시되는 경우에는 setuid가 걸려 있으나, 실행 권한이 없는 경우입니다. /bin/passwd의 권한 플래그는 다음과 같습니다. 소유자의 실행 권한이 s로 설정된 것을 볼 수 있습니다.\n1 2 user@user-VirtualBox:/bin$ ls -l passwd -rwsr-xr-x 1 root root 59976 11월 24 21:05 passwd setgid: 일반 사용자가 파일을 실행하면 파일 소유 그룹 권한으로 실행됩니다. setgid는 소유 그룹의 실행 권한에 x 대신 s 문자로 나타냅니다. 마찬가지로 실행 권한이 없으나 setgid가 걸려 있는 경우 대문자 S로 표시됩니다. sticky bit: 디렉토리에 sticky bit를 설정하면 파일 및 디렉토리 소유자와 root 사용자 외에 일반 사용자가 파일을 삭제할 수 없습니다. 주로 공용 디렉토리에 사용합니다. 일반 사용자의 실행 권한에 x 대신 t 문자로 나타냅니다. 이 역시 마찬가지로 실행 권한이 없는 경우에는 대문자 T로 표시됩니다. 특수 권한을 지정할 때는 권한 플래그 맨 앞에 숫자를 붙여 나타냅니다. setuid는 4, setgid는 2, sticky bit는 1입니다.\n다음은 chmod 4755 world 명령어로 world 파일에 실행 권한과 setuid를 설정하는 모습입니다. setuid만 설정하는 경우 chmod u+s world도 가능합니다.\nsetgid는 chmod g+s world, sticky bit는 chmod o+t world로 설정할 수 있습니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ chmod 4775 world user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwsrwxr-x 1 user user 13 12월 2 13:08 world 디렉토리 구조 루트 디렉토리 / 루트 디렉토리는 리눅스의 최상위 디렉토리를 말하며, 절대 경로는 / 입니다.\ncd /; ls -l 또는 ls -l /를 실행하면 루트 디렉토리에 존재하는 파일과 디렉토리들을 볼 수 있습니다. 명령어 실행 결과는 다음과 같습니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 user@user-VirtualBox:~$ ls -l / total 3991632 lrwxrwxrwx 1 root root 7 11월 30 18:15 bin -\u0026gt; usr/bin drwxr-xr-x 4 root root 4096 12월 1 14:10 boot drwxrwxr-x 2 root root 4096 11월 30 18:25 cdrom drwxr-xr-x 19 root root 4180 12월 1 14:25 dev drwxr-xr-x 130 root root 12288 12월 1 14:09 etc drwxr-xr-x 3 root root 4096 11월 30 18:27 home lrwxrwxrwx 1 root root 7 11월 30 18:15 lib -\u0026gt; usr/lib lrwxrwxrwx 1 root root 9 11월 30 18:15 lib32 -\u0026gt; usr/lib32 lrwxrwxrwx 1 root root 9 11월 30 18:15 lib64 -\u0026gt; usr/lib64 lrwxrwxrwx 1 root root 10 11월 30 18:15 libx32 -\u0026gt; usr/libx32 drwx------ 2 root root 16384 11월 30 18:14 lost+found drwxr-xr-x 3 root root 4096 11월 30 19:49 media drwxr-xr-x 2 root root 4096 8월 9 20:48 mnt drwxr-xr-x 3 root root 4096 11월 30 19:55 opt dr-xr-xr-x 257 root root 0 12월 1 14:11 proc drwx------ 4 root root 4096 12월 1 14:17 root drwxr-xr-x 33 root root 900 12월 1 14:12 run lrwxrwxrwx 1 root root 8 11월 30 18:15 sbin -\u0026gt; usr/sbin drwxr-xr-x 11 root root 4096 8월 9 20:55 snap drwxr-xr-x 2 root root 4096 8월 9 20:48 srv -rw------- 1 root root 4087349248 11월 30 18:15 swapfile dr-xr-xr-x 13 root root 0 12월 1 14:11 sys drwxrwxrwt 20 root root 4096 12월 1 14:17 tmp drwxr-xr-x 14 root root 4096 8월 9 20:48 usr drwxr-xr-x 14 root root 4096 8월 9 20:54 var user@user-VirtualBox:~$ 위 ls 명령어 실행 결과에서 볼 수 있듯이 루트 디렉토리 안에 많은 디렉토리가 존재합니다. 이중 몇 가지 중요한 디렉토리들을 알아보겠습니다.\n/bin\n일반 유저가 사용할 수 있는 기본적인 명령어나 프로그램을 담고 있는 디렉토리입니다. /boot\n시스템 부팅에 필요한 파일들을 담고 있는 디렉토리입니다. /dev\n리눅스에서는 컴퓨터에 부착된 물리적인 장치들을 디바이스 드라이버를 거쳐 파일 형태로 접근 가능합니다. 그러한 장치들을 나타내는 파일들을 담고 있는 디렉토리입니다. /etc\n운영체제나 운영체제 위에서 동작하는 서비스의 설정 파일들을 담고 있는 디렉토리입니다. /home\n각 일반 유저의 홈 디렉토리를 담고 있는 디렉토리입니다. 일반 유저들은 각기 자신만의 홈 디렉토리를 가지고 있습니다. 예를 들어 dream 유저의 홈 디렉토리는 /home/dream 입니다. /lib\n시스템에 필요한 라이브러리 파일들을 담고 있는 디렉토리입니다. /bin 이나 /sbin 에 존재하는 프로그램이 필요로 하는 동적 라이브러리 파일이 /lib 디렉토리에 존재합니다. /opt\n소프트웨어 패키지들을 담는 디렉토리입니다. /proc\n리눅스 커널 자원에 접근할 수 있는 파일과 프로세스를 나타내는 파일을 담고 있습니다. /root\nroot 유저의 홈 디렉토리입니다. /sbin\n/bin 디렉토리와 마찬가지로 기본적인 유저 명령어나 프로그램을 가지고 있는 디렉토리입니다. /sbin은 root 유저가 사용할 수 있는 명령어나 프로그램을 가지고 있습니다. /tmp\n유저나 프로그램이 임시로 파일을 생성해야할 때 사용할 수 있는 디렉토리입니다. 본 디렉토리에 오래 존재했던 파일들은 자동으로 삭제되므로 주의하여 사용해야 합니다. /usr\n사용자 바이너리, 문서, 라이브러리, 헤더 파일 등을 담고 있는 디렉토리입니다. /var\n프로그램이나 시스템이 실시간으로 가변적인 파일을 사용하고 저장해야 할 때 활용하는 디렉토리입니다. 예를 들어 /var/log에는 다양한 로그 파일이 저장됩니다. 물론 모든 디렉토리의 모든 파일을 외울 수만 있다면 리눅스를 사용하는데 있어서 많은 도움이 됩니다. 하지만 처음부터 모든 디렉토리의 모든 파일을 다 외워야 하는 것은 아닙니다. 공부할수록 자주 접하는 디렉토리나 파일이 생기게 되고, 그런 것들을 시작으로 자연스럽게 기억하고 이해하게 될 것입니다.\n문제풀이 ls -\u0026gt; cat hint.txt -\u0026gt; cat /dream/hack/hello/flag.txt -\u0026gt; cat app.py -\u0026gt; cat ./dream/hack/hello/f*ag.txt DH{671ce26c70829e716fae26c7c71a33823feb479f2562891f64605bf68f60ae54}\n","permalink":"http://localhost:1313/posts/2026-01-08/","summary":"리눅스 사용법 정리글","title":"리눅스 사용법 한 눈에 살펴보기"},{"content":"1. 개요 (Intro) 안녕하세요, AlwaysHyeon의 보안 블로그입니다. 이 글은 GitHub Pages와 Hugo PaperMod 테마가 정상적으로 연동되었는지 확인하기 위한 테스트 포스트입니다.\n테스트 환경 Generator: Hugo Theme: PaperMod Hosting: GitHub Pages 2. 기능 테스트 (Feature Test) 2.1. 코드 하이라이팅 (Code Block) Python 코드가 예쁘게 나오는지 확인합니다.\n1 2 3 4 5 6 7 8 import os def check_security(): print(\u0026#34;System Secure... maybe?\u0026#34;) return True if __name__ == \u0026#34;__main__\u0026#34;: check_security() ","permalink":"http://localhost:1313/posts/test-post/","summary":"Hugo PaperMod 테마 적용 테스트 글입니다. 마크다운 문법과 코드 하이라이팅이 잘 적용되는지 확인합니다.","title":"블로그 테스트 및 첫 번째 글 (Hello World)"},{"content":"셸(Shell) 유저가 리눅스 시스템을 이용할 수 있는 인터페이스입니다. 터미널 실행 단축키 ctrl + alt + T (윈도우, 리눅스 기준) control + option + T (맥 기준) 셸 프롬프트(Shell Prompt) 셸이 입력 받을 준비가 되었을 때 1 user@user-VirtualBox:~$ id 명령어: 현재 유저의 유저 ID와 해당 유저가 속해 있는 그룹 ID. 1 2 3 user@user-VirtualBox:~$ id uid=1000(user) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),134(lxd),135(sambashare) user@user-VirtualBox:~$ 기초적인 명령어 sudo apt update apt 명령어로 설치 가능한 소프트웨어 패키지 목록을 업데이트합니다. 그리고 각 소프트웨어 별로 어떤 버전을 설치할 수 있는지도 업데이트 합니다. sudo apt upgrade 리눅스에 설치된 소프트웨어 패키지의 버전을 업그레이드합니다. id 리눅스는 권한을 기반으로 파일을 읽고 쓸 수 있기 때문에 주로 자신이 해당하는 권한을 가지고 있는지 확인하기 위해서 사용하는 명령어입니다. pwd Print Working Directory의 줄임말로 현재 작업 중인 디렉토리의 경로를 출력합니다. ls List의 줄임말로 디렉토리의 내용을 출력하는 명령어입니다.\n-l 플래그를 추가한 형태인 ls -l을 실행하면 더 자세한 내용을 출력합니다.\n현재 디렉토리 뿐만 아니라 임의 디렉토리의 내용을 출력하는 것도 가능합니다. 루트 디렉토리인 / 디렉토리의 내용을 출력하는 ls -l /으로 출력 가능합니다.\ncd Change Directory의 줄임말로 작업 중인 디렉토리를 변경하는 명령어입니다. 구분 기호/명령어 설명 예시 절대 경로 / 시작 루트 디렉토리(/)를 시작으로 모든 경로를 전부 적어서 표현하는 방식 /home/user 상대 경로 .. 등 현재 디렉토리를 기준으로 상위 또는 하위 디렉토리로 뻗어 나가는 방식 cd .. (현재 위치에서 부모 디렉토리로 이동) 홈 디렉토리 ~ 현재 로그인한 유저의 홈 디렉토리 cd ~ (내 홈 폴더로 이동) 이전 경로 - 직전에 위치했던 디렉토리 (바로 전 경로) cd - (이전 작업 위치로 복귀) mkdir Make Directory의 줄임말로 디렉토리를 생성하는 명령어입니다.\n/home/user 디렉토리에 위치할 때 mkdir new_dir 명령어로 new_dir 디렉토리를 생성하면, new_dir가 새롭게 추가됩니다.\ntouch touch 명령어는 비어있는 새로운 파일을 만드는 데 사용합니다. 앞서 생성한 new_dir 디렉토리로 이동 후 ls -l 명령어를 실행하면 아무런 파일도 존재하지 않습니다.\n이때 touch new_file 명령어를 실행한 후 ls -l을 실행하면, new_file 파일이 생성되었습니다.\nmv Move의 줄임말로 파일이나 디렉토리의 위치를 옮길 때 사용하는 명령어입니다. 파일이나 디렉토리의 이름을 변경할 때도 사용할 수 있습니다. 1 mv [예전 이름] [변경할 이름] 파일을 옮길 수도 있습니다. 1 2 3 4 5 6 7 8 9 10 11 user@user-VirtualBox:~/new_dir$ ls old_file user@user-VirtualBox:~/new_dir$ ls .. Desktop Downloads new_dir Public Templates Documents Music Pictures snap Videos user@user-VirtualBox:~/new_dir$ mv old_file .. user@user-VirtualBox:~/new_dir$ ls user@user-VirtualBox:~/new_dir$ ls .. Desktop Downloads new_dir Pictures snap Videos Documents Music old_file Public Templates user@user-VirtualBox:~/new_dir$ rm Remove의 줄임말로 파일이나 디렉토리를 삭제하는 명령어입니다. 디렉토리 삭제는 -r 플래그를 추가한 rm -r로 수행할 수 있습니다. cat 파일의 내용을 출력하는 명령어입니다. cat 파일경로 형식으로 사용할 수 있습니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 user@user-VirtualBox:~/new_dir$ cat /etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin ... (생략) user:x:1000:1000:user,,,:/home/user:/bin/bash fwupd-refresh:x:128:136:fwupd-refresh user,,,:/run/systemd:/usr/sbin/nologin vboxadd:x:999:1::/var/run/vboxadd:/bin/false user@user-VirtualBox:~/new_dir$ file 파일의 유형을 출력하는 명령어입니다. 1 2 3 user@user-VirtualBox:~$ file /bin/ls /bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=897f49cafa98c11d63e619e7e40352f855249c13, for GNU/Linux 3.2.0, stripped user@user-VirtualBox:~$ echo 셸에 유저가 입력한 텍스트를 출력합니다. 1 2 3 user@user-VirtualBox:~/new_dir$ echo \u0026#34;Hello world!\u0026#34; Hello world! user@user-VirtualBox:~/new_dir$ ehco 명령어를 사용해서 파일을 생성할 수도 있습니다. echo 명령문 끝에 \u0026gt; 파일명을 이어 붙여 실행하면 파일명 이름을 가지는 파일을 생성하고 echo 뒤에 입력한 내용을 파일 내용으로 저장합니다. 1 2 3 4 5 6 7 8 9 user@user-VirtualBox:~/new_dir$ ls -l total 0 user@user-VirtualBox:~/new_dir$ echo \u0026#34;Hello world!\u0026#34; \u0026gt; hello user@user-VirtualBox:~/new_dir$ ls -l total 4 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello user@user-VirtualBox:~/new_dir$ cat hello Hello world! user@user-VirtualBox:~/new_dir$ cp Copy의 줄임말로 파일이나 디렉토리를 복사하는 명령어입니다. 다음은 위에서 생성한 hello 파일을 world라는 이름으로 복사하는 모습입니다. 디렉토리를 복사할 때는 -r 플래그를 붙인 형태인 cp -r을 사용합니다. 1 2 3 4 5 6 7 8 9 10 11 user@user-VirtualBox:~/new_dir$ ls -l total 4 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello user@user-VirtualBox:~/new_dir$ cp hello world user@user-VirtualBox:~/new_dir$ ls -l total 8 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello -rw-rw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ cat world Hello world! user@user-VirtualBox:~/new_dir$ grep 전체에서 특정 문자열을 찾을 때 사용합니다. grep 문자열 파일 형식으로 사용할 수 있습니다. 다음은 grep root /etc/passwd를 수행하여 /etc/passwd 파일에서 root 문자열이 포함된 행을 출력하는 모습입니다. 1 2 3 user@user-VirtualBox:~/new_dir$ grep root /etc/passwd root:x:0:0:root:/root:/bin/bash nm-openvpn:x:121:127:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin man Manual의 줄임말로 특정 명령어의 매뉴얼을 보여주는 명령어입니다. man [명령어]로 수행할 수 있습니다. curl client URL의 줄임말로 서버에 데이터를 보내거나 서버로부터 받는 데이터 전송 명령어입니다. curl [옵션] URL 형식으로 사용할 수 있으며, HTTP, HTTPS, FTP 등 다양한 프로토콜을 지원합니다. curl 명령어의 주요 옵션들 -o file: 전송 받은 데이터를 파일에 저장합니다. -i: 결과 값에 HTTP 응답 헤더를 포함합니다. -X \u0026quot;method\u0026quot;: HTTP 요청 메소드를 지정합니다. -d \u0026quot;key=value\u0026quot;: HTTP POST 메소드로 데이터를 전송합니다. curl을 이용한 명령어 실행 결과 전송 curl은 워게임 문제를 풀 때도 유용하게 사용됩니다. 예를 들어 풀이자가 명령어 실행 결과를 볼 수 없는 경우, 결과를 curl 명령어에 포함하여 풀이자의 웹 서버로 전송하면 확인이 가능합니다. 1 $ curl \u0026#34;[웹사이트]\u0026#34; -d \u0026#34;`cat [파일]`\u0026#34; 와일드카드 **와일드카드(wildcards)**는 리눅스에서 임의의 다른 문자를 나타낼 수 있는 특수 문자들을 의미합니다. 주로 명령어를 다른 문자열로 대체하기 위해 사용합니다. ? a-z, 0-9 범위 내 임의의 1개 문자로 대체됩니다. * a-z, 0-9 범위 내 임의의 0개 이상 문자로 대체됩니다. [] [문자1-문자2] 혹은 [문자1, 문자2, …] 형태로 범위를 지정합니다. 범위 내 모든 문자로 대체될 수 있습니다. 리다이렉션 **리다이렉션(redirection)**은 모니터에 나타나는 표준 출력 혹은 키보드로 입력하는 표준 입력을 다른 곳으로 변경하는 작업입니다. 주로 어떤 명령어의 결과를 파일로 저장하거나, 다른 명령어의 입력으로 전달하는 형태로 리다이렉션합니다. 명령어 \u0026gt; 파일 명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 덮어씁니다. 명령어 \u0026gt;\u0026gt; 파일 명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 이어서 씁니다. 명령어 \u0026lt; 파일 명령어 표준 입력을 파일로 변경합니다. 파일로부터 표준 입력을 받아 명령어를 수행합니다. 파이프 **파이프(pipe)**는 리다이렉션의 한 형태로, 명령어 결과 표준 출력을 다른 명령어의 표준 입력으로 보낼 때 사용합니다. 파이프는 | 문자로 나타냅니다. 권한 유저(user)와 그룹(group) 리눅스에서 유저와 그룹은 리눅스의 권한 시스템을 설명하기 위해 빠뜨릴 수 없는 개념입니다. 리눅스의 각 유저는 이름과 고유한 사용자 ID(UID) 를 가지고 있습니다. 그룹은 말 그대로 여러 유저가 속할 수 있는 그룹으로, 이 역시 그룹 이름과 고유한 그룹 ID(GID) 를 가지고 있습니다.\n파일이나 디렉토리와 같은 시스템 자원에 유저가 접근하면 유저의 UID와 해당 유저가 속한 그룹의 GID를 확인하여 정당한 권한을 가지고 있는지를 판단해 접근을 제어합니다.\n/etc/passwd 는 리눅스의 유저 정보를 담고 있는 텍스트 파일입니다. 각 사용자의 이름, 사용자 ID, 속해있는 그룹 ID 등의 정보를 포함하고 있습니다. cat 명령어로 /etc/passwd 파일의 내용을 확인할 수 있습니다.\n/etc/group 은 리눅스의 그룹 정보를 저장하는 텍스트 파일입니다. 각 그룹의 이름, 그룹 ID, 그룹에 속한 유저 목록 등의 정보를 포함하고 있습니다. cat 명령어로 /etc/group 파일의 내용을 확인할 수 있습니다.\n파일 및 디렉토리 권한 리눅스는 사용자가 파일과 디렉토리에 접근하는 행위에 대해 권한으로 제어합니다. 각 파일과 디렉토리는 **소유자(owner)**와 소유 그룹(group) 을 가지고 있습니다. 소유자는 파일 또는 디렉토리의 권한을 수정할 수 있는 능력을 가지고 있습니다. 소유자는 이를 통해 소유자 또는 소유 그룹에 포함된 유저가 해당 파일 또는 디렉토리에 대해서 얼마만큼 접근 권한을 가질 것인지 설정할 수 있습니다. 다음과 같이 세 종류의 접근 권한이 있습니다.\n읽기(Read): 파일 또는 디렉토리의 내용을 볼 수 있게 허용합니다.\n쓰기(Write): 파일 또는 디렉토리의 내용을 수정하거나 삭제하는 것을 허용합니다.\n실행(Execute): 파일이 프로그램인 경우 실행할 수 있게 허용합니다. 디렉토리의 경우, 디렉토리의 내용에 접근할 수 있도록 허용합니다.\n파일이나 디렉토리의 권한을 보기 위해 ls -l를 사용합니다. 해당 명령어는 디렉토리의 내용을 권한 정보와 함께 출력합니다. 다음은 ls -l 명령어 예시 결과입니다.\n1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ---------- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ 다음은 dir 디렉토리의 예시입니다. 첫 번째 열은 권한 플래그를 나타내고 세 번째 열은 소유자를 나타냅니다. 네 번째 열은 소유 그룹을 나타냅니다. 결과의 첫 번째 행을 가져와 자세히 살펴보겠습니다.\n1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir dir의 권한 플래그는 drwxrwxr-x이고, 소유자는 user이며 소유 그룹은 user 입니다. 각각에 대해 자세히 알아보겠습니다.\n첫 번째 열 drwxrwxr-x : 권한 플래그 1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir 위 결과에서 첫 번째 열이 각 파일 또는 디렉토리의 권한 플래그를 나타냅니다. 권한 플래그는 다음과 같이 4개의 부분으로 나뉠 수 있습니다: d rwx rwx r-x\nd rwx rwx r-x\n먼저 위에서 bold 처리한 첫 번째 문자는 파일의 타입을 나타냅니다. d 는 디렉토리, - 는 일반 파일, l 은 바로가기와 같은 링크 파일을 나타냅니다.\n그 다음 문자들은 권한 플래그입니다. 문자 3개씩 3개의 덩어리로 나뉩니다.\nd rwx rwx r-x\n위에서 bold 처리한 3개의 문자는 파일 또는 디렉토리의 소유자의 권한을 나타냅니다.\nd rwx rwx r-x\n위에서 bold 처리한 3개의 문자는 파일 또는 디렉토리의 소유 그룹에 포함된 유저들의 권한을 나타냅니다.\nd rwx rwx r-x\n위에서 bold 처리한 3개의 문자는 파일 또는 디렉토리의 소유자 및 소유 그룹에 포함된 유저들을 제외한, 나머지 유저들의 권한을 나타냅니다.\n권한을 나타내는 각 문자에 대한 설명은 다음과 같습니다.\nr: 소유자(또는 소유 그룹에 포함된 유저들 또는 그외 유저)가 파일 또는 디렉토리에 읽기(Read) 권한을 가집니다.\nw: 소유자(또는 소유 그룹에 포함된 유저들 또는 그외 유저)가 파일 또는 디렉토리에 쓰기(Write) 권한을 가집니다.\nx: 소유자(또는 소유 그룹에 포함된 유저들 또는 그외 유저)가 파일 또는 디렉토리에 실행(Execute) 권한을 가집니다.\n권한을 나타내는 3개 문자는 2진수나 10진수로도 표현이 가능합니다. 예를 들어 rwx 는 2진수로 111이며, 10진수로는 7입니다. r-- 은 2진수로 100이며, 10진수로는 4입니다.\n세 번째 열 user : 소유자 1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir 위 결과에서 세 번째 열이 파일 또는 디렉토리의 소유자를 나타냅니다.\n소유자는 파일 또는 디렉토리에 대한 제어권을 가지고 있습니다. 소유자는 파일 또는 디렉토리의 권한 플래그를 변경할 수 있고 파일의 소유자 또는 소유 그룹을 변경할 수도 있습니다. 위 dir 디렉토리의 소유자가 user 유저임을 알 수 있습니다.\n네 번째 열 user : 소유 그룹 리눅스에는 여러 사용자를 하나의 집합으로 관리할 수 있는 그룹 기능이 있습니다. 소유 그룹은 그룹 단위로 파일 또는 디렉토리에 권한을 부여할 때 사용합니다. 특정 파일 또는 디렉토리에 대한 접근 권한을 편리하게 그룹 단위로 부여하거나 제한할 수 있어 자주 활용되는 기능입니다.\n결론 앞서 배운 것들을 종합하여 아래의 ls -l 결과를 해석해보겠습니다.\n1 -rwxrw-r-- 1 user user 13 12월 2 13:08 world 우선 소유자는 user 이며 소유 그룹은 user 입니다.\n권한 플래그는 다음과 같습니다.\nrwx rw- r--\n파일 타입을 나타내는 첫 번째 문자가 - 이므로 world는 일반 파일입니다. 소유자 권한 플래그는 rwx 이므로 user 유저는 world 파일을 읽고 쓰고 실행할 수 있습니다. 소유 그룹 권한 플래그는 rw- 이므로 user 그룹에 속한 유저들은 world 파일을 읽고 쓸 수는 있지만 실행할 수는 없습니다. user 유저가 아니면서 user 그룹에 속하지 않은 유저들은 r-- 권한을 가지므로 world 파일을 읽을 수만 있고 쓰거나 실행할 수는 없습니다. 파일 및 디렉토리 권한 명령어 chmod chmod는 파일 권한을 변경하는 명령어입니다. root 유저 혹은 파일의 소유자만 실행할 수 있습니다. chmod 권한 파일명 형식으로 사용합니다. 권한을 표현할 때는 권한 플래그를 10진수로 표현하거나 기존의 권한에 문자를 더하거나 뺍니다.\n다음은 ls -l 명령어 결과입니다. hello 파일에 아무 권한도 부여되지 않은 상태입니다.\nDetails 1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ---------- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ world 파일과 동일하게, 소유자는 읽고 쓰고 실행할 수 있고, 소유 그룹은 읽고 쓸 수 있고, 일반 유저는 읽을 수만 있도록 hello 파일 권한을 수정하겠습니다.\n소유자 권한은 rwx이므로 111=7, 소유 그룹 권한은 rw-이므로 110=6, 일반 유저 권한은 **r\u0026ndash;**이므로 100=4입니다. chmod 764 hello를 실행하면 권한이 아래와 같이 변경됩니다.\nDetails 1 2 3 4 5 6 7 user@user-VirtualBox:~/new_dir$ chmod 764 hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxrw-r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ 이번에는 hello 파일 소유 그룹에 실행 권한을 부여하겠습니다. 다음과 같이 chmod g+x hello 명령어를 실행하면 권한이 변경됩니다. 권한을 제거하고 싶으면 chmod g-wx hello와 같은 형식으로 입력합니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 12 user@user-VirtualBox:~/new_dir$ chmod g+x hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxrwxr-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ chmod g-wx hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world chown chown은 파일 소유자 혹은 소유 그룹을 변경하는 명령어입니다. root 유저만 실행할 수 있습니다. chown 사용자명[.그룹명] 파일명 형식으로 사용합니다. 소유 그룹만 변경하고 싶은 경우 chgrp 명령어를 사용합니다.\nhello 파일의 소유자를 user에서 root로 변경하겠습니다. 명령어를 root 권한으로 실행하려면 맨 앞에 sudo를 붙여줍니다.\nsudo chown root hello 명령어를 실행하면 소유자가 변경됩니다. 이제 user 유저는 hello 파일을 수정할 수 없습니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ sudo chown root hello [sudo] password for user: user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ echo \u0026#34;hello\u0026#34; \u0026gt; hello bash: hello: Permission denied user@user-VirtualBox:~/new_dir$ 특수 권한 앞서 배운 r, w, x 권한 외에 특수한 권한 3가지를 소개하겠습니다.\nsetuid: 일반 사용자가 파일을 실행하면 파일 소유자 권한으로 실행됩니다. 예를 들어, /bin/passwd 파일은 소유자가 root이지만 setuid가 설정되어 있어 일반 사용자가 root 권한으로 실행하고 비밀번호도 변경할 수 있습니다. setuid는 소유자의 실행 권한에 x 대신 s 문자로 나타냅니다. 대문자 S로 표시되는 경우에는 setuid가 걸려 있으나, 실행 권한이 없는 경우입니다. /bin/passwd의 권한 플래그는 다음과 같습니다. 소유자의 실행 권한이 s로 설정된 것을 볼 수 있습니다.\n1 2 user@user-VirtualBox:/bin$ ls -l passwd -rwsr-xr-x 1 root root 59976 11월 24 21:05 passwd setgid: 일반 사용자가 파일을 실행하면 파일 소유 그룹 권한으로 실행됩니다. setgid는 소유 그룹의 실행 권한에 x 대신 s 문자로 나타냅니다. 마찬가지로 실행 권한이 없으나 setgid가 걸려 있는 경우 대문자 S로 표시됩니다. sticky bit: 디렉토리에 sticky bit를 설정하면 파일 및 디렉토리 소유자와 root 사용자 외에 일반 사용자가 파일을 삭제할 수 없습니다. 주로 공용 디렉토리에 사용합니다. 일반 사용자의 실행 권한에 x 대신 t 문자로 나타냅니다. 이 역시 마찬가지로 실행 권한이 없는 경우에는 대문자 T로 표시됩니다. 특수 권한을 지정할 때는 권한 플래그 맨 앞에 숫자를 붙여 나타냅니다. setuid는 4, setgid는 2, sticky bit는 1입니다.\n다음은 chmod 4755 world 명령어로 world 파일에 실행 권한과 setuid를 설정하는 모습입니다. setuid만 설정하는 경우 chmod u+s world도 가능합니다.\nsetgid는 chmod g+s world, sticky bit는 chmod o+t world로 설정할 수 있습니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ chmod 4775 world user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwsrwxr-x 1 user user 13 12월 2 13:08 world 디렉토리 구조 루트 디렉토리 / 루트 디렉토리는 리눅스의 최상위 디렉토리를 말하며, 절대 경로는 / 입니다.\ncd /; ls -l 또는 ls -l /를 실행하면 루트 디렉토리에 존재하는 파일과 디렉토리들을 볼 수 있습니다. 명령어 실행 결과는 다음과 같습니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 user@user-VirtualBox:~$ ls -l / total 3991632 lrwxrwxrwx 1 root root 7 11월 30 18:15 bin -\u0026gt; usr/bin drwxr-xr-x 4 root root 4096 12월 1 14:10 boot drwxrwxr-x 2 root root 4096 11월 30 18:25 cdrom drwxr-xr-x 19 root root 4180 12월 1 14:25 dev drwxr-xr-x 130 root root 12288 12월 1 14:09 etc drwxr-xr-x 3 root root 4096 11월 30 18:27 home lrwxrwxrwx 1 root root 7 11월 30 18:15 lib -\u0026gt; usr/lib lrwxrwxrwx 1 root root 9 11월 30 18:15 lib32 -\u0026gt; usr/lib32 lrwxrwxrwx 1 root root 9 11월 30 18:15 lib64 -\u0026gt; usr/lib64 lrwxrwxrwx 1 root root 10 11월 30 18:15 libx32 -\u0026gt; usr/libx32 drwx------ 2 root root 16384 11월 30 18:14 lost+found drwxr-xr-x 3 root root 4096 11월 30 19:49 media drwxr-xr-x 2 root root 4096 8월 9 20:48 mnt drwxr-xr-x 3 root root 4096 11월 30 19:55 opt dr-xr-xr-x 257 root root 0 12월 1 14:11 proc drwx------ 4 root root 4096 12월 1 14:17 root drwxr-xr-x 33 root root 900 12월 1 14:12 run lrwxrwxrwx 1 root root 8 11월 30 18:15 sbin -\u0026gt; usr/sbin drwxr-xr-x 11 root root 4096 8월 9 20:55 snap drwxr-xr-x 2 root root 4096 8월 9 20:48 srv -rw------- 1 root root 4087349248 11월 30 18:15 swapfile dr-xr-xr-x 13 root root 0 12월 1 14:11 sys drwxrwxrwt 20 root root 4096 12월 1 14:17 tmp drwxr-xr-x 14 root root 4096 8월 9 20:48 usr drwxr-xr-x 14 root root 4096 8월 9 20:54 var user@user-VirtualBox:~$ 위 ls 명령어 실행 결과에서 볼 수 있듯이 루트 디렉토리 안에 많은 디렉토리가 존재합니다. 이중 몇 가지 중요한 디렉토리들을 알아보겠습니다.\n/bin\n일반 유저가 사용할 수 있는 기본적인 명령어나 프로그램을 담고 있는 디렉토리입니다. /boot\n시스템 부팅에 필요한 파일들을 담고 있는 디렉토리입니다. /dev\n리눅스에서는 컴퓨터에 부착된 물리적인 장치들을 디바이스 드라이버를 거쳐 파일 형태로 접근 가능합니다. 그러한 장치들을 나타내는 파일들을 담고 있는 디렉토리입니다. /etc\n운영체제나 운영체제 위에서 동작하는 서비스의 설정 파일들을 담고 있는 디렉토리입니다. /home\n각 일반 유저의 홈 디렉토리를 담고 있는 디렉토리입니다. 일반 유저들은 각기 자신만의 홈 디렉토리를 가지고 있습니다. 예를 들어 dream 유저의 홈 디렉토리는 /home/dream 입니다. /lib\n시스템에 필요한 라이브러리 파일들을 담고 있는 디렉토리입니다. /bin 이나 /sbin 에 존재하는 프로그램이 필요로 하는 동적 라이브러리 파일이 /lib 디렉토리에 존재합니다. /opt\n소프트웨어 패키지들을 담는 디렉토리입니다. /proc\n리눅스 커널 자원에 접근할 수 있는 파일과 프로세스를 나타내는 파일을 담고 있습니다. /root\nroot 유저의 홈 디렉토리입니다. /sbin\n/bin 디렉토리와 마찬가지로 기본적인 유저 명령어나 프로그램을 가지고 있는 디렉토리입니다. /sbin은 root 유저가 사용할 수 있는 명령어나 프로그램을 가지고 있습니다. /tmp\n유저나 프로그램이 임시로 파일을 생성해야할 때 사용할 수 있는 디렉토리입니다. 본 디렉토리에 오래 존재했던 파일들은 자동으로 삭제되므로 주의하여 사용해야 합니다. /usr\n사용자 바이너리, 문서, 라이브러리, 헤더 파일 등을 담고 있는 디렉토리입니다. /var\n프로그램이나 시스템이 실시간으로 가변적인 파일을 사용하고 저장해야 할 때 활용하는 디렉토리입니다. 예를 들어 /var/log에는 다양한 로그 파일이 저장됩니다. 물론 모든 디렉토리의 모든 파일을 외울 수만 있다면 리눅스를 사용하는데 있어서 많은 도움이 됩니다. 하지만 처음부터 모든 디렉토리의 모든 파일을 다 외워야 하는 것은 아닙니다. 공부할수록 자주 접하는 디렉토리나 파일이 생기게 되고, 그런 것들을 시작으로 자연스럽게 기억하고 이해하게 될 것입니다.\n문제풀이 ls -\u0026gt; cat hint.txt -\u0026gt; cat /dream/hack/hello/flag.txt -\u0026gt; cat app.py -\u0026gt; cat ./dream/hack/hello/f*ag.txt DH{671ce26c70829e716fae26c7c71a33823feb479f2562891f64605bf68f60ae54}\n","permalink":"http://localhost:1313/posts/2026-01-08/","summary":"리눅스 사용법 정리글","title":"리눅스 사용법 한 눈에 살펴보기"},{"content":"1. 개요 (Intro) 안녕하세요, AlwaysHyeon의 보안 블로그입니다. 이 글은 GitHub Pages와 Hugo PaperMod 테마가 정상적으로 연동되었는지 확인하기 위한 테스트 포스트입니다.\n테스트 환경 Generator: Hugo Theme: PaperMod Hosting: GitHub Pages 2. 기능 테스트 (Feature Test) 2.1. 코드 하이라이팅 (Code Block) Python 코드가 예쁘게 나오는지 확인합니다.\n1 2 3 4 5 6 7 8 import os def check_security(): print(\u0026#34;System Secure... maybe?\u0026#34;) return True if __name__ == \u0026#34;__main__\u0026#34;: check_security() ","permalink":"http://localhost:1313/posts/test-post/","summary":"Hugo PaperMod 테마 적용 테스트 글입니다. 마크다운 문법과 코드 하이라이팅이 잘 적용되는지 확인합니다.","title":"블로그 테스트 및 첫 번째 글 (Hello World)"},{"content":"셸(Shell) 유저가 리눅스 시스템을 이용할 수 있는 인터페이스입니다. 터미널 실행 단축키 ctrl + alt + T (윈도우, 리눅스 기준) control + option + T (맥 기준) 셸 프롬프트(Shell Prompt) 셸이 입력 받을 준비가 되었을 때 1 user@user-VirtualBox:~$ id 명령어: 현재 유저의 유저 ID와 해당 유저가 속해 있는 그룹 ID. 1 2 3 user@user-VirtualBox:~$ id uid=1000(user) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),134(lxd),135(sambashare) user@user-VirtualBox:~$ 기초적인 명령어 sudo apt update apt 명령어로 설치 가능한 소프트웨어 패키지 목록을 업데이트합니다. 그리고 각 소프트웨어 별로 어떤 버전을 설치할 수 있는지도 업데이트 합니다. sudo apt upgrade 리눅스에 설치된 소프트웨어 패키지의 버전을 업그레이드합니다. id 리눅스는 권한을 기반으로 파일을 읽고 쓸 수 있기 때문에 주로 자신이 해당하는 권한을 가지고 있는지 확인하기 위해서 사용하는 명령어입니다. pwd Print Working Directory의 줄임말로 현재 작업 중인 디렉토리의 경로를 출력합니다. ls List의 줄임말로 디렉토리의 내용을 출력하는 명령어입니다.\n-l 플래그를 추가한 형태인 ls -l을 실행하면 더 자세한 내용을 출력합니다.\n현재 디렉토리 뿐만 아니라 임의 디렉토리의 내용을 출력하는 것도 가능합니다. 루트 디렉토리인 / 디렉토리의 내용을 출력하는 ls -l /으로 출력 가능합니다.\ncd Change Directory의 줄임말로 작업 중인 디렉토리를 변경하는 명령어입니다. 구분 기호/명령어 설명 예시 절대 경로 / 시작 루트 디렉토리(/)를 시작으로 모든 경로를 전부 적어서 표현하는 방식 /home/user 상대 경로 .. 등 현재 디렉토리를 기준으로 상위 또는 하위 디렉토리로 뻗어 나가는 방식 cd .. (현재 위치에서 부모 디렉토리로 이동) 홈 디렉토리 ~ 현재 로그인한 유저의 홈 디렉토리 cd ~ (내 홈 폴더로 이동) 이전 경로 - 직전에 위치했던 디렉토리 (바로 전 경로) cd - (이전 작업 위치로 복귀) mkdir Make Directory의 줄임말로 디렉토리를 생성하는 명령어입니다.\n/home/user 디렉토리에 위치할 때 mkdir new_dir 명령어로 new_dir 디렉토리를 생성하면, new_dir가 새롭게 추가됩니다.\ntouch touch 명령어는 비어있는 새로운 파일을 만드는 데 사용합니다. 앞서 생성한 new_dir 디렉토리로 이동 후 ls -l 명령어를 실행하면 아무런 파일도 존재하지 않습니다.\n이때 touch new_file 명령어를 실행한 후 ls -l을 실행하면, new_file 파일이 생성되었습니다.\nmv Move의 줄임말로 파일이나 디렉토리의 위치를 옮길 때 사용하는 명령어입니다. 파일이나 디렉토리의 이름을 변경할 때도 사용할 수 있습니다. 1 mv [예전 이름] [변경할 이름] 파일을 옮길 수도 있습니다. 1 2 3 4 5 6 7 8 9 10 11 user@user-VirtualBox:~/new_dir$ ls old_file user@user-VirtualBox:~/new_dir$ ls .. Desktop Downloads new_dir Public Templates Documents Music Pictures snap Videos user@user-VirtualBox:~/new_dir$ mv old_file .. user@user-VirtualBox:~/new_dir$ ls user@user-VirtualBox:~/new_dir$ ls .. Desktop Downloads new_dir Pictures snap Videos Documents Music old_file Public Templates user@user-VirtualBox:~/new_dir$ rm Remove의 줄임말로 파일이나 디렉토리를 삭제하는 명령어입니다. 디렉토리 삭제는 -r 플래그를 추가한 rm -r로 수행할 수 있습니다. cat 파일의 내용을 출력하는 명령어입니다. cat 파일경로 형식으로 사용할 수 있습니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 user@user-VirtualBox:~/new_dir$ cat /etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin ... (생략) user:x:1000:1000:user,,,:/home/user:/bin/bash fwupd-refresh:x:128:136:fwupd-refresh user,,,:/run/systemd:/usr/sbin/nologin vboxadd:x:999:1::/var/run/vboxadd:/bin/false user@user-VirtualBox:~/new_dir$ file 파일의 유형을 출력하는 명령어입니다. 1 2 3 user@user-VirtualBox:~$ file /bin/ls /bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=897f49cafa98c11d63e619e7e40352f855249c13, for GNU/Linux 3.2.0, stripped user@user-VirtualBox:~$ echo 셸에 유저가 입력한 텍스트를 출력합니다. 1 2 3 user@user-VirtualBox:~/new_dir$ echo \u0026#34;Hello world!\u0026#34; Hello world! user@user-VirtualBox:~/new_dir$ ehco 명령어를 사용해서 파일을 생성할 수도 있습니다. echo 명령문 끝에 \u0026gt; 파일명을 이어 붙여 실행하면 파일명 이름을 가지는 파일을 생성하고 echo 뒤에 입력한 내용을 파일 내용으로 저장합니다. 1 2 3 4 5 6 7 8 9 user@user-VirtualBox:~/new_dir$ ls -l total 0 user@user-VirtualBox:~/new_dir$ echo \u0026#34;Hello world!\u0026#34; \u0026gt; hello user@user-VirtualBox:~/new_dir$ ls -l total 4 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello user@user-VirtualBox:~/new_dir$ cat hello Hello world! user@user-VirtualBox:~/new_dir$ cp Copy의 줄임말로 파일이나 디렉토리를 복사하는 명령어입니다. 다음은 위에서 생성한 hello 파일을 world라는 이름으로 복사하는 모습입니다. 디렉토리를 복사할 때는 -r 플래그를 붙인 형태인 cp -r을 사용합니다. 1 2 3 4 5 6 7 8 9 10 11 user@user-VirtualBox:~/new_dir$ ls -l total 4 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello user@user-VirtualBox:~/new_dir$ cp hello world user@user-VirtualBox:~/new_dir$ ls -l total 8 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello -rw-rw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ cat world Hello world! user@user-VirtualBox:~/new_dir$ grep 전체에서 특정 문자열을 찾을 때 사용합니다. grep 문자열 파일 형식으로 사용할 수 있습니다. 다음은 grep root /etc/passwd를 수행하여 /etc/passwd 파일에서 root 문자열이 포함된 행을 출력하는 모습입니다. 1 2 3 user@user-VirtualBox:~/new_dir$ grep root /etc/passwd root:x:0:0:root:/root:/bin/bash nm-openvpn:x:121:127:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin man Manual의 줄임말로 특정 명령어의 매뉴얼을 보여주는 명령어입니다. man [명령어]로 수행할 수 있습니다. curl client URL의 줄임말로 서버에 데이터를 보내거나 서버로부터 받는 데이터 전송 명령어입니다. curl [옵션] URL 형식으로 사용할 수 있으며, HTTP, HTTPS, FTP 등 다양한 프로토콜을 지원합니다. curl 명령어의 주요 옵션들 -o file: 전송 받은 데이터를 파일에 저장합니다. -i: 결과 값에 HTTP 응답 헤더를 포함합니다. -X \u0026quot;method\u0026quot;: HTTP 요청 메소드를 지정합니다. -d \u0026quot;key=value\u0026quot;: HTTP POST 메소드로 데이터를 전송합니다. curl을 이용한 명령어 실행 결과 전송 curl은 워게임 문제를 풀 때도 유용하게 사용됩니다. 예를 들어 풀이자가 명령어 실행 결과를 볼 수 없는 경우, 결과를 curl 명령어에 포함하여 풀이자의 웹 서버로 전송하면 확인이 가능합니다. 1 $ curl \u0026#34;[웹사이트]\u0026#34; -d \u0026#34;`cat [파일]`\u0026#34; 와일드카드 **와일드카드(wildcards)**는 리눅스에서 임의의 다른 문자를 나타낼 수 있는 특수 문자들을 의미합니다. 주로 명령어를 다른 문자열로 대체하기 위해 사용합니다. ? a-z, 0-9 범위 내 임의의 1개 문자로 대체됩니다. * a-z, 0-9 범위 내 임의의 0개 이상 문자로 대체됩니다. [] [문자1-문자2] 혹은 [문자1, 문자2, …] 형태로 범위를 지정합니다. 범위 내 모든 문자로 대체될 수 있습니다. 리다이렉션 **리다이렉션(redirection)**은 모니터에 나타나는 표준 출력 혹은 키보드로 입력하는 표준 입력을 다른 곳으로 변경하는 작업입니다. 주로 어떤 명령어의 결과를 파일로 저장하거나, 다른 명령어의 입력으로 전달하는 형태로 리다이렉션합니다. 명령어 \u0026gt; 파일 명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 덮어씁니다. 명령어 \u0026gt;\u0026gt; 파일 명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 이어서 씁니다. 명령어 \u0026lt; 파일 명령어 표준 입력을 파일로 변경합니다. 파일로부터 표준 입력을 받아 명령어를 수행합니다. 파이프 **파이프(pipe)**는 리다이렉션의 한 형태로, 명령어 결과 표준 출력을 다른 명령어의 표준 입력으로 보낼 때 사용합니다. 파이프는 | 문자로 나타냅니다. 권한 유저(user)와 그룹(group) 리눅스에서 유저와 그룹은 리눅스의 권한 시스템을 설명하기 위해 빠뜨릴 수 없는 개념입니다. 리눅스의 각 유저는 이름과 고유한 사용자 ID(UID) 를 가지고 있습니다. 그룹은 말 그대로 여러 유저가 속할 수 있는 그룹으로, 이 역시 그룹 이름과 고유한 그룹 ID(GID) 를 가지고 있습니다.\n파일이나 디렉토리와 같은 시스템 자원에 유저가 접근하면 유저의 UID와 해당 유저가 속한 그룹의 GID를 확인하여 정당한 권한을 가지고 있는지를 판단해 접근을 제어합니다.\n/etc/passwd 는 리눅스의 유저 정보를 담고 있는 텍스트 파일입니다. 각 사용자의 이름, 사용자 ID, 속해있는 그룹 ID 등의 정보를 포함하고 있습니다. cat 명령어로 /etc/passwd 파일의 내용을 확인할 수 있습니다.\n/etc/group 은 리눅스의 그룹 정보를 저장하는 텍스트 파일입니다. 각 그룹의 이름, 그룹 ID, 그룹에 속한 유저 목록 등의 정보를 포함하고 있습니다. cat 명령어로 /etc/group 파일의 내용을 확인할 수 있습니다.\n파일 및 디렉토리 권한 리눅스는 사용자가 파일과 디렉토리에 접근하는 행위에 대해 권한으로 제어합니다. 각 파일과 디렉토리는 **소유자(owner)**와 소유 그룹(group) 을 가지고 있습니다. 소유자는 파일 또는 디렉토리의 권한을 수정할 수 있는 능력을 가지고 있습니다. 소유자는 이를 통해 소유자 또는 소유 그룹에 포함된 유저가 해당 파일 또는 디렉토리에 대해서 얼마만큼 접근 권한을 가질 것인지 설정할 수 있습니다. 다음과 같이 세 종류의 접근 권한이 있습니다.\n읽기(Read): 파일 또는 디렉토리의 내용을 볼 수 있게 허용합니다.\n쓰기(Write): 파일 또는 디렉토리의 내용을 수정하거나 삭제하는 것을 허용합니다.\n실행(Execute): 파일이 프로그램인 경우 실행할 수 있게 허용합니다. 디렉토리의 경우, 디렉토리의 내용에 접근할 수 있도록 허용합니다.\n파일이나 디렉토리의 권한을 보기 위해 ls -l를 사용합니다. 해당 명령어는 디렉토리의 내용을 권한 정보와 함께 출력합니다. 다음은 ls -l 명령어 예시 결과입니다.\n1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ---------- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ 다음은 dir 디렉토리의 예시입니다. 첫 번째 열은 권한 플래그를 나타내고 세 번째 열은 소유자를 나타냅니다. 네 번째 열은 소유 그룹을 나타냅니다. 결과의 첫 번째 행을 가져와 자세히 살펴보겠습니다.\n1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir dir의 권한 플래그는 drwxrwxr-x이고, 소유자는 user이며 소유 그룹은 user 입니다. 각각에 대해 자세히 알아보겠습니다.\n첫 번째 열 drwxrwxr-x : 권한 플래그 1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir 위 결과에서 첫 번째 열이 각 파일 또는 디렉토리의 권한 플래그를 나타냅니다. 권한 플래그는 다음과 같이 4개의 부분으로 나뉠 수 있습니다: d rwx rwx r-x\nd rwx rwx r-x\n먼저 위에서 bold 처리한 첫 번째 문자는 파일의 타입을 나타냅니다. d 는 디렉토리, - 는 일반 파일, l 은 바로가기와 같은 링크 파일을 나타냅니다.\n그 다음 문자들은 권한 플래그입니다. 문자 3개씩 3개의 덩어리로 나뉩니다.\nd rwx rwx r-x\n위에서 bold 처리한 3개의 문자는 파일 또는 디렉토리의 소유자의 권한을 나타냅니다.\nd rwx rwx r-x\n위에서 bold 처리한 3개의 문자는 파일 또는 디렉토리의 소유 그룹에 포함된 유저들의 권한을 나타냅니다.\nd rwx rwx r-x\n위에서 bold 처리한 3개의 문자는 파일 또는 디렉토리의 소유자 및 소유 그룹에 포함된 유저들을 제외한, 나머지 유저들의 권한을 나타냅니다.\n권한을 나타내는 각 문자에 대한 설명은 다음과 같습니다.\nr: 소유자(또는 소유 그룹에 포함된 유저들 또는 그외 유저)가 파일 또는 디렉토리에 읽기(Read) 권한을 가집니다.\nw: 소유자(또는 소유 그룹에 포함된 유저들 또는 그외 유저)가 파일 또는 디렉토리에 쓰기(Write) 권한을 가집니다.\nx: 소유자(또는 소유 그룹에 포함된 유저들 또는 그외 유저)가 파일 또는 디렉토리에 실행(Execute) 권한을 가집니다.\n권한을 나타내는 3개 문자는 2진수나 10진수로도 표현이 가능합니다. 예를 들어 rwx 는 2진수로 111이며, 10진수로는 7입니다. r-- 은 2진수로 100이며, 10진수로는 4입니다.\n세 번째 열 user : 소유자 1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir 위 결과에서 세 번째 열이 파일 또는 디렉토리의 소유자를 나타냅니다.\n소유자는 파일 또는 디렉토리에 대한 제어권을 가지고 있습니다. 소유자는 파일 또는 디렉토리의 권한 플래그를 변경할 수 있고 파일의 소유자 또는 소유 그룹을 변경할 수도 있습니다. 위 dir 디렉토리의 소유자가 user 유저임을 알 수 있습니다.\n네 번째 열 user : 소유 그룹 리눅스에는 여러 사용자를 하나의 집합으로 관리할 수 있는 그룹 기능이 있습니다. 소유 그룹은 그룹 단위로 파일 또는 디렉토리에 권한을 부여할 때 사용합니다. 특정 파일 또는 디렉토리에 대한 접근 권한을 편리하게 그룹 단위로 부여하거나 제한할 수 있어 자주 활용되는 기능입니다.\n결론 앞서 배운 것들을 종합하여 아래의 ls -l 결과를 해석해보겠습니다.\n1 -rwxrw-r-- 1 user user 13 12월 2 13:08 world 우선 소유자는 user 이며 소유 그룹은 user 입니다.\n권한 플래그는 다음과 같습니다.\nrwx rw- r--\n파일 타입을 나타내는 첫 번째 문자가 - 이므로 world는 일반 파일입니다. 소유자 권한 플래그는 rwx 이므로 user 유저는 world 파일을 읽고 쓰고 실행할 수 있습니다. 소유 그룹 권한 플래그는 rw- 이므로 user 그룹에 속한 유저들은 world 파일을 읽고 쓸 수는 있지만 실행할 수는 없습니다. user 유저가 아니면서 user 그룹에 속하지 않은 유저들은 r-- 권한을 가지므로 world 파일을 읽을 수만 있고 쓰거나 실행할 수는 없습니다. 파일 및 디렉토리 권한 명령어 chmod chmod는 파일 권한을 변경하는 명령어입니다. root 유저 혹은 파일의 소유자만 실행할 수 있습니다. chmod 권한 파일명 형식으로 사용합니다. 권한을 표현할 때는 권한 플래그를 10진수로 표현하거나 기존의 권한에 문자를 더하거나 뺍니다.\n다음은 ls -l 명령어 결과입니다. hello 파일에 아무 권한도 부여되지 않은 상태입니다.\nDetails 1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ---------- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ world 파일과 동일하게, 소유자는 읽고 쓰고 실행할 수 있고, 소유 그룹은 읽고 쓸 수 있고, 일반 유저는 읽을 수만 있도록 hello 파일 권한을 수정하겠습니다.\n소유자 권한은 rwx이므로 111=7, 소유 그룹 권한은 rw-이므로 110=6, 일반 유저 권한은 **r\u0026ndash;**이므로 100=4입니다. chmod 764 hello를 실행하면 권한이 아래와 같이 변경됩니다.\nDetails 1 2 3 4 5 6 7 user@user-VirtualBox:~/new_dir$ chmod 764 hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxrw-r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ 이번에는 hello 파일 소유 그룹에 실행 권한을 부여하겠습니다. 다음과 같이 chmod g+x hello 명령어를 실행하면 권한이 변경됩니다. 권한을 제거하고 싶으면 chmod g-wx hello와 같은 형식으로 입력합니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 12 user@user-VirtualBox:~/new_dir$ chmod g+x hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxrwxr-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ chmod g-wx hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world chown chown은 파일 소유자 혹은 소유 그룹을 변경하는 명령어입니다. root 유저만 실행할 수 있습니다. chown 사용자명[.그룹명] 파일명 형식으로 사용합니다. 소유 그룹만 변경하고 싶은 경우 chgrp 명령어를 사용합니다.\nhello 파일의 소유자를 user에서 root로 변경하겠습니다. 명령어를 root 권한으로 실행하려면 맨 앞에 sudo를 붙여줍니다.\nsudo chown root hello 명령어를 실행하면 소유자가 변경됩니다. 이제 user 유저는 hello 파일을 수정할 수 없습니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ sudo chown root hello [sudo] password for user: user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ echo \u0026#34;hello\u0026#34; \u0026gt; hello bash: hello: Permission denied user@user-VirtualBox:~/new_dir$ 특수 권한 앞서 배운 r, w, x 권한 외에 특수한 권한 3가지를 소개하겠습니다.\nsetuid: 일반 사용자가 파일을 실행하면 파일 소유자 권한으로 실행됩니다. 예를 들어, /bin/passwd 파일은 소유자가 root이지만 setuid가 설정되어 있어 일반 사용자가 root 권한으로 실행하고 비밀번호도 변경할 수 있습니다. setuid는 소유자의 실행 권한에 x 대신 s 문자로 나타냅니다. 대문자 S로 표시되는 경우에는 setuid가 걸려 있으나, 실행 권한이 없는 경우입니다. /bin/passwd의 권한 플래그는 다음과 같습니다. 소유자의 실행 권한이 s로 설정된 것을 볼 수 있습니다.\n1 2 user@user-VirtualBox:/bin$ ls -l passwd -rwsr-xr-x 1 root root 59976 11월 24 21:05 passwd setgid: 일반 사용자가 파일을 실행하면 파일 소유 그룹 권한으로 실행됩니다. setgid는 소유 그룹의 실행 권한에 x 대신 s 문자로 나타냅니다. 마찬가지로 실행 권한이 없으나 setgid가 걸려 있는 경우 대문자 S로 표시됩니다. sticky bit: 디렉토리에 sticky bit를 설정하면 파일 및 디렉토리 소유자와 root 사용자 외에 일반 사용자가 파일을 삭제할 수 없습니다. 주로 공용 디렉토리에 사용합니다. 일반 사용자의 실행 권한에 x 대신 t 문자로 나타냅니다. 이 역시 마찬가지로 실행 권한이 없는 경우에는 대문자 T로 표시됩니다. 특수 권한을 지정할 때는 권한 플래그 맨 앞에 숫자를 붙여 나타냅니다. setuid는 4, setgid는 2, sticky bit는 1입니다.\n다음은 chmod 4755 world 명령어로 world 파일에 실행 권한과 setuid를 설정하는 모습입니다. setuid만 설정하는 경우 chmod u+s world도 가능합니다.\nsetgid는 chmod g+s world, sticky bit는 chmod o+t world로 설정할 수 있습니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ chmod 4775 world user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwsrwxr-x 1 user user 13 12월 2 13:08 world 디렉토리 구조 루트 디렉토리 / 루트 디렉토리는 리눅스의 최상위 디렉토리를 말하며, 절대 경로는 / 입니다.\ncd /; ls -l 또는 ls -l /를 실행하면 루트 디렉토리에 존재하는 파일과 디렉토리들을 볼 수 있습니다. 명령어 실행 결과는 다음과 같습니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 user@user-VirtualBox:~$ ls -l / total 3991632 lrwxrwxrwx 1 root root 7 11월 30 18:15 bin -\u0026gt; usr/bin drwxr-xr-x 4 root root 4096 12월 1 14:10 boot drwxrwxr-x 2 root root 4096 11월 30 18:25 cdrom drwxr-xr-x 19 root root 4180 12월 1 14:25 dev drwxr-xr-x 130 root root 12288 12월 1 14:09 etc drwxr-xr-x 3 root root 4096 11월 30 18:27 home lrwxrwxrwx 1 root root 7 11월 30 18:15 lib -\u0026gt; usr/lib lrwxrwxrwx 1 root root 9 11월 30 18:15 lib32 -\u0026gt; usr/lib32 lrwxrwxrwx 1 root root 9 11월 30 18:15 lib64 -\u0026gt; usr/lib64 lrwxrwxrwx 1 root root 10 11월 30 18:15 libx32 -\u0026gt; usr/libx32 drwx------ 2 root root 16384 11월 30 18:14 lost+found drwxr-xr-x 3 root root 4096 11월 30 19:49 media drwxr-xr-x 2 root root 4096 8월 9 20:48 mnt drwxr-xr-x 3 root root 4096 11월 30 19:55 opt dr-xr-xr-x 257 root root 0 12월 1 14:11 proc drwx------ 4 root root 4096 12월 1 14:17 root drwxr-xr-x 33 root root 900 12월 1 14:12 run lrwxrwxrwx 1 root root 8 11월 30 18:15 sbin -\u0026gt; usr/sbin drwxr-xr-x 11 root root 4096 8월 9 20:55 snap drwxr-xr-x 2 root root 4096 8월 9 20:48 srv -rw------- 1 root root 4087349248 11월 30 18:15 swapfile dr-xr-xr-x 13 root root 0 12월 1 14:11 sys drwxrwxrwt 20 root root 4096 12월 1 14:17 tmp drwxr-xr-x 14 root root 4096 8월 9 20:48 usr drwxr-xr-x 14 root root 4096 8월 9 20:54 var user@user-VirtualBox:~$ 위 ls 명령어 실행 결과에서 볼 수 있듯이 루트 디렉토리 안에 많은 디렉토리가 존재합니다. 이중 몇 가지 중요한 디렉토리들을 알아보겠습니다.\n/bin\n일반 유저가 사용할 수 있는 기본적인 명령어나 프로그램을 담고 있는 디렉토리입니다. /boot\n시스템 부팅에 필요한 파일들을 담고 있는 디렉토리입니다. /dev\n리눅스에서는 컴퓨터에 부착된 물리적인 장치들을 디바이스 드라이버를 거쳐 파일 형태로 접근 가능합니다. 그러한 장치들을 나타내는 파일들을 담고 있는 디렉토리입니다. /etc\n운영체제나 운영체제 위에서 동작하는 서비스의 설정 파일들을 담고 있는 디렉토리입니다. /home\n각 일반 유저의 홈 디렉토리를 담고 있는 디렉토리입니다. 일반 유저들은 각기 자신만의 홈 디렉토리를 가지고 있습니다. 예를 들어 dream 유저의 홈 디렉토리는 /home/dream 입니다. /lib\n시스템에 필요한 라이브러리 파일들을 담고 있는 디렉토리입니다. /bin 이나 /sbin 에 존재하는 프로그램이 필요로 하는 동적 라이브러리 파일이 /lib 디렉토리에 존재합니다. /opt\n소프트웨어 패키지들을 담는 디렉토리입니다. /proc\n리눅스 커널 자원에 접근할 수 있는 파일과 프로세스를 나타내는 파일을 담고 있습니다. /root\nroot 유저의 홈 디렉토리입니다. /sbin\n/bin 디렉토리와 마찬가지로 기본적인 유저 명령어나 프로그램을 가지고 있는 디렉토리입니다. /sbin은 root 유저가 사용할 수 있는 명령어나 프로그램을 가지고 있습니다. /tmp\n유저나 프로그램이 임시로 파일을 생성해야할 때 사용할 수 있는 디렉토리입니다. 본 디렉토리에 오래 존재했던 파일들은 자동으로 삭제되므로 주의하여 사용해야 합니다. /usr\n사용자 바이너리, 문서, 라이브러리, 헤더 파일 등을 담고 있는 디렉토리입니다. /var\n프로그램이나 시스템이 실시간으로 가변적인 파일을 사용하고 저장해야 할 때 활용하는 디렉토리입니다. 예를 들어 /var/log에는 다양한 로그 파일이 저장됩니다. 물론 모든 디렉토리의 모든 파일을 외울 수만 있다면 리눅스를 사용하는데 있어서 많은 도움이 됩니다. 하지만 처음부터 모든 디렉토리의 모든 파일을 다 외워야 하는 것은 아닙니다. 공부할수록 자주 접하는 디렉토리나 파일이 생기게 되고, 그런 것들을 시작으로 자연스럽게 기억하고 이해하게 될 것입니다.\n문제풀이 ls -\u0026gt; cat hint.txt -\u0026gt; cat /dream/hack/hello/flag.txt -\u0026gt; cat app.py -\u0026gt; cat ./dream/hack/hello/f*ag.txt DH{671ce26c70829e716fae26c7c71a33823feb479f2562891f64605bf68f60ae54}\n","permalink":"http://localhost:1313/posts/2026-01-08/","summary":"리눅스 사용법 정리글","title":"리눅스 사용법 한 눈에 살펴보기"},{"content":"1. 개요 (Intro) 안녕하세요, AlwaysHyeon의 보안 블로그입니다. 이 글은 GitHub Pages와 Hugo PaperMod 테마가 정상적으로 연동되었는지 확인하기 위한 테스트 포스트입니다.\n테스트 환경 Generator: Hugo Theme: PaperMod Hosting: GitHub Pages 2. 기능 테스트 (Feature Test) 2.1. 코드 하이라이팅 (Code Block) Python 코드가 예쁘게 나오는지 확인합니다.\n1 2 3 4 5 6 7 8 import os def check_security(): print(\u0026#34;System Secure... maybe?\u0026#34;) return True if __name__ == \u0026#34;__main__\u0026#34;: check_security() ","permalink":"http://localhost:1313/posts/test-post/","summary":"Hugo PaperMod 테마 적용 테스트 글입니다. 마크다운 문법과 코드 하이라이팅이 잘 적용되는지 확인합니다.","title":"블로그 테스트 및 첫 번째 글 (Hello World)"},{"content":"셸(Shell) 유저가 리눅스 시스템을 이용할 수 있는 인터페이스입니다. 터미널 실행 단축키 ctrl + alt + T (윈도우, 리눅스 기준) control + option + T (맥 기준) 셸 프롬프트(Shell Prompt) 셸이 입력 받을 준비가 되었을 때 1 user@user-VirtualBox:~$ id 명령어: 현재 유저의 유저 ID와 해당 유저가 속해 있는 그룹 ID. 1 2 3 user@user-VirtualBox:~$ id uid=1000(user) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),134(lxd),135(sambashare) user@user-VirtualBox:~$ 기초적인 명령어 sudo apt update apt 명령어로 설치 가능한 소프트웨어 패키지 목록을 업데이트합니다. 그리고 각 소프트웨어 별로 어떤 버전을 설치할 수 있는지도 업데이트 합니다. sudo apt upgrade 리눅스에 설치된 소프트웨어 패키지의 버전을 업그레이드합니다. id 리눅스는 권한을 기반으로 파일을 읽고 쓸 수 있기 때문에 주로 자신이 해당하는 권한을 가지고 있는지 확인하기 위해서 사용하는 명령어입니다. pwd Print Working Directory의 줄임말로 현재 작업 중인 디렉토리의 경로를 출력합니다. ls List의 줄임말로 디렉토리의 내용을 출력하는 명령어입니다.\n-l 플래그를 추가한 형태인 ls -l을 실행하면 더 자세한 내용을 출력합니다.\n현재 디렉토리 뿐만 아니라 임의 디렉토리의 내용을 출력하는 것도 가능합니다. 루트 디렉토리인 / 디렉토리의 내용을 출력하는 ls -l /으로 출력 가능합니다.\ncd Change Directory의 줄임말로 작업 중인 디렉토리를 변경하는 명령어입니다. 구분 기호/명령어 설명 예시 절대 경로 / 시작 루트 디렉토리(/)를 시작으로 모든 경로를 전부 적어서 표현하는 방식 /home/user 상대 경로 .. 등 현재 디렉토리를 기준으로 상위 또는 하위 디렉토리로 뻗어 나가는 방식 cd .. (현재 위치에서 부모 디렉토리로 이동) 홈 디렉토리 ~ 현재 로그인한 유저의 홈 디렉토리 cd ~ (내 홈 폴더로 이동) 이전 경로 - 직전에 위치했던 디렉토리 (바로 전 경로) cd - (이전 작업 위치로 복귀) mkdir Make Directory의 줄임말로 디렉토리를 생성하는 명령어입니다.\n/home/user 디렉토리에 위치할 때 mkdir new_dir 명령어로 new_dir 디렉토리를 생성하면, new_dir가 새롭게 추가됩니다.\ntouch touch 명령어는 비어있는 새로운 파일을 만드는 데 사용합니다. 앞서 생성한 new_dir 디렉토리로 이동 후 ls -l 명령어를 실행하면 아무런 파일도 존재하지 않습니다.\n이때 touch new_file 명령어를 실행한 후 ls -l을 실행하면, new_file 파일이 생성되었습니다.\nmv Move의 줄임말로 파일이나 디렉토리의 위치를 옮길 때 사용하는 명령어입니다. 파일이나 디렉토리의 이름을 변경할 때도 사용할 수 있습니다. 1 mv [예전 이름] [변경할 이름] 파일을 옮길 수도 있습니다. 1 2 3 4 5 6 7 8 9 10 11 user@user-VirtualBox:~/new_dir$ ls old_file user@user-VirtualBox:~/new_dir$ ls .. Desktop Downloads new_dir Public Templates Documents Music Pictures snap Videos user@user-VirtualBox:~/new_dir$ mv old_file .. user@user-VirtualBox:~/new_dir$ ls user@user-VirtualBox:~/new_dir$ ls .. Desktop Downloads new_dir Pictures snap Videos Documents Music old_file Public Templates user@user-VirtualBox:~/new_dir$ rm Remove의 줄임말로 파일이나 디렉토리를 삭제하는 명령어입니다. 디렉토리 삭제는 -r 플래그를 추가한 rm -r로 수행할 수 있습니다. cat 파일의 내용을 출력하는 명령어입니다. cat 파일경로 형식으로 사용할 수 있습니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 user@user-VirtualBox:~/new_dir$ cat /etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin ... (생략) user:x:1000:1000:user,,,:/home/user:/bin/bash fwupd-refresh:x:128:136:fwupd-refresh user,,,:/run/systemd:/usr/sbin/nologin vboxadd:x:999:1::/var/run/vboxadd:/bin/false user@user-VirtualBox:~/new_dir$ file 파일의 유형을 출력하는 명령어입니다. 1 2 3 user@user-VirtualBox:~$ file /bin/ls /bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=897f49cafa98c11d63e619e7e40352f855249c13, for GNU/Linux 3.2.0, stripped user@user-VirtualBox:~$ echo 셸에 유저가 입력한 텍스트를 출력합니다. 1 2 3 user@user-VirtualBox:~/new_dir$ echo \u0026#34;Hello world!\u0026#34; Hello world! user@user-VirtualBox:~/new_dir$ ehco 명령어를 사용해서 파일을 생성할 수도 있습니다. echo 명령문 끝에 \u0026gt; 파일명을 이어 붙여 실행하면 파일명 이름을 가지는 파일을 생성하고 echo 뒤에 입력한 내용을 파일 내용으로 저장합니다. 1 2 3 4 5 6 7 8 9 user@user-VirtualBox:~/new_dir$ ls -l total 0 user@user-VirtualBox:~/new_dir$ echo \u0026#34;Hello world!\u0026#34; \u0026gt; hello user@user-VirtualBox:~/new_dir$ ls -l total 4 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello user@user-VirtualBox:~/new_dir$ cat hello Hello world! user@user-VirtualBox:~/new_dir$ cp Copy의 줄임말로 파일이나 디렉토리를 복사하는 명령어입니다. 다음은 위에서 생성한 hello 파일을 world라는 이름으로 복사하는 모습입니다. 디렉토리를 복사할 때는 -r 플래그를 붙인 형태인 cp -r을 사용합니다. 1 2 3 4 5 6 7 8 9 10 11 user@user-VirtualBox:~/new_dir$ ls -l total 4 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello user@user-VirtualBox:~/new_dir$ cp hello world user@user-VirtualBox:~/new_dir$ ls -l total 8 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello -rw-rw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ cat world Hello world! user@user-VirtualBox:~/new_dir$ grep 전체에서 특정 문자열을 찾을 때 사용합니다. grep 문자열 파일 형식으로 사용할 수 있습니다. 다음은 grep root /etc/passwd를 수행하여 /etc/passwd 파일에서 root 문자열이 포함된 행을 출력하는 모습입니다. 1 2 3 user@user-VirtualBox:~/new_dir$ grep root /etc/passwd root:x:0:0:root:/root:/bin/bash nm-openvpn:x:121:127:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin man Manual의 줄임말로 특정 명령어의 매뉴얼을 보여주는 명령어입니다. man [명령어]로 수행할 수 있습니다. curl client URL의 줄임말로 서버에 데이터를 보내거나 서버로부터 받는 데이터 전송 명령어입니다. curl [옵션] URL 형식으로 사용할 수 있으며, HTTP, HTTPS, FTP 등 다양한 프로토콜을 지원합니다. curl 명령어의 주요 옵션들 -o file: 전송 받은 데이터를 파일에 저장합니다. -i: 결과 값에 HTTP 응답 헤더를 포함합니다. -X \u0026quot;method\u0026quot;: HTTP 요청 메소드를 지정합니다. -d \u0026quot;key=value\u0026quot;: HTTP POST 메소드로 데이터를 전송합니다. curl을 이용한 명령어 실행 결과 전송 curl은 워게임 문제를 풀 때도 유용하게 사용됩니다. 예를 들어 풀이자가 명령어 실행 결과를 볼 수 없는 경우, 결과를 curl 명령어에 포함하여 풀이자의 웹 서버로 전송하면 확인이 가능합니다. 1 $ curl \u0026#34;[웹사이트]\u0026#34; -d \u0026#34;`cat [파일]`\u0026#34; 와일드카드 **와일드카드(wildcards)**는 리눅스에서 임의의 다른 문자를 나타낼 수 있는 특수 문자들을 의미합니다. 주로 명령어를 다른 문자열로 대체하기 위해 사용합니다. ? a-z, 0-9 범위 내 임의의 1개 문자로 대체됩니다. * a-z, 0-9 범위 내 임의의 0개 이상 문자로 대체됩니다. [] [문자1-문자2] 혹은 [문자1, 문자2, …] 형태로 범위를 지정합니다. 범위 내 모든 문자로 대체될 수 있습니다. 리다이렉션 **리다이렉션(redirection)**은 모니터에 나타나는 표준 출력 혹은 키보드로 입력하는 표준 입력을 다른 곳으로 변경하는 작업입니다. 주로 어떤 명령어의 결과를 파일로 저장하거나, 다른 명령어의 입력으로 전달하는 형태로 리다이렉션합니다. 명령어 \u0026gt; 파일 명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 덮어씁니다. 명령어 \u0026gt;\u0026gt; 파일 명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 이어서 씁니다. 명령어 \u0026lt; 파일 명령어 표준 입력을 파일로 변경합니다. 파일로부터 표준 입력을 받아 명령어를 수행합니다. 파이프 **파이프(pipe)**는 리다이렉션의 한 형태로, 명령어 결과 표준 출력을 다른 명령어의 표준 입력으로 보낼 때 사용합니다. 파이프는 | 문자로 나타냅니다. 권한 유저(user)와 그룹(group) 리눅스에서 유저와 그룹은 리눅스의 권한 시스템을 설명하기 위해 빠뜨릴 수 없는 개념입니다. 리눅스의 각 유저는 이름과 고유한 사용자 ID(UID) 를 가지고 있습니다. 그룹은 말 그대로 여러 유저가 속할 수 있는 그룹으로, 이 역시 그룹 이름과 고유한 그룹 ID(GID) 를 가지고 있습니다.\n파일이나 디렉토리와 같은 시스템 자원에 유저가 접근하면 유저의 UID와 해당 유저가 속한 그룹의 GID를 확인하여 정당한 권한을 가지고 있는지를 판단해 접근을 제어합니다.\n/etc/passwd 는 리눅스의 유저 정보를 담고 있는 텍스트 파일입니다. 각 사용자의 이름, 사용자 ID, 속해있는 그룹 ID 등의 정보를 포함하고 있습니다. cat 명령어로 /etc/passwd 파일의 내용을 확인할 수 있습니다.\n/etc/group 은 리눅스의 그룹 정보를 저장하는 텍스트 파일입니다. 각 그룹의 이름, 그룹 ID, 그룹에 속한 유저 목록 등의 정보를 포함하고 있습니다. cat 명령어로 /etc/group 파일의 내용을 확인할 수 있습니다.\n파일 및 디렉토리 권한 리눅스는 사용자가 파일과 디렉토리에 접근하는 행위에 대해 권한으로 제어합니다. 각 파일과 디렉토리는 **소유자(owner)**와 소유 그룹(group) 을 가지고 있습니다. 소유자는 파일 또는 디렉토리의 권한을 수정할 수 있는 능력을 가지고 있습니다. 소유자는 이를 통해 소유자 또는 소유 그룹에 포함된 유저가 해당 파일 또는 디렉토리에 대해서 얼마만큼 접근 권한을 가질 것인지 설정할 수 있습니다. 다음과 같이 세 종류의 접근 권한이 있습니다.\n읽기(Read): 파일 또는 디렉토리의 내용을 볼 수 있게 허용합니다.\n쓰기(Write): 파일 또는 디렉토리의 내용을 수정하거나 삭제하는 것을 허용합니다.\n실행(Execute): 파일이 프로그램인 경우 실행할 수 있게 허용합니다. 디렉토리의 경우, 디렉토리의 내용에 접근할 수 있도록 허용합니다.\n파일이나 디렉토리의 권한을 보기 위해 ls -l를 사용합니다. 해당 명령어는 디렉토리의 내용을 권한 정보와 함께 출력합니다. 다음은 ls -l 명령어 예시 결과입니다.\n1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ---------- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ 다음은 dir 디렉토리의 예시입니다. 첫 번째 열은 권한 플래그를 나타내고 세 번째 열은 소유자를 나타냅니다. 네 번째 열은 소유 그룹을 나타냅니다. 결과의 첫 번째 행을 가져와 자세히 살펴보겠습니다.\n1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir dir의 권한 플래그는 drwxrwxr-x이고, 소유자는 user이며 소유 그룹은 user 입니다. 각각에 대해 자세히 알아보겠습니다.\n첫 번째 열 drwxrwxr-x : 권한 플래그 1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir 위 결과에서 첫 번째 열이 각 파일 또는 디렉토리의 권한 플래그를 나타냅니다. 권한 플래그는 다음과 같이 4개의 부분으로 나뉠 수 있습니다: d rwx rwx r-x\nd rwx rwx r-x\n먼저 위에서 bold 처리한 첫 번째 문자는 파일의 타입을 나타냅니다. d 는 디렉토리, - 는 일반 파일, l 은 바로가기와 같은 링크 파일을 나타냅니다.\n그 다음 문자들은 권한 플래그입니다. 문자 3개씩 3개의 덩어리로 나뉩니다.\nd rwx rwx r-x\n위에서 bold 처리한 3개의 문자는 파일 또는 디렉토리의 소유자의 권한을 나타냅니다.\nd rwx rwx r-x\n위에서 bold 처리한 3개의 문자는 파일 또는 디렉토리의 소유 그룹에 포함된 유저들의 권한을 나타냅니다.\nd rwx rwx r-x\n위에서 bold 처리한 3개의 문자는 파일 또는 디렉토리의 소유자 및 소유 그룹에 포함된 유저들을 제외한, 나머지 유저들의 권한을 나타냅니다.\n권한을 나타내는 각 문자에 대한 설명은 다음과 같습니다.\nr: 소유자(또는 소유 그룹에 포함된 유저들 또는 그외 유저)가 파일 또는 디렉토리에 읽기(Read) 권한을 가집니다.\nw: 소유자(또는 소유 그룹에 포함된 유저들 또는 그외 유저)가 파일 또는 디렉토리에 쓰기(Write) 권한을 가집니다.\nx: 소유자(또는 소유 그룹에 포함된 유저들 또는 그외 유저)가 파일 또는 디렉토리에 실행(Execute) 권한을 가집니다.\n권한을 나타내는 3개 문자는 2진수나 10진수로도 표현이 가능합니다. 예를 들어 rwx 는 2진수로 111이며, 10진수로는 7입니다. r-- 은 2진수로 100이며, 10진수로는 4입니다.\n세 번째 열 user : 소유자 1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir 위 결과에서 세 번째 열이 파일 또는 디렉토리의 소유자를 나타냅니다.\n소유자는 파일 또는 디렉토리에 대한 제어권을 가지고 있습니다. 소유자는 파일 또는 디렉토리의 권한 플래그를 변경할 수 있고 파일의 소유자 또는 소유 그룹을 변경할 수도 있습니다. 위 dir 디렉토리의 소유자가 user 유저임을 알 수 있습니다.\n네 번째 열 user : 소유 그룹 리눅스에는 여러 사용자를 하나의 집합으로 관리할 수 있는 그룹 기능이 있습니다. 소유 그룹은 그룹 단위로 파일 또는 디렉토리에 권한을 부여할 때 사용합니다. 특정 파일 또는 디렉토리에 대한 접근 권한을 편리하게 그룹 단위로 부여하거나 제한할 수 있어 자주 활용되는 기능입니다.\n결론 앞서 배운 것들을 종합하여 아래의 ls -l 결과를 해석해보겠습니다.\n1 -rwxrw-r-- 1 user user 13 12월 2 13:08 world 우선 소유자는 user 이며 소유 그룹은 user 입니다.\n권한 플래그는 다음과 같습니다.\nrwx rw- r--\n파일 타입을 나타내는 첫 번째 문자가 - 이므로 world는 일반 파일입니다. 소유자 권한 플래그는 rwx 이므로 user 유저는 world 파일을 읽고 쓰고 실행할 수 있습니다. 소유 그룹 권한 플래그는 rw- 이므로 user 그룹에 속한 유저들은 world 파일을 읽고 쓸 수는 있지만 실행할 수는 없습니다. user 유저가 아니면서 user 그룹에 속하지 않은 유저들은 r-- 권한을 가지므로 world 파일을 읽을 수만 있고 쓰거나 실행할 수는 없습니다. 파일 및 디렉토리 권한 명령어 chmod chmod는 파일 권한을 변경하는 명령어입니다. root 유저 혹은 파일의 소유자만 실행할 수 있습니다. chmod 권한 파일명 형식으로 사용합니다. 권한을 표현할 때는 권한 플래그를 10진수로 표현하거나 기존의 권한에 문자를 더하거나 뺍니다.\n다음은 ls -l 명령어 결과입니다. hello 파일에 아무 권한도 부여되지 않은 상태입니다.\nDetails 1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ---------- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ world 파일과 동일하게, 소유자는 읽고 쓰고 실행할 수 있고, 소유 그룹은 읽고 쓸 수 있고, 일반 유저는 읽을 수만 있도록 hello 파일 권한을 수정하겠습니다.\n소유자 권한은 rwx이므로 111=7, 소유 그룹 권한은 rw-이므로 110=6, 일반 유저 권한은 **r\u0026ndash;**이므로 100=4입니다. chmod 764 hello를 실행하면 권한이 아래와 같이 변경됩니다.\nDetails 1 2 3 4 5 6 7 user@user-VirtualBox:~/new_dir$ chmod 764 hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxrw-r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ 이번에는 hello 파일 소유 그룹에 실행 권한을 부여하겠습니다. 다음과 같이 chmod g+x hello 명령어를 실행하면 권한이 변경됩니다. 권한을 제거하고 싶으면 chmod g-wx hello와 같은 형식으로 입력합니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 12 user@user-VirtualBox:~/new_dir$ chmod g+x hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxrwxr-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ chmod g-wx hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world chown chown은 파일 소유자 혹은 소유 그룹을 변경하는 명령어입니다. root 유저만 실행할 수 있습니다. chown 사용자명[.그룹명] 파일명 형식으로 사용합니다. 소유 그룹만 변경하고 싶은 경우 chgrp 명령어를 사용합니다.\nhello 파일의 소유자를 user에서 root로 변경하겠습니다. 명령어를 root 권한으로 실행하려면 맨 앞에 sudo를 붙여줍니다.\nsudo chown root hello 명령어를 실행하면 소유자가 변경됩니다. 이제 user 유저는 hello 파일을 수정할 수 없습니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ sudo chown root hello [sudo] password for user: user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ echo \u0026#34;hello\u0026#34; \u0026gt; hello bash: hello: Permission denied user@user-VirtualBox:~/new_dir$ 특수 권한 앞서 배운 r, w, x 권한 외에 특수한 권한 3가지를 소개하겠습니다.\nsetuid: 일반 사용자가 파일을 실행하면 파일 소유자 권한으로 실행됩니다. 예를 들어, /bin/passwd 파일은 소유자가 root이지만 setuid가 설정되어 있어 일반 사용자가 root 권한으로 실행하고 비밀번호도 변경할 수 있습니다. setuid는 소유자의 실행 권한에 x 대신 s 문자로 나타냅니다. 대문자 S로 표시되는 경우에는 setuid가 걸려 있으나, 실행 권한이 없는 경우입니다. /bin/passwd의 권한 플래그는 다음과 같습니다. 소유자의 실행 권한이 s로 설정된 것을 볼 수 있습니다.\n1 2 user@user-VirtualBox:/bin$ ls -l passwd -rwsr-xr-x 1 root root 59976 11월 24 21:05 passwd setgid: 일반 사용자가 파일을 실행하면 파일 소유 그룹 권한으로 실행됩니다. setgid는 소유 그룹의 실행 권한에 x 대신 s 문자로 나타냅니다. 마찬가지로 실행 권한이 없으나 setgid가 걸려 있는 경우 대문자 S로 표시됩니다. sticky bit: 디렉토리에 sticky bit를 설정하면 파일 및 디렉토리 소유자와 root 사용자 외에 일반 사용자가 파일을 삭제할 수 없습니다. 주로 공용 디렉토리에 사용합니다. 일반 사용자의 실행 권한에 x 대신 t 문자로 나타냅니다. 이 역시 마찬가지로 실행 권한이 없는 경우에는 대문자 T로 표시됩니다. 특수 권한을 지정할 때는 권한 플래그 맨 앞에 숫자를 붙여 나타냅니다. setuid는 4, setgid는 2, sticky bit는 1입니다.\n다음은 chmod 4755 world 명령어로 world 파일에 실행 권한과 setuid를 설정하는 모습입니다. setuid만 설정하는 경우 chmod u+s world도 가능합니다.\nsetgid는 chmod g+s world, sticky bit는 chmod o+t world로 설정할 수 있습니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ chmod 4775 world user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwsrwxr-x 1 user user 13 12월 2 13:08 world 디렉토리 구조 루트 디렉토리 / 루트 디렉토리는 리눅스의 최상위 디렉토리를 말하며, 절대 경로는 / 입니다.\ncd /; ls -l 또는 ls -l /를 실행하면 루트 디렉토리에 존재하는 파일과 디렉토리들을 볼 수 있습니다. 명령어 실행 결과는 다음과 같습니다.\nDetails 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 user@user-VirtualBox:~$ ls -l / total 3991632 lrwxrwxrwx 1 root root 7 11월 30 18:15 bin -\u0026gt; usr/bin drwxr-xr-x 4 root root 4096 12월 1 14:10 boot drwxrwxr-x 2 root root 4096 11월 30 18:25 cdrom drwxr-xr-x 19 root root 4180 12월 1 14:25 dev drwxr-xr-x 130 root root 12288 12월 1 14:09 etc drwxr-xr-x 3 root root 4096 11월 30 18:27 home lrwxrwxrwx 1 root root 7 11월 30 18:15 lib -\u0026gt; usr/lib lrwxrwxrwx 1 root root 9 11월 30 18:15 lib32 -\u0026gt; usr/lib32 lrwxrwxrwx 1 root root 9 11월 30 18:15 lib64 -\u0026gt; usr/lib64 lrwxrwxrwx 1 root root 10 11월 30 18:15 libx32 -\u0026gt; usr/libx32 drwx------ 2 root root 16384 11월 30 18:14 lost+found drwxr-xr-x 3 root root 4096 11월 30 19:49 media drwxr-xr-x 2 root root 4096 8월 9 20:48 mnt drwxr-xr-x 3 root root 4096 11월 30 19:55 opt dr-xr-xr-x 257 root root 0 12월 1 14:11 proc drwx------ 4 root root 4096 12월 1 14:17 root drwxr-xr-x 33 root root 900 12월 1 14:12 run lrwxrwxrwx 1 root root 8 11월 30 18:15 sbin -\u0026gt; usr/sbin drwxr-xr-x 11 root root 4096 8월 9 20:55 snap drwxr-xr-x 2 root root 4096 8월 9 20:48 srv -rw------- 1 root root 4087349248 11월 30 18:15 swapfile dr-xr-xr-x 13 root root 0 12월 1 14:11 sys drwxrwxrwt 20 root root 4096 12월 1 14:17 tmp drwxr-xr-x 14 root root 4096 8월 9 20:48 usr drwxr-xr-x 14 root root 4096 8월 9 20:54 var user@user-VirtualBox:~$ 위 ls 명령어 실행 결과에서 볼 수 있듯이 루트 디렉토리 안에 많은 디렉토리가 존재합니다. 이중 몇 가지 중요한 디렉토리들을 알아보겠습니다.\n/bin\n일반 유저가 사용할 수 있는 기본적인 명령어나 프로그램을 담고 있는 디렉토리입니다. /boot\n시스템 부팅에 필요한 파일들을 담고 있는 디렉토리입니다. /dev\n리눅스에서는 컴퓨터에 부착된 물리적인 장치들을 디바이스 드라이버를 거쳐 파일 형태로 접근 가능합니다. 그러한 장치들을 나타내는 파일들을 담고 있는 디렉토리입니다. /etc\n운영체제나 운영체제 위에서 동작하는 서비스의 설정 파일들을 담고 있는 디렉토리입니다. /home\n각 일반 유저의 홈 디렉토리를 담고 있는 디렉토리입니다. 일반 유저들은 각기 자신만의 홈 디렉토리를 가지고 있습니다. 예를 들어 dream 유저의 홈 디렉토리는 /home/dream 입니다. /lib\n시스템에 필요한 라이브러리 파일들을 담고 있는 디렉토리입니다. /bin 이나 /sbin 에 존재하는 프로그램이 필요로 하는 동적 라이브러리 파일이 /lib 디렉토리에 존재합니다. /opt\n소프트웨어 패키지들을 담는 디렉토리입니다. /proc\n리눅스 커널 자원에 접근할 수 있는 파일과 프로세스를 나타내는 파일을 담고 있습니다. /root\nroot 유저의 홈 디렉토리입니다. /sbin\n/bin 디렉토리와 마찬가지로 기본적인 유저 명령어나 프로그램을 가지고 있는 디렉토리입니다. /sbin은 root 유저가 사용할 수 있는 명령어나 프로그램을 가지고 있습니다. /tmp\n유저나 프로그램이 임시로 파일을 생성해야할 때 사용할 수 있는 디렉토리입니다. 본 디렉토리에 오래 존재했던 파일들은 자동으로 삭제되므로 주의하여 사용해야 합니다. /usr\n사용자 바이너리, 문서, 라이브러리, 헤더 파일 등을 담고 있는 디렉토리입니다. /var\n프로그램이나 시스템이 실시간으로 가변적인 파일을 사용하고 저장해야 할 때 활용하는 디렉토리입니다. 예를 들어 /var/log에는 다양한 로그 파일이 저장됩니다. 물론 모든 디렉토리의 모든 파일을 외울 수만 있다면 리눅스를 사용하는데 있어서 많은 도움이 됩니다. 하지만 처음부터 모든 디렉토리의 모든 파일을 다 외워야 하는 것은 아닙니다. 공부할수록 자주 접하는 디렉토리나 파일이 생기게 되고, 그런 것들을 시작으로 자연스럽게 기억하고 이해하게 될 것입니다.\n문제풀이 ls -\u0026gt; cat hint.txt -\u0026gt; cat /dream/hack/hello/flag.txt -\u0026gt; cat app.py -\u0026gt; cat ./dream/hack/hello/f*ag.txt DH{671ce26c70829e716fae26c7c71a33823feb479f2562891f64605bf68f60ae54}\n","permalink":"http://localhost:1313/posts/2026-01-08/","summary":"리눅스 사용법 정리글","title":"리눅스 사용법 한 눈에 살펴보기"},{"content":"1. 개요 (Intro) 안녕하세요, AlwaysHyeon의 보안 블로그입니다. 이 글은 GitHub Pages와 Hugo PaperMod 테마가 정상적으로 연동되었는지 확인하기 위한 테스트 포스트입니다.\n테스트 환경 Generator: Hugo Theme: PaperMod Hosting: GitHub Pages 2. 기능 테스트 (Feature Test) 2.1. 코드 하이라이팅 (Code Block) Python 코드가 예쁘게 나오는지 확인합니다.\n1 2 3 4 5 6 7 8 import os def check_security(): print(\u0026#34;System Secure... maybe?\u0026#34;) return True if __name__ == \u0026#34;__main__\u0026#34;: check_security() ","permalink":"http://localhost:1313/posts/test-post/","summary":"Hugo PaperMod 테마 적용 테스트 글입니다. 마크다운 문법과 코드 하이라이팅이 잘 적용되는지 확인합니다.","title":"블로그 테스트 및 첫 번째 글 (Hello World)"},{"content":"셸(Shell) 셸은 유저가 리눅스 시스템을 이용할 수 있는 인터페이스입니다. 사용자와 커널 사이에서 명령어를 해석하고 실행하는 중요한 역할을 합니다.\n터미널 실행 단축키 Windows/Linux: Ctrl + Alt + T macOS: Control + Option + T 또는 Command + Space로 Spotlight 실행 후 \u0026ldquo;Terminal\u0026rdquo; 입력 셸 프롬프트(Shell Prompt) 셸이 입력을 받을 준비가 되었을 때 다음과 같은 프롬프트가 표시됩니다:\n1 user@user-VirtualBox:~$ 프롬프트 구조:\nuser: 현재 로그인한 사용자 이름 user-VirtualBox: 호스트(컴퓨터) 이름 ~: 현재 위치한 디렉토리 (~는 홈 디렉토리를 의미) $: 일반 사용자 (#는 root 사용자를 의미) id 명령어 현재 유저의 사용자 ID(UID)와 해당 유저가 속해 있는 그룹 ID(GID)를 확인합니다.\n1 2 3 user@user-VirtualBox:~$ id uid=1000(user) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),134(lxd),135(sambashare) user@user-VirtualBox:~$ 기본 명령어 시스템 정보 및 관리 1. sudo apt update apt 명령어로 설치 가능한 소프트웨어 패키지 목록을 업데이트합니다. 각 소프트웨어별로 설치 가능한 버전 정보도 함께 업데이트합니다.\n1 sudo apt update 2. sudo apt upgrade 리눅스에 설치된 소프트웨어 패키지의 버전을 업그레이드합니다.\n1 sudo apt upgrade 3. id 리눅스는 권한을 기반으로 파일을 읽고 쓸 수 있기 때문에 주로 자신이 해당하는 권한을 가지고 있는지 확인하기 위해서 사용하는 명령어입니다.\n1 id 디렉토리 탐색 4. pwd Print Working Directory의 줄임말로 현재 작업 중인 디렉토리의 경로를 출력합니다.\n1 2 user@user-VirtualBox:~$ pwd /home/user 5. ls List의 줄임말로 디렉토리의 내용을 출력하는 명령어입니다.\n기본 사용법:\n1 2 ls # 현재 디렉토리 내용 ls /home # 특정 디렉토리 내용 유용한 옵션:\n1 2 3 4 5 6 ls -l # 상세 정보 포함 ls -a # 숨김 파일 포함 ls -lh # 사람이 읽기 쉬운 파일 크기 ls -lt # 수정 시간순 정렬 ls -lS # 파일 크기순 정렬 ls -lR # 하위 디렉토리까지 재귀적으로 표시 6. cd Change Directory의 줄임말로 작업 중인 디렉토리를 변경하는 명령어입니다.\n구분 기호/명령어 설명 예시 절대 경로 / 시작 루트 디렉토리(/)를 시작으로 모든 경로를 전부 적어서 표현하는 방식 cd /home/user 상대 경로 .. 등 현재 디렉토리를 기준으로 상위 또는 하위 디렉토리로 뻗어 나가는 방식 cd .. (현재 위치에서 부모 디렉토리로 이동) 홈 디렉토리 ~ 현재 로그인한 유저의 홈 디렉토리 cd ~ 또는 cd (내 홈 폴더로 이동) 이전 경로 - 직전에 위치했던 디렉토리 (바로 전 경로) cd - (이전 작업 위치로 복귀) 현재 디렉토리 . 현재 디렉토리 cd . (변화 없음, 주로 상대 경로에 활용) 파일 및 디렉토리 생성 7. mkdir Make Directory의 줄임말로 디렉토리를 생성하는 명령어입니다.\n1 2 3 mkdir new_dir # 단일 디렉토리 생성 mkdir dir1 dir2 dir3 # 여러 디렉토리 동시 생성 mkdir -p parent/child/grandchild # 상위 디렉토리까지 자동 생성 /home/user 디렉토리에 위치할 때 mkdir new_dir 명령어로 new_dir 디렉토리를 생성하면, new_dir가 새롭게 추가됩니다.\n8. touch 비어있는 새로운 파일을 만드는 데 사용합니다. 파일이 이미 존재하는 경우 수정 시간을 현재 시간으로 업데이트합니다.\n1 2 3 4 user@user-VirtualBox:~/new_dir$ ls -l user@user-VirtualBox:~/new_dir$ touch new_file user@user-VirtualBox:~/new_dir$ ls -l -rw-rw-r-- 1 user user 0 12월 2 13:05 new_file 여러 파일 동시 생성:\n1 touch file1.txt file2.txt file3.txt 파일 및 디렉토리 조작 9. mv Move의 줄임말로 파일이나 디렉토리의 위치를 옮기거나 이름을 변경할 때 사용하는 명령어입니다.\n이름 변경:\n1 mv old_name new_name 파일 이동:\n1 2 3 4 5 6 7 8 9 10 user@user-VirtualBox:~/new_dir$ ls old_file user@user-VirtualBox:~/new_dir$ ls .. Desktop Downloads new_dir Public Templates Documents Music Pictures snap Videos user@user-VirtualBox:~/new_dir$ mv old_file .. user@user-VirtualBox:~/new_dir$ ls user@user-VirtualBox:~/new_dir$ ls .. Desktop Downloads new_dir Pictures snap Videos Documents Music old_file Public Templates 여러 파일을 디렉토리로 이동:\n1 mv file1.txt file2.txt file3.txt /destination/ 10. cp Copy의 줄임말로 파일이나 디렉토리를 복사하는 명령어입니다.\n파일 복사:\n1 2 3 4 5 6 7 8 9 10 user@user-VirtualBox:~/new_dir$ ls -l total 4 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello user@user-VirtualBox:~/new_dir$ cp hello world user@user-VirtualBox:~/new_dir$ ls -l total 8 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello -rw-rw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ cat world Hello world! 디렉토리 복사:\n1 2 cp -r source_dir destination_dir # 디렉토리 전체 복사 cp -r dir1/ dir2/ # dir1의 내용을 dir2로 복사 유용한 옵션:\n1 2 3 cp -i file1 file2 # 덮어쓰기 전 확인 cp -v file1 file2 # 복사 과정 표시 cp -u file1 file2 # 더 최신 파일만 복사 11. rm Remove의 줄임말로 파일이나 디렉토리를 삭제하는 명령어입니다.\n파일 삭제:\n1 rm file.txt 디렉토리 삭제:\n1 rm -r directory_name # 디렉토리와 내용물 전체 삭제 유용한 옵션:\n1 2 3 rm -i file.txt # 삭제 전 확인 rm -f file.txt # 강제 삭제 (확인 없이) rm -rf directory/ # 디렉토리 강제 삭제 (주의!) 파일 내용 보기 12. cat 파일의 내용을 출력하는 명령어입니다. cat 파일경로 형식으로 사용할 수 있습니다.\n1 2 3 4 5 6 7 user@user-VirtualBox:~/new_dir$ cat /etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin ... (생략) user:x:1000:1000:user,,,:/home/user:/bin/bash 여러 파일 연결:\n1 cat file1.txt file2.txt \u0026gt; combined.txt 13. head / tail 파일의 처음 또는 끝 부분만 출력합니다.\n1 2 3 4 5 head file.txt # 처음 10줄 head -n 20 file.txt # 처음 20줄 tail file.txt # 마지막 10줄 tail -n 50 file.txt # 마지막 50줄 tail -f log.txt # 실시간 로그 모니터링 (매우 유용!) 14. less / more 파일 내용을 페이지 단위로 보여줍니다.\n1 2 less large_file.txt # 위아래 스크롤 가능, 검색 가능 (추천) more large_file.txt # 한 방향으로만 스크롤 less 명령어 내부에서:\nSpace: 다음 페이지 b: 이전 페이지 /word: 단어 검색 q: 종료 15. file 파일의 유형을 출력하는 명령어입니다.\n1 2 user@user-VirtualBox:~$ file /bin/ls /bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=897f49cafa98c11d63e619e7e40352f855249c13, for GNU/Linux 3.2.0, stripped 다양한 파일 타입 확인:\n1 2 3 file document.pdf # PDF document file image.jpg # JPEG image data file script.sh # Bourne-Again shell script 텍스트 출력 및 생성 16. echo 셸에 유저가 입력한 텍스트를 출력합니다.\n1 2 user@user-VirtualBox:~/new_dir$ echo \u0026#34;Hello world!\u0026#34; Hello world! 파일로 리다이렉션:\n1 2 3 4 5 6 7 8 user@user-VirtualBox:~/new_dir$ ls -l total 0 user@user-VirtualBox:~/new_dir$ echo \u0026#34;Hello world!\u0026#34; \u0026gt; hello user@user-VirtualBox:~/new_dir$ ls -l total 4 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello user@user-VirtualBox:~/new_dir$ cat hello Hello world! 파일에 추가:\n1 echo \u0026#34;Another line\u0026#34; \u0026gt;\u0026gt; hello 변수 출력:\n1 2 3 echo $HOME # 홈 디렉토리 경로 echo $PATH # PATH 환경 변수 echo $USER # 현재 사용자 이름 검색 및 필터링 17. grep 전체에서 특정 문자열을 찾을 때 사용합니다. grep 문자열 파일 형식으로 사용할 수 있습니다.\n기본 사용:\n1 2 3 user@user-VirtualBox:~/new_dir$ grep root /etc/passwd root:x:0:0:root:/root:/bin/bash nm-openvpn:x:121:127:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin 유용한 옵션:\n1 2 3 4 5 6 7 grep -i \u0026#34;error\u0026#34; log.txt # 대소문자 구분 없이 검색 grep -r \u0026#34;TODO\u0026#34; . # 현재 디렉토리에서 재귀 검색 grep -n \u0026#34;function\u0026#34; script.py # 줄 번호 포함 grep -v \u0026#34;comment\u0026#34; file.txt # 패턴과 일치하지 않는 줄 grep -c \u0026#34;error\u0026#34; log.txt # 일치하는 줄 개수만 출력 grep -A 3 \u0026#34;error\u0026#34; log.txt # 일치 줄 + 다음 3줄 grep -B 2 \u0026#34;error\u0026#34; log.txt # 일치 줄 + 이전 2줄 18. find 파일과 디렉토리를 검색하는 강력한 명령어입니다.\n1 2 3 4 5 6 7 find /home -name \u0026#34;*.txt\u0026#34; # 이름으로 검색 find . -type f -name \u0026#34;test*\u0026#34; # 파일만 검색 find . -type d -name \u0026#34;backup\u0026#34; # 디렉토리만 검색 find . -mtime -7 # 최근 7일 수정된 파일 find . -size +100M # 100MB 이상 파일 find . -name \u0026#34;*.log\u0026#34; -delete # 찾은 파일 삭제 find . -name \u0026#34;*.sh\u0026#34; -exec chmod +x {} \\; # 찾은 파일에 명령 실행 19. which / whereis 명령어나 프로그램의 위치를 찾습니다.\n1 2 3 which python # python 명령어의 실행 파일 위치 which gcc # gcc 컴파일러 위치 whereis ls # ls 명령어의 바이너리, 소스, 매뉴얼 위치 프로세스 관리 20. ps 현재 실행 중인 프로세스를 확인합니다.\n1 2 3 4 ps # 현재 터미널의 프로세스 ps aux # 모든 프로세스 상세 정보 ps aux | grep nginx # 특정 프로세스 찾기 ps -ef # 전체 프로세스 (다른 포맷) 21. top / htop 실시간으로 시스템 리소스와 프로세스를 모니터링합니다.\n1 2 top # 기본 모니터링 htop # 향상된 인터페이스 (설치 필요: sudo apt install htop) top 내부 명령:\nq: 종료 k: 프로세스 종료 M: 메모리 사용량 정렬 P: CPU 사용량 정렬 22. kill 프로세스를 종료합니다.\n1 2 3 kill 1234 # PID 1234 프로세스 종료 kill -9 1234 # 강제 종료 killall nginx # 이름으로 모든 nginx 프로세스 종료 도움말 23. man Manual의 줄임말로 특정 명령어의 매뉴얼을 보여주는 명령어입니다.\n1 2 3 man ls # ls 명령어 매뉴얼 man grep # grep 명령어 매뉴얼 man 5 passwd # /etc/passwd 파일 형식 매뉴얼 man 페이지 탐색:\nSpace: 다음 페이지 b: 이전 페이지 /word: 검색 q: 종료 24. help / \u0026ndash;help 간단한 도움말을 출력합니다.\n1 2 3 ls --help cp --help help cd # 내장 명령어 네트워크 25. curl client URL의 줄임말로 서버에 데이터를 보내거나 서버로부터 받는 데이터 전송 명령어입니다. HTTP, HTTPS, FTP 등 다양한 프로토콜을 지원합니다.\n기본 사용:\n1 curl https://example.com # 웹 페이지 내용 가져오기 주요 옵션:\n1 2 3 4 curl -o file.html https://example.com # 파일로 저장 curl -O https://example.com/file.zip # 원본 이름으로 저장 curl -i https://example.com # 응답 헤더 포함 curl -L https://example.com # 리다이렉트 따라가기 HTTP 메소드:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # GET 요청 (기본) curl https://api.example.com/users # POST 요청 curl -X POST https://api.example.com/data \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;,\u0026#34;age\u0026#34;:30}\u0026#39; # PUT 요청 curl -X PUT https://api.example.com/users/1 \\ -d \u0026#34;name=Jane\u0026#34; # DELETE 요청 curl -X DELETE https://api.example.com/users/1 워게임에서의 활용:\n1 2 3 4 5 # 명령어 실행 결과를 서버로 전송 curl \u0026#34;http://myserver.com\u0026#34; -d \u0026#34;`cat /flag`\u0026#34; # 파일 내용 전송 curl -X POST http://myserver.com -d \u0026#34;@/etc/passwd\u0026#34; 26. wget 파일을 다운로드하는 명령어입니다.\n1 2 3 4 wget https://example.com/file.zip # 파일 다운로드 wget -O custom_name.zip https://... # 다른 이름으로 저장 wget -c https://example.com/large.iso # 중단된 다운로드 이어받기 wget -r https://example.com # 웹사이트 전체 다운로드 압축 및 아카이브 27. tar 파일을 묶고 압축하는 명령어입니다.\n1 2 3 4 5 tar -cvf archive.tar files/ # 묶기 tar -czvf archive.tar.gz files/ # 묶고 gzip 압축 tar -xvf archive.tar # 풀기 tar -xzvf archive.tar.gz # gzip 압축 해제하며 풀기 tar -tvf archive.tar # 내용 확인 옵션 의미:\nc: create (생성) x: extract (추출) v: verbose (과정 표시) f: file (파일 지정) z: gzip 압축/해제 j: bzip2 압축/해제 28. zip / unzip zip 형식으로 압축합니다.\n1 2 3 4 zip archive.zip file1 file2 # 압축 zip -r archive.zip directory/ # 디렉토리 압축 unzip archive.zip # 압축 해제 unzip -l archive.zip # 내용만 확인 디스크 사용량 29. du 디렉토리와 파일의 디스크 사용량을 확인합니다.\n1 2 3 4 du -h # 사람이 읽기 쉬운 형식 du -sh * # 현재 디렉토리의 각 항목 크기 du -sh /home/user # 특정 디렉토리 전체 크기 du -h --max-depth=1 # 1단계 깊이까지만 30. df 파일 시스템의 디스크 공간 사용량을 확인합니다.\n1 2 df -h # 모든 파일 시스템 df -h /home # 특정 디렉토리가 속한 파일 시스템 고급 기능 와일드카드 **와일드카드(wildcards)**는 리눅스에서 임의의 다른 문자를 나타낐 수 있는 특수 문자들을 의미합니다. 주로 명령어를 다른 문자열로 대체하기 위해 사용합니다.\n기본 와일드카드\n? - 임의의 1개 문자\na-z, 0-9 범위 내 임의의 1개 문자로 대체됩니다. 1 2 ls file?.txt # file1.txt, fileA.txt 등 매칭 ls test? # test1, testa 등 매칭 * - 임의의 0개 이상 문자\na-z, 0-9 범위 내 임의의 0개 이상 문자로 대체됩니다. 1 2 3 ls *.txt # 모든 .txt 파일 ls test* # test로 시작하는 모든 파일 ls *backup* # backup이 포함된 모든 파일 [] - 범위 지정\n[문자1-문자2] 혹은 [문자1, 문자2, …] 형태로 범위를 지정합니다. 1 2 3 ls file[1-3].txt # file1.txt, file2.txt, file3.txt ls [abc]* # a, b, c로 시작하는 파일 ls *.[ch] # .c 또는 .h로 끝나는 파일 실전 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # .txt로 끝나는 모든 파일 삭제 rm *.txt # file1, file2, file3... file9 선택 ls file[1-9] # 이름이 정확히 3글자인 모든 파일 ls ??? # test로 시작하는 모든 파일을 /backup/으로 복사 cp test* /backup/ # 2024년 로그 파일 전체 보기 cat log-2024-*.txt # JPG 또는 PNG 이미지 파일 이동 mv *.{jpg,png} images/ 리다이렉션 **리다이렉션(redirection)**은 모니터에 나타나는 표준 출력 혹은 키보드로 입력하는 표준 입력을 다른 곳으로 변경하는 작업입니다.\n표준 스트림\n표준 입력 (stdin): 0번, 키보드로부터의 입력 표준 출력 (stdout): 1번, 화면으로의 정상 출력 표준 에러 (stderr): 2번, 화면으로의 에러 메시지 출력 리다이렉션\n명령어 \u0026gt; 파일\n명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 덮어씁니다. 1 2 ls -l \u0026gt; file_list.txt # 출력을 파일에 저장 (덮어쓰기) echo \u0026#34;Hello\u0026#34; \u0026gt; greeting.txt 명령어 \u0026gt;\u0026gt; 파일\n명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 이어서 씁니다. 1 2 3 echo \u0026#34;Line 1\u0026#34; \u0026gt; log.txt # 새로 생성 echo \u0026#34;Line 2\u0026#34; \u0026gt;\u0026gt; log.txt # 추가 echo \u0026#34;Line 3\u0026#34; \u0026gt;\u0026gt; log.txt # 추가 명령어 2\u0026gt; 파일\n에러 메시지만 파일로 저장합니다. 1 2 3 4 command 2\u0026gt; error.log # 에러만 파일에 저장 command \u0026gt; output.txt 2\u0026gt; error.log # 출력과 에러 분리 command \u0026gt; output.txt 2\u0026gt;\u0026amp;1 # 출력과 에러를 같은 파일에 command \u0026amp;\u0026gt; all.log # 출력과 에러를 같은 파일에 (축약형) 입력 리다이렉션\n명령어 \u0026lt; 파일\n명령어 표준 입력을 파일로 변경합니다. 파일로부터 표준 입력을 받아 명령어를 수행합니다. 1 2 sort \u0026lt; unsorted.txt # 파일 내용을 정렬 wc -l \u0026lt; file.txt # 파일 줄 수 세기 Here Document\n1 2 3 4 5 cat \u0026lt;\u0026lt; EOF \u0026gt; file.txt 여러 줄의 텍스트를 입력할 수 있습니다 EOF 파이프 **파이프(pipe)**는 리다이렉션의 한 형태로, 명령어 결과 표준 출력을 다른 명령어의 표준 입력으로 보낼 때 사용합니다. 파이프는 | 문자로 나타냅니다.\n기본 사용\n1 2 3 ls -l | grep \u0026#34;.txt\u0026#34; # ls 출력에서 .txt 검색 cat file.txt | wc -l # 파일 줄 수 세기 ps aux | grep nginx # 프로세스 필터링 실전 파이프 활용\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 가장 많이 사용하는 명령어 top 10 history | awk \u0026#39;{print $2}\u0026#39; | sort | uniq -c | sort -rn | head # 특정 프로세스의 메모리 사용량 확인 ps aux | grep nginx | awk \u0026#39;{print $6}\u0026#39; # 로그에서 에러만 필터링하여 개수 확인 cat app.log | grep ERROR | wc -l # 디렉토리별 용량 확인 후 정렬 du -sh */ | sort -h # 가장 큰 파일 10개 찾기 du -ah | sort -rh | head -10 # 특정 확장자 파일 개수 find . -name \u0026#34;*.py\u0026#34; | wc -l # CPU 사용률 높은 프로세스 상위 5개 ps aux | sort -nrk 3 | head -5 # 특정 포트를 사용하는 프로세스 찾기 netstat -tuln | grep :80 # 중복 제거된 정렬된 목록 cat list.txt | sort | uniq # 로그에서 IP 주소 추출 및 빈도 분석 grep -oE \u0026#39;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#39; access.log | sort | uniq -c | sort -rn 권한 유저(user)와 그룹(group) 리눅스에서 유저와 그룹은 리눅스의 권한 시스템을 설명하기 위해 빠뜨릴 수 없는 개념입니다. 리눅스의 각 유저는 이름과 고유한 사용자 ID(UID)를 가지고 있습니다. 그룹은 말 그대로 여러 유저가 속할 수 있는 그룹으로, 이 역시 그룹 이름과 고유한 그룹 ID(GID)를 가지고 있습니다.\n파일이나 디렉토리와 같은 시스템 자원에 유저가 접근하면 유저의 UID와 해당 유저가 속한 그룹의 GID를 확인하여 정당한 권한을 가지고 있는지를 판단해 접근을 제어합니다.\n유저 정보 확인\n/etc/passwd는 리눅스의 유저 정보를 담고 있는 텍스트 파일입니다. 각 사용자의 이름, 사용자 ID, 속해있는 그룹 ID 등의 정보를 포함하고 있습니다.\n1 cat /etc/passwd 각 줄의 형식: username:x:UID:GID:comment:home_directory:shell\n예시:\nroot:x:0:0:root:/root:/bin/bash\ruser:x:1000:1000:user,,,:/home/user:/bin/bash 그룹 정보 확인\n/etc/group은 리눅스의 그룹 정보를 저장하는 텍스트 파일입니다. 각 그룹의 이름, 그룹 ID, 그룹에 속한 유저 목록 등의 정보를 포함하고 있습니다.\n1 cat /etc/group 유저 관련 명령어\n1 2 3 4 whoami # 현재 사용자 이름 id # 현재 사용자의 UID, GID 정보 groups # 현재 사용자가 속한 그룹들 users # 현재 로그인한 사용자들 파일 및 디렉토리 권한 리눅스는 사용자가 파일과 디렉토리에 접근하는 행위에 대해 권한으로 제어합니다. 각 파일과 디렉토리는 **소유자(owner)**와 **소유 그룹(group)**을 가지고 있습니다. 소유자는 파일 또는 디렉토리의 권한을 수정할 수 있는 능력을 가지고 있습니다.\n세 가지 접근 권한\n읽기(Read, r): 파일 또는 디렉토리의 내용을 볼 수 있게 허용합니다.\n파일: 파일 내용을 읽을 수 있음 디렉토리: 디렉토리 내 파일 목록을 볼 수 있음 쓰기(Write, w): 파일 또는 디렉토리의 내용을 수정하거나 삭제하는 것을 허용합니다.\n파일: 파일 내용을 수정하거나 삭제할 수 있음 디렉토리: 디렉토리 내에 파일을 생성하거나 삭제할 수 있음 실행(Execute, x): 파일이 프로그램인 경우 실행할 수 있게 허용합니다.\n파일: 프로그램으로 실행할 수 있음 디렉토리: 디렉토리에 접근(cd)할 수 있음 권한 확인하기\n파일이나 디렉토리의 권한을 보기 위해 ls -l을 사용합니다.\n1 2 3 4 5 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ---------- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world 권한 플래그 해석 1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir 권한 플래그 drwxrwxr-x는 4개 부분으로 나뉩니다:\nd rwx rwx r-x\r│ └┬┘ └┬┘ └┬┘\r│ │ │ └─→ 기타 사용자 권한 (r-x: 읽기, 실행)\r│ │ └─────→ 그룹 권한 (rwx: 읽기, 쓰기, 실행)\r│ └─────────→ 소유자 권한 (rwx: 읽기, 쓰기, 실행)\r└────────────→ 파일 타입 (d: 디렉토리) 파일 타입 (첫 번째 문자)\nd: 디렉토리 (directory) -: 일반 파일 (regular file) l: 심볼릭 링크 (symbolic link) b: 블록 디바이스 (block device) c: 문자 디바이스 (character device) s: 소켓 (socket) p: 파이프 (pipe) 권한 문자\nr: 읽기 권한 (Read) w: 쓰기 권한 (Write) x: 실행 권한 (Execute) -: 해당 권한 없음 권한의 숫자 표현\n권한은 2진수나 10진수로도 표현할 수 있습니다.\n권한 2진수 10진수 의미 --- 000 0 권한 없음 --x 001 1 실행만 -w- 010 2 쓰기만 -wx 011 3 쓰기, 실행 r-- 100 4 읽기만 r-x 101 5 읽기, 실행 rw- 110 6 읽기, 쓰기 rwx 111 7 모든 권한 예시:\nrwx = 111 = 7 rw- = 110 = 6 r-- = 100 = 4 rwxrw-r-- = 764 소유자와 소유 그룹\n1 2 3 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ↑ ↑ 소유자 소유그룹 세 번째 열: 파일/디렉토리의 소유자 네 번째 열: 파일/디렉토리의 소유 그룹 종합 예시\n1 -rwxrw-r-- 1 user user 13 12월 2 13:08 world 해석:\n파일 타입: - (일반 파일) 소유자 권한: rwx (읽기, 쓰기, 실행 가능) 그룹 권한: rw- (읽기, 쓰기 가능, 실행 불가) 기타 권한: r-- (읽기만 가능) 소유자: user 소유 그룹: user 파일 및 디렉토리 권한 명령어 chmod chmod는 파일 권한을 변경하는 명령어입니다. root 유저 혹은 파일의 소유자만 실행할 수 있습니다.\n형식\n1 chmod 권한 파일명 숫자 모드\n1 2 3 4 5 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ---------- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world hello 파일을 rwxrw-r-- (764) 권한으로 변경:\n소유자: rwx = 7 그룹: rw- = 6 기타: r-- = 4 1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ chmod 764 hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxrw-r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world 기호 모드\n대상:\nu: 소유자 (user) g: 그룹 (group) o: 기타 (others) a: 모두 (all) 연산:\n+: 권한 추가 -: 권한 제거 =: 권한 설정 권한 추가:\n1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ chmod g+x hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxrwxr-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world 권한 제거:\n1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ chmod g-wx hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world 유용한 예시\n1 2 3 4 5 6 7 8 chmod 644 file.txt # rw-r--r-- (일반 파일) chmod 755 script.sh # rwxr-xr-x (실행 파일) chmod 700 private.txt # rwx------ (소유자만 접근) chmod 777 public_dir # rwxrwxrwx (모두 접근, 위험!) chmod -R 755 directory/ # 디렉토리와 내부 파일 전체에 적용 chmod u+x script.sh # 소유자에게 실행 권한 추가 chmod a-w file.txt # 모두에게서 쓰기 권한 제거 chmod o-rwx private # 기타 사용자 모든 권한 제거 chown chown은 파일 소유자 혹은 소유 그룹을 변경하는 명령어입니다. root 유저만 실행할 수 있습니다.\n형식\n1 chown 사용자명[:그룹명] 파일명 소유자 변경\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ sudo chown root hello [sudo] password for user: user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ echo \u0026#34;hello\u0026#34; \u0026gt; hello bash: hello: Permission denied 소유자와 그룹 동시 변경\n1 2 3 sudo chown root:root hello # 소유자와 그룹을 root로 sudo chown user:developers file.txt # 특정 사용자와 그룹으로 sudo chown -R user:user directory/ # 디렉토리 전체에 재귀적으로 적용 chgrp chgrp는 소유 그룹만 변경하는 명령어입니다.\n1 2 sudo chgrp developers file.txt # 그룹만 변경 sudo chgrp -R www-data /var/www/ # 디렉토리 전체에 적용 특수 권한 앞서 배운 r, w, x 권한 외에 특수한 권한 3가지가 있습니다.\nsetuid (Set User ID) 일반 사용자가 파일을 실행하면 파일 소유자 권한으로 실행됩니다.\n예시: /bin/passwd\n1 2 user@user-VirtualBox:/bin$ ls -l passwd -rwsr-xr-x 1 root root 59976 11월 24 21:05 passwd 소유자의 실행 권한에 x 대신 s가 표시됩니다. 이는 일반 사용자가 passwd 명령을 실행하면 root 권한으로 실행되어 자신의 비밀번호를 변경할 수 있게 합니다.\ns: setuid가 설정되고 실행 권한도 있음 S: setuid는 설정되었지만 실행 권한이 없음 (의미 없음) setgid (Set Group ID) 일반 사용자가 파일을 실행하면 파일 소유 그룹 권한으로 실행됩니다.\n소유 그룹의 실행 권한에 x 대신 s가 표시됩니다.\n디렉토리에 setgid를 설정하면 해당 디렉토리 내에서 생성되는 모든 파일이 디렉토리의 그룹을 상속받습니다.\n1 drwxr-sr-x 2 user developers 4096 12월 2 13:38 shared_dir s: setgid가 설정되고 실행 권한도 있음 S: setgid는 설정되었지만 실행 권한이 없음 sticky bit 디렉토리에 sticky bit를 설정하면 파일 및 디렉토리 소유자와 root 사용자 외에는 일반 사용자가 파일을 삭제할 수 없습니다. 주로 공용 디렉토리에 사용합니다.\n예시: /tmp 디렉토리\n1 drwxrwxrwt 20 root root 4096 12월 1 14:17 tmp 일반 사용자의 실행 권한에 x 대신 t가 표시됩니다.\nt: sticky bit가 설정되고 실행 권한도 있음 T: sticky bit는 설정되었지만 실행 권한이 없음 특수 권한 설정 특수 권한은 숫자 형식으로 권한 플래그 맨 앞에 붙여 표현합니다:\nsetuid: 4 setgid: 2 sticky bit: 1 숫자 모드\n1 2 3 4 5 6 7 8 9 10 11 12 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ chmod 4775 world user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwsrwxr-x 1 user user 13 12월 2 13:08 world 기호 모드\n1 2 3 4 chmod u+s file # setuid 설정 chmod g+s directory # setgid 설정 chmod o+t directory # sticky bit 설정 chmod u-s file # setuid 제거 조합 예시\n1 2 3 4 chmod 4755 program # rwsr-xr-x (setuid) chmod 2755 shared_dir # rwxr-sr-x (setgid) chmod 1777 /tmp # rwxrwxrwt (sticky bit) chmod 6755 file # rwsr-sr-x (setuid + setgid) 디렉토리 구조 루트 디렉토리 / 루트 디렉토리는 리눅스의 최상위 디렉토리를 말하며, 절대 경로는 /입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 user@user-VirtualBox:~$ ls -l / total 3991632 lrwxrwxrwx 1 root root 7 11월 30 18:15 bin -\u0026gt; usr/bin drwxr-xr-x 4 root root 4096 12월 1 14:10 boot drwxrwxr-x 2 root root 4096 11월 30 18:25 cdrom drwxr-xr-x 19 root root 4180 12월 1 14:25 dev drwxr-xr-x 130 root root 12288 12월 1 14:09 etc drwxr-xr-x 3 root root 4096 11월 30 18:27 home lrwxrwxrwx 1 root root 7 11월 30 18:15 lib -\u0026gt; usr/lib lrwxrwxrwx 1 root root 9 11월 30 18:15 lib32 -\u0026gt; usr/lib32 lrwxrwxrwx 1 root root 9 11월 30 18:15 lib64 -\u0026gt; usr/lib64 lrwxrwxrwx 1 root root 10 11월 30 18:15 libx32 -\u0026gt; usr/libx32 drwx------ 2 root root 16384 11월 30 18:14 lost+found drwxr-xr-x 3 root root 4096 11월 30 19:49 media drwxr-xr-x 2 root root 4096 8월 9 20:48 mnt drwxr-xr-x 3 root root 4096 11월 30 19:55 opt dr-xr-xr-x 257 root root 0 12월 1 14:11 proc drwx------ 4 root root 4096 12월 1 14:17 root drwxr-xr-x 33 root root 900 12월 1 14:12 run lrwxrwxrwx 1 root root 8 11월 30 18:15 sbin -\u0026gt; usr/sbin drwxr-xr-x 11 root root 4096 8월 9 20:55 snap drwxr-xr-x 2 root root 4096 8월 9 20:48 srv -rw------- 1 root root 4087349248 11월 30 18:15 swapfile dr-xr-xr-x 13 root root 0 12월 1 14:11 sys drwxrwxrwt 20 root root 4096 12월 1 14:17 tmp drwxr-xr-x 14 root root 4096 8월 9 20:48 usr drwxr-xr-x 14 root root 4096 8월 9 20:54 var 주요 디렉토리 설명 /bin - 기본 명령어 일반 유저가 사용할 수 있는 기본적인 명령어나 프로그램을 담고 있는 디렉토리입니다.\n1 ls, cp, mv, rm, cat, echo, mkdir, chmod, ps 등 최신 시스템에서는 /usr/bin으로의 심볼릭 링크입니다.\n/boot - 부팅 파일 시스템 부팅에 필요한 파일들을 담고 있는 디렉토리입니다.\n1 커널 이미지, 부트로더 설정 파일, initramfs 등 /dev - 디바이스 파일 컴퓨터에 부착된 물리적인 장치들을 파일 형태로 접근할 수 있게 합니다.\n1 2 3 4 5 /dev/sda # 첫 번째 하드 디스크 /dev/sda1 # 첫 번째 하드 디스크의 첫 번째 파티션 /dev/null # 널 디바이스 (출력 버리기에 사용) /dev/zero # 0을 무한히 생성 /dev/random # 난수 생성기 /etc - 설정 파일 운영체제나 운영체제 위에서 동작하는 서비스의 설정 파일들을 담고 있는 디렉토리입니다.\n1 2 3 4 5 6 7 /etc/passwd # 사용자 정보 /etc/group # 그룹 정보 /etc/hosts # 호스트 이름 매핑 /etc/hostname # 시스템 호스트명 /etc/ssh/ # SSH 서버 설정 /etc/nginx/ # Nginx 웹서버 설정 /etc/apache2/ # Apache 웹서버 설정 /home - 사용자 홈 디렉토리 각 일반 유저의 홈 디렉토리를 담고 있는 디렉토리입니다.\n1 2 /home/user # user 사용자의 홈 디렉토리 /home/dream # dream 사용자의 홈 디렉토리 각 사용자는 자신의 홈 디렉토리에서 완전한 권한을 가집니다.\n/lib, /lib32, /lib64 - 라이브러리 시스템에 필요한 라이브러리 파일들을 담고 있는 디렉토리입니다.\n1 공유 라이브러리, 커널 모듈 등 /bin이나 /sbin의 프로그램이 필요로 하는 동적 라이브러리 파일이 존재합니다.\n/media - 이동식 미디어 이동식 미디어(USB, CD/DVD 등)가 자동으로 마운트되는 디렉토리입니다.\n1 2 /media/user/USB_DRIVE /media/user/CDROM /mnt - 임시 마운트 파일 시스템을 임시로 마운트하는 데 사용하는 디렉토리입니다.\n1 sudo mount /dev/sdb1 /mnt /opt - 선택적 소프트웨어 추가로 설치한 소프트웨어 패키지들을 담는 디렉토리입니다.\n1 2 /opt/google/chrome /opt/teamviewer /proc - 프로세스 정보 리눅스 커널 자원에 접근할 수 있는 가상 파일 시스템입니다. 프로세스와 시스템 정보를 파일 형태로 제공합니다.\n1 2 3 4 /proc/cpuinfo # CPU 정보 /proc/meminfo # 메모리 정보 /proc/[PID]/ # 각 프로세스 정보 /proc/version # 커널 버전 /root - root 사용자 홈 root 유저의 홈 디렉토리입니다. /home/root가 아님에 주의하세요.\n/run - 런타임 데이터 시스템이 부팅된 이후 런타임 데이터를 저장합니다.\n1 PID 파일, 소켓 파일 등 /sbin - 시스템 관리 명령어 /bin 디렉토리와 유사하지만, root 유저가 사용하는 시스템 관리 명령어를 포함합니다.\n1 fdisk, mkfs, shutdown, reboot, iptables 등 /srv - 서비스 데이터 시스템에서 제공하는 서비스의 데이터를 저장하는 디렉토리입니다.\n1 2 /srv/www # 웹 서버 데이터 /srv/ftp # FTP 서버 데이터 /sys - 시스템 정보 커널과 하드웨어 정보를 제공하는 가상 파일 시스템입니다.\n/tmp - 임시 파일 유저나 프로그램이 임시로 파일을 생성할 때 사용하는 디렉토리입니다.\n주의: 시스템 재부팅 시 또는 일정 시간이 지나면 파일이 자동으로 삭제될 수 있습니다.\n1 drwxrwxrwt # sticky bit로 보호됨 /usr - 사용자 프로그램 사용자 바이너리, 문서, 라이브러리, 헤더 파일 등을 담고 있는 디렉토리입니다.\n1 2 3 4 5 6 /usr/bin/ # 사용자 명령어 /usr/sbin/ # 시스템 관리 명령어 /usr/lib/ # 라이브러리 /usr/local/ # 로컬에 설치한 프로그램 /usr/share/ # 아키텍처 독립적인 데이터 /usr/include/ # C 헤더 파일 /var - 가변 데이터 프로그램이나 시스템이 실시간으로 가변적인 파일을 사용하고 저장할 때 활용하는 디렉토리입니다.\n1 2 3 4 5 6 /var/log/ # 각종 로그 파일 /var/www/ # 웹 서버 루트 (보통) /var/mail/ # 메일 스풀 /var/spool/ # 대기열 데이터 (프린터, cron 등) /var/tmp/ # 재부팅 후에도 유지되는 임시 파일 /var/cache/ # 애플리케이션 캐시 ⚠️ 주의사항 및 안전 사용 팁 위험한 명령어들 절대 실행하지 마세요!\n1 2 3 4 5 6 rm -rf / # 시스템 전체 삭제 (현대 시스템은 보호됨) rm -rf /* # 루트 디렉토리의 모든 내용 삭제 chmod 777 -R / # 모든 파일 권한 열기 (심각한 보안 위험) dd if=/dev/zero of=/dev/sda # 디스크 전체 초기화 mkfs.ext4 /dev/sda # 파티션 포맷 (데이터 삭제) :(){ :|:\u0026amp; };: # Fork bomb (시스템 멈춤) 안전한 사용 습관 1. 삭제 전 항상 확인\n1 2 ls -l file* # 먼저 어떤 파일이 매칭되는지 확인 rm -i file* # 삭제 전 각 파일마다 확인 2. 중요한 작업 전 백업\n1 2 cp important.txt important.txt.backup tar -czf backup_$(date +%Y%m%d).tar.gz /important/directory/ 3. sudo 사용 시 신중하게\n1 2 3 4 5 6 # 나쁜 예 sudo rm -rf /tmp ../file # 경로 실수 시 위험 # 좋은 예 ls -l /tmp ../file # 먼저 확인 sudo rm -rf /tmp ../file # 확인 후 실행 4. 와일드카드 사용 시 주의\n1 2 3 4 5 6 # 나쁜 예 rm * .txt # 모든 파일 삭제 후 .txt 삭제 시도 # 좋은 예 rm *.txt # .txt 파일만 삭제 ls *.txt # 먼저 무엇이 삭제될지 확인 5. 절대 경로 vs 상대 경로\n1 2 3 4 5 6 # 현재 위치를 항상 확인 pwd # 중요한 작업은 절대 경로 사용 rm -rf /home/user/old_project # 명확함 # rm -rf ../../../old_project # 위험할 수 있음 유용한 팁과 트릭 명령어 히스토리 1 2 3 4 5 history # 명령어 이력 보기 !100 # 100번째 명령어 실행 !! # 마지막 명령어 실행 !grep # grep으로 시작하는 마지막 명령어 실행 Ctrl + R # 명령어 이력 검색 (interactive) 단축키 터미널 조작\nCtrl + C # 현재 실행 중인 프로세스 중단\rCtrl + Z # 현재 프로세스 일시 중지\rCtrl + D # 로그아웃 / EOF 전송\rCtrl + L # 화면 지우기 (clear 명령어와 동일) 커서 이동\nCtrl + A # 줄의 시작으로\rCtrl + E # 줄의 끝으로\rCtrl + U # 커서부터 앞쪽 전체 삭제\rCtrl + K # 커서부터 뒷쪽 전체 삭제\rCtrl + W # 커서 앞의 단어 삭제 Tab 자동완성\nTab # 파일명/명령어 자동완성\rTab Tab # 가능한 모든 옵션 표시 별칭(Alias) 설정 자주 사용하는 명령어를 짧게 만들 수 있습니다.\n1 2 3 4 5 6 7 8 9 # 임시 별칭 (현재 세션만) alias ll=\u0026#39;ls -alh\u0026#39; alias ..=\u0026#39;cd ..\u0026#39; alias ...=\u0026#39;cd ../..\u0026#39; alias grep=\u0026#39;grep --color=auto\u0026#39; # 영구 별칭 (~/.bashrc 또는 ~/.zshrc에 추가) echo \u0026#34;alias ll=\u0026#39;ls -alh\u0026#39;\u0026#34; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc 환경 변수 1 2 3 4 5 6 7 8 9 10 11 echo $PATH # PATH 환경 변수 확인 echo $HOME # 홈 디렉토리 echo $USER # 현재 사용자 echo $SHELL # 현재 셸 # 환경 변수 설정 export MY_VAR=\u0026#34;value\u0026#34; echo $MY_VAR # 영구 설정 (~/.bashrc에 추가) echo \u0026#39;export PATH=$PATH:/my/custom/path\u0026#39; \u0026gt;\u0026gt; ~/.bashrc 작업 관리 1 2 3 4 5 command \u0026amp; # 백그라운드에서 실행 jobs # 백그라운드 작업 목록 fg %1 # 1번 작업을 포그라운드로 bg %1 # 1번 작업을 백그라운드로 nohup command \u0026amp; # 로그아웃 후에도 계속 실행 파일 찾기 고급 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 최근 수정된 파일 찾기 find . -mtime -7 # 7일 이내 find . -mmin -60 # 60분 이내 # 파일 크기로 찾기 find . -size +100M # 100MB 이상 find . -size -1k # 1KB 이하 # 찾은 파일에 명령 실행 find . -name \u0026#34;*.log\u0026#34; -exec rm {} \\; find . -type f -name \u0026#34;*.txt\u0026#34; -exec grep \u0026#34;error\u0026#34; {} + # 여러 조건 조합 find . -type f -name \u0026#34;*.py\u0026#34; -size +1M -mtime -30 텍스트 처리 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 줄 번호 표시 cat -n file.txt nl file.txt # 중복 제거 sort file.txt | uniq sort -u file.txt # 컬럼 추출 awk \u0026#39;{print $1}\u0026#39; file.txt # 첫 번째 컬럼 cut -d\u0026#39;:\u0026#39; -f1 /etc/passwd # : 구분자로 첫 번째 필드 # 문자열 치환 sed \u0026#39;s/old/new/\u0026#39; file.txt # 첫 번째 매치만 sed \u0026#39;s/old/new/g\u0026#39; file.txt # 모든 매치 sed -i \u0026#39;s/old/new/g\u0026#39; file.txt # 파일 직접 수정 시스템 모니터링 1 2 3 4 5 6 7 8 9 10 11 12 # 디스크 I/O iostat iotop # 실시간 I/O 모니터링 # 네트워크 netstat -tuln # 리스닝 포트 ss -tuln # 현대적인 대체 lsof -i :80 # 특정 포트 사용 프로세스 # 메모리 free -h # 메모리 사용량 vmstat # 가상 메모리 통계 실전 시나리오 시나리오 1: 디스크 공간 확보 상황: 디스크 공간이 부족합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 1. 디스크 사용량 확인 df -h # 2. 큰 파일/디렉토리 찾기 du -sh /* | sort -h # 3. 특정 디렉토리 상세 분석 du -h --max-depth=1 /home | sort -h # 4. 100MB 이상 파일 찾기 find / -type f -size +100M 2\u0026gt;/dev/null # 5. 오래된 로그 파일 정리 find /var/log -name \u0026#34;*.log\u0026#34; -mtime +30 -delete # 6. 임시 파일 정리 sudo apt clean # 패키지 캐시 rm -rf ~/.cache/* # 사용자 캐시 시나리오 2: 시스템 느림 진단 상황: 시스템이 갑자기 느려졌습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 1. CPU 사용률 확인 top # 또는 htop # 2. CPU 사용 상위 프로세스 ps aux --sort=-%cpu | head # 3. 메모리 사용 상위 프로세스 ps aux --sort=-%mem | head # 4. 디스크 I/O 확인 iostat -x 1 # 5. 특정 프로세스 종료 kill -9 [PID] 시나리오 3: 로그 분석 상황: 웹 서버에 문제가 있어 로그를 분석해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1. 최근 에러 확인 tail -f /var/log/nginx/error.log # 2. 특정 시간대 로그 grep \u0026#34;2026-01-12 14:\u0026#34; /var/log/nginx/access.log # 3. 404 에러 개수 grep \u0026#34;404\u0026#34; /var/log/nginx/access.log | wc -l # 4. IP별 요청 횟수 awk \u0026#39;{print $1}\u0026#39; /var/log/nginx/access.log | sort | uniq -c | sort -rn # 5. 가장 많이 요청된 URL awk \u0026#39;{print $7}\u0026#39; /var/log/nginx/access.log | sort | uniq -c | sort -rn | head # 6. 에러 로그를 파일로 저장 grep \u0026#34;error\u0026#34; /var/log/nginx/error.log \u0026gt; errors_$(date +%Y%m%d).log 시나리오 4: 백업 및 복원 상황: 프로젝트 파일을 백업하고 싶습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1. 압축 백업 생성 tar -czf backup_$(date +%Y%m%d_%H%M%S).tar.gz /path/to/project # 2. 원격 서버로 전송 scp backup_*.tar.gz user@remote:/backup/ # 3. 백업에서 복원 tar -xzf backup_20260112_143000.tar.gz # 4. 특정 파일만 추출 tar -xzf backup.tar.gz path/to/specific/file # 5. 증분 백업 (rsync 사용) rsync -avz --delete /source/ /backup/ # 6. 원격 동기화 rsync -avz -e ssh /local/path/ user@remote:/remote/path/ 시나리오 5: 권한 문제 해결 상황: 웹 서버가 특정 파일에 접근하지 못합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 1. 파일 권한 확인 ls -l /var/www/html/ # 2. 소유자 확인 stat /var/www/html/index.html # 3. 웹 서버 사용자 확인 (nginx 예시) ps aux | grep nginx # 4. 소유자 변경 sudo chown -R www-data:www-data /var/www/html/ # 5. 권한 설정 sudo find /var/www/html -type d -exec chmod 755 {} \\; sudo find /var/www/html -type f -exec chmod 644 {} \\; # 6. 특수 권한이 필요한 경우 sudo chmod u+s /usr/bin/special_program 실전 문제 풀이 1 2 3 4 5 ls # 현재 디렉토리 파일 확인 cat hint.txt # 힌트 파일 읽기 cat /dream/hack/hello/flag.txt # 힌트에 나온 경로의 플래그 읽기 cat app.py # 추가 파일 확인 cat ./dream/hack/hello/f*ag.txt # 와일드카드로 플래그 파일 읽기 Details 플래그: DH{671ce26c70829e716fae26c7c71a33823feb479f2562891f64605bf68f60ae54}\n","permalink":"http://localhost:1313/posts/2026-01-08/","summary":"리눅스 사용법 정리글 - 개선판","title":"리눅스 사용법 완벽 가이드"},{"content":"1. 개요 (Intro) 안녕하세요, AlwaysHyeon의 보안 블로그입니다. 이 글은 GitHub Pages와 Hugo PaperMod 테마가 정상적으로 연동되었는지 확인하기 위한 테스트 포스트입니다.\n테스트 환경 Generator: Hugo Theme: PaperMod Hosting: GitHub Pages 2. 기능 테스트 (Feature Test) 2.1. 코드 하이라이팅 (Code Block) Python 코드가 예쁘게 나오는지 확인합니다.\n1 2 3 4 5 6 7 8 import os def check_security(): print(\u0026#34;System Secure... maybe?\u0026#34;) return True if __name__ == \u0026#34;__main__\u0026#34;: check_security() ","permalink":"http://localhost:1313/posts/test-post/","summary":"Hugo PaperMod 테마 적용 테스트 글입니다. 마크다운 문법과 코드 하이라이팅이 잘 적용되는지 확인합니다.","title":"블로그 테스트 및 첫 번째 글 (Hello World)"},{"content":"셸(Shell) 셸은 유저가 리눅스 시스템을 이용할 수 있는 인터페이스입니다. 사용자와 커널 사이에서 명령어를 해석하고 실행하는 중요한 역할을 합니다.\n터미널 실행 단축키 Windows/Linux: Ctrl + Alt + T macOS: Control + Option + T 또는 Command + Space로 Spotlight 실행 후 \u0026ldquo;Terminal\u0026rdquo; 입력 셸 프롬프트(Shell Prompt) 셸이 입력을 받을 준비가 되었을 때 다음과 같은 프롬프트가 표시됩니다:\n1 user@user-VirtualBox:~$ 프롬프트 구조:\nuser: 현재 로그인한 사용자 이름 user-VirtualBox: 호스트(컴퓨터) 이름 ~: 현재 위치한 디렉토리 (~는 홈 디렉토리를 의미) $: 일반 사용자 (#는 root 사용자를 의미) id 명령어 현재 유저의 사용자 ID(UID)와 해당 유저가 속해 있는 그룹 ID(GID)를 확인합니다.\n1 2 3 user@user-VirtualBox:~$ id uid=1000(user) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),134(lxd),135(sambashare) user@user-VirtualBox:~$ 기본 명령어 시스템 정보 및 관리 1. sudo apt update apt 명령어로 설치 가능한 소프트웨어 패키지 목록을 업데이트합니다. 각 소프트웨어별로 설치 가능한 버전 정보도 함께 업데이트합니다.\n1 sudo apt update 2. sudo apt upgrade 리눅스에 설치된 소프트웨어 패키지의 버전을 업그레이드합니다.\n1 sudo apt upgrade 3. id 리눅스는 권한을 기반으로 파일을 읽고 쓸 수 있기 때문에 주로 자신이 해당하는 권한을 가지고 있는지 확인하기 위해서 사용하는 명령어입니다.\n1 id 디렉토리 탐색 4. pwd Print Working Directory의 줄임말로 현재 작업 중인 디렉토리의 경로를 출력합니다.\n1 2 user@user-VirtualBox:~$ pwd /home/user 5. ls List의 줄임말로 디렉토리의 내용을 출력하는 명령어입니다.\n기본 사용법:\n1 2 ls # 현재 디렉토리 내용 ls /home # 특정 디렉토리 내용 유용한 옵션:\n1 2 3 4 5 6 ls -l # 상세 정보 포함 ls -a # 숨김 파일 포함 ls -lh # 사람이 읽기 쉬운 파일 크기 ls -lt # 수정 시간순 정렬 ls -lS # 파일 크기순 정렬 ls -lR # 하위 디렉토리까지 재귀적으로 표시 6. cd Change Directory의 줄임말로 작업 중인 디렉토리를 변경하는 명령어입니다.\n구분 기호/명령어 설명 예시 절대 경로 / 시작 루트 디렉토리(/)를 시작으로 모든 경로를 전부 적어서 표현하는 방식 cd /home/user 상대 경로 .. 등 현재 디렉토리를 기준으로 상위 또는 하위 디렉토리로 뻗어 나가는 방식 cd .. (현재 위치에서 부모 디렉토리로 이동) 홈 디렉토리 ~ 현재 로그인한 유저의 홈 디렉토리 cd ~ 또는 cd (내 홈 폴더로 이동) 이전 경로 - 직전에 위치했던 디렉토리 (바로 전 경로) cd - (이전 작업 위치로 복귀) 현재 디렉토리 . 현재 디렉토리 cd . (변화 없음, 주로 상대 경로에 활용) 파일 및 디렉토리 생성 7. mkdir Make Directory의 줄임말로 디렉토리를 생성하는 명령어입니다.\n1 2 3 mkdir new_dir # 단일 디렉토리 생성 mkdir dir1 dir2 dir3 # 여러 디렉토리 동시 생성 mkdir -p parent/child/grandchild # 상위 디렉토리까지 자동 생성 /home/user 디렉토리에 위치할 때 mkdir new_dir 명령어로 new_dir 디렉토리를 생성하면, new_dir가 새롭게 추가됩니다.\n8. touch 비어있는 새로운 파일을 만드는 데 사용합니다. 파일이 이미 존재하는 경우 수정 시간을 현재 시간으로 업데이트합니다.\n1 2 3 4 user@user-VirtualBox:~/new_dir$ ls -l user@user-VirtualBox:~/new_dir$ touch new_file user@user-VirtualBox:~/new_dir$ ls -l -rw-rw-r-- 1 user user 0 12월 2 13:05 new_file 여러 파일 동시 생성:\n1 touch file1.txt file2.txt file3.txt 파일 및 디렉토리 조작 9. mv Move의 줄임말로 파일이나 디렉토리의 위치를 옮기거나 이름을 변경할 때 사용하는 명령어입니다.\n이름 변경:\n1 mv old_name new_name 파일 이동:\n1 2 3 4 5 6 7 8 9 10 user@user-VirtualBox:~/new_dir$ ls old_file user@user-VirtualBox:~/new_dir$ ls .. Desktop Downloads new_dir Public Templates Documents Music Pictures snap Videos user@user-VirtualBox:~/new_dir$ mv old_file .. user@user-VirtualBox:~/new_dir$ ls user@user-VirtualBox:~/new_dir$ ls .. Desktop Downloads new_dir Pictures snap Videos Documents Music old_file Public Templates 여러 파일을 디렉토리로 이동:\n1 mv file1.txt file2.txt file3.txt /destination/ 10. cp Copy의 줄임말로 파일이나 디렉토리를 복사하는 명령어입니다.\n파일 복사:\n1 2 3 4 5 6 7 8 9 10 user@user-VirtualBox:~/new_dir$ ls -l total 4 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello user@user-VirtualBox:~/new_dir$ cp hello world user@user-VirtualBox:~/new_dir$ ls -l total 8 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello -rw-rw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ cat world Hello world! 디렉토리 복사:\n1 2 cp -r source_dir destination_dir # 디렉토리 전체 복사 cp -r dir1/ dir2/ # dir1의 내용을 dir2로 복사 유용한 옵션:\n1 2 3 cp -i file1 file2 # 덮어쓰기 전 확인 cp -v file1 file2 # 복사 과정 표시 cp -u file1 file2 # 더 최신 파일만 복사 11. rm Remove의 줄임말로 파일이나 디렉토리를 삭제하는 명령어입니다.\n파일 삭제:\n1 rm file.txt 디렉토리 삭제:\n1 rm -r directory_name # 디렉토리와 내용물 전체 삭제 유용한 옵션:\n1 2 3 rm -i file.txt # 삭제 전 확인 rm -f file.txt # 강제 삭제 (확인 없이) rm -rf directory/ # 디렉토리 강제 삭제 (주의!) 파일 내용 보기 12. cat 파일의 내용을 출력하는 명령어입니다. cat 파일경로 형식으로 사용할 수 있습니다.\n1 2 3 4 5 6 7 user@user-VirtualBox:~/new_dir$ cat /etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin ... (생략) user:x:1000:1000:user,,,:/home/user:/bin/bash 여러 파일 연결:\n1 cat file1.txt file2.txt \u0026gt; combined.txt 13. head / tail 파일의 처음 또는 끝 부분만 출력합니다.\n1 2 3 4 5 head file.txt # 처음 10줄 head -n 20 file.txt # 처음 20줄 tail file.txt # 마지막 10줄 tail -n 50 file.txt # 마지막 50줄 tail -f log.txt # 실시간 로그 모니터링 (매우 유용!) 14. less / more 파일 내용을 페이지 단위로 보여줍니다.\n1 2 less large_file.txt # 위아래 스크롤 가능, 검색 가능 (추천) more large_file.txt # 한 방향으로만 스크롤 less 명령어 내부에서:\nSpace: 다음 페이지 b: 이전 페이지 /word: 단어 검색 q: 종료 15. file 파일의 유형을 출력하는 명령어입니다.\n1 2 user@user-VirtualBox:~$ file /bin/ls /bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=897f49cafa98c11d63e619e7e40352f855249c13, for GNU/Linux 3.2.0, stripped 다양한 파일 타입 확인:\n1 2 3 file document.pdf # PDF document file image.jpg # JPEG image data file script.sh # Bourne-Again shell script 텍스트 출력 및 생성 16. echo 셸에 유저가 입력한 텍스트를 출력합니다.\n1 2 user@user-VirtualBox:~/new_dir$ echo \u0026#34;Hello world!\u0026#34; Hello world! 파일로 리다이렉션:\n1 2 3 4 5 6 7 8 user@user-VirtualBox:~/new_dir$ ls -l total 0 user@user-VirtualBox:~/new_dir$ echo \u0026#34;Hello world!\u0026#34; \u0026gt; hello user@user-VirtualBox:~/new_dir$ ls -l total 4 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello user@user-VirtualBox:~/new_dir$ cat hello Hello world! 파일에 추가:\n1 echo \u0026#34;Another line\u0026#34; \u0026gt;\u0026gt; hello 변수 출력:\n1 2 3 echo $HOME # 홈 디렉토리 경로 echo $PATH # PATH 환경 변수 echo $USER # 현재 사용자 이름 검색 및 필터링 17. grep 전체에서 특정 문자열을 찾을 때 사용합니다. grep 문자열 파일 형식으로 사용할 수 있습니다.\n기본 사용:\n1 2 3 user@user-VirtualBox:~/new_dir$ grep root /etc/passwd root:x:0:0:root:/root:/bin/bash nm-openvpn:x:121:127:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin 유용한 옵션:\n1 2 3 4 5 6 7 grep -i \u0026#34;error\u0026#34; log.txt # 대소문자 구분 없이 검색 grep -r \u0026#34;TODO\u0026#34; . # 현재 디렉토리에서 재귀 검색 grep -n \u0026#34;function\u0026#34; script.py # 줄 번호 포함 grep -v \u0026#34;comment\u0026#34; file.txt # 패턴과 일치하지 않는 줄 grep -c \u0026#34;error\u0026#34; log.txt # 일치하는 줄 개수만 출력 grep -A 3 \u0026#34;error\u0026#34; log.txt # 일치 줄 + 다음 3줄 grep -B 2 \u0026#34;error\u0026#34; log.txt # 일치 줄 + 이전 2줄 18. find 파일과 디렉토리를 검색하는 강력한 명령어입니다.\n1 2 3 4 5 6 7 find /home -name \u0026#34;*.txt\u0026#34; # 이름으로 검색 find . -type f -name \u0026#34;test*\u0026#34; # 파일만 검색 find . -type d -name \u0026#34;backup\u0026#34; # 디렉토리만 검색 find . -mtime -7 # 최근 7일 수정된 파일 find . -size +100M # 100MB 이상 파일 find . -name \u0026#34;*.log\u0026#34; -delete # 찾은 파일 삭제 find . -name \u0026#34;*.sh\u0026#34; -exec chmod +x {} \\; # 찾은 파일에 명령 실행 19. which / whereis 명령어나 프로그램의 위치를 찾습니다.\n1 2 3 which python # python 명령어의 실행 파일 위치 which gcc # gcc 컴파일러 위치 whereis ls # ls 명령어의 바이너리, 소스, 매뉴얼 위치 프로세스 관리 20. ps 현재 실행 중인 프로세스를 확인합니다.\n1 2 3 4 ps # 현재 터미널의 프로세스 ps aux # 모든 프로세스 상세 정보 ps aux | grep nginx # 특정 프로세스 찾기 ps -ef # 전체 프로세스 (다른 포맷) 21. top / htop 실시간으로 시스템 리소스와 프로세스를 모니터링합니다.\n1 2 top # 기본 모니터링 htop # 향상된 인터페이스 (설치 필요: sudo apt install htop) top 내부 명령:\nq: 종료 k: 프로세스 종료 M: 메모리 사용량 정렬 P: CPU 사용량 정렬 22. kill 프로세스를 종료합니다.\n1 2 3 kill 1234 # PID 1234 프로세스 종료 kill -9 1234 # 강제 종료 killall nginx # 이름으로 모든 nginx 프로세스 종료 도움말 23. man Manual의 줄임말로 특정 명령어의 매뉴얼을 보여주는 명령어입니다.\n1 2 3 man ls # ls 명령어 매뉴얼 man grep # grep 명령어 매뉴얼 man 5 passwd # /etc/passwd 파일 형식 매뉴얼 man 페이지 탐색:\nSpace: 다음 페이지 b: 이전 페이지 /word: 검색 q: 종료 24. help / \u0026ndash;help 간단한 도움말을 출력합니다.\n1 2 3 ls --help cp --help help cd # 내장 명령어 네트워크 25. curl client URL의 줄임말로 서버에 데이터를 보내거나 서버로부터 받는 데이터 전송 명령어입니다. HTTP, HTTPS, FTP 등 다양한 프로토콜을 지원합니다.\n기본 사용:\n1 curl https://example.com # 웹 페이지 내용 가져오기 주요 옵션:\n1 2 3 4 curl -o file.html https://example.com # 파일로 저장 curl -O https://example.com/file.zip # 원본 이름으로 저장 curl -i https://example.com # 응답 헤더 포함 curl -L https://example.com # 리다이렉트 따라가기 HTTP 메소드:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # GET 요청 (기본) curl https://api.example.com/users # POST 요청 curl -X POST https://api.example.com/data \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;,\u0026#34;age\u0026#34;:30}\u0026#39; # PUT 요청 curl -X PUT https://api.example.com/users/1 \\ -d \u0026#34;name=Jane\u0026#34; # DELETE 요청 curl -X DELETE https://api.example.com/users/1 워게임에서의 활용:\n1 2 3 4 5 # 명령어 실행 결과를 서버로 전송 curl \u0026#34;http://myserver.com\u0026#34; -d \u0026#34;`cat /flag`\u0026#34; # 파일 내용 전송 curl -X POST http://myserver.com -d \u0026#34;@/etc/passwd\u0026#34; 26. wget 파일을 다운로드하는 명령어입니다.\n1 2 3 4 wget https://example.com/file.zip # 파일 다운로드 wget -O custom_name.zip https://... # 다른 이름으로 저장 wget -c https://example.com/large.iso # 중단된 다운로드 이어받기 wget -r https://example.com # 웹사이트 전체 다운로드 압축 및 아카이브 27. tar 파일을 묶고 압축하는 명령어입니다.\n1 2 3 4 5 tar -cvf archive.tar files/ # 묶기 tar -czvf archive.tar.gz files/ # 묶고 gzip 압축 tar -xvf archive.tar # 풀기 tar -xzvf archive.tar.gz # gzip 압축 해제하며 풀기 tar -tvf archive.tar # 내용 확인 옵션 의미:\nc: create (생성) x: extract (추출) v: verbose (과정 표시) f: file (파일 지정) z: gzip 압축/해제 j: bzip2 압축/해제 28. zip / unzip zip 형식으로 압축합니다.\n1 2 3 4 zip archive.zip file1 file2 # 압축 zip -r archive.zip directory/ # 디렉토리 압축 unzip archive.zip # 압축 해제 unzip -l archive.zip # 내용만 확인 디스크 사용량 29. du 디렉토리와 파일의 디스크 사용량을 확인합니다.\n1 2 3 4 du -h # 사람이 읽기 쉬운 형식 du -sh * # 현재 디렉토리의 각 항목 크기 du -sh /home/user # 특정 디렉토리 전체 크기 du -h --max-depth=1 # 1단계 깊이까지만 30. df 파일 시스템의 디스크 공간 사용량을 확인합니다.\n1 2 df -h # 모든 파일 시스템 df -h /home # 특정 디렉토리가 속한 파일 시스템 고급 기능 와일드카드 **와일드카드(wildcards)**는 리눅스에서 임의의 다른 문자를 나타낐 수 있는 특수 문자들을 의미합니다. 주로 명령어를 다른 문자열로 대체하기 위해 사용합니다.\n기본 와일드카드\n? - 임의의 1개 문자\na-z, 0-9 범위 내 임의의 1개 문자로 대체됩니다. 1 2 ls file?.txt # file1.txt, fileA.txt 등 매칭 ls test? # test1, testa 등 매칭 * - 임의의 0개 이상 문자\na-z, 0-9 범위 내 임의의 0개 이상 문자로 대체됩니다. 1 2 3 ls *.txt # 모든 .txt 파일 ls test* # test로 시작하는 모든 파일 ls *backup* # backup이 포함된 모든 파일 [] - 범위 지정\n[문자1-문자2] 혹은 [문자1, 문자2, …] 형태로 범위를 지정합니다. 1 2 3 ls file[1-3].txt # file1.txt, file2.txt, file3.txt ls [abc]* # a, b, c로 시작하는 파일 ls *.[ch] # .c 또는 .h로 끝나는 파일 실전 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # .txt로 끝나는 모든 파일 삭제 rm *.txt # file1, file2, file3... file9 선택 ls file[1-9] # 이름이 정확히 3글자인 모든 파일 ls ??? # test로 시작하는 모든 파일을 /backup/으로 복사 cp test* /backup/ # 2024년 로그 파일 전체 보기 cat log-2024-*.txt # JPG 또는 PNG 이미지 파일 이동 mv *.{jpg,png} images/ 리다이렉션 **리다이렉션(redirection)**은 모니터에 나타나는 표준 출력 혹은 키보드로 입력하는 표준 입력을 다른 곳으로 변경하는 작업입니다.\n표준 스트림\n표준 입력 (stdin): 0번, 키보드로부터의 입력 표준 출력 (stdout): 1번, 화면으로의 정상 출력 표준 에러 (stderr): 2번, 화면으로의 에러 메시지 출력 리다이렉션\n명령어 \u0026gt; 파일\n명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 덮어씁니다. 1 2 ls -l \u0026gt; file_list.txt # 출력을 파일에 저장 (덮어쓰기) echo \u0026#34;Hello\u0026#34; \u0026gt; greeting.txt 명령어 \u0026gt;\u0026gt; 파일\n명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 이어서 씁니다. 1 2 3 echo \u0026#34;Line 1\u0026#34; \u0026gt; log.txt # 새로 생성 echo \u0026#34;Line 2\u0026#34; \u0026gt;\u0026gt; log.txt # 추가 echo \u0026#34;Line 3\u0026#34; \u0026gt;\u0026gt; log.txt # 추가 명령어 2\u0026gt; 파일\n에러 메시지만 파일로 저장합니다. 1 2 3 4 command 2\u0026gt; error.log # 에러만 파일에 저장 command \u0026gt; output.txt 2\u0026gt; error.log # 출력과 에러 분리 command \u0026gt; output.txt 2\u0026gt;\u0026amp;1 # 출력과 에러를 같은 파일에 command \u0026amp;\u0026gt; all.log # 출력과 에러를 같은 파일에 (축약형) 입력 리다이렉션\n명령어 \u0026lt; 파일\n명령어 표준 입력을 파일로 변경합니다. 파일로부터 표준 입력을 받아 명령어를 수행합니다. 1 2 sort \u0026lt; unsorted.txt # 파일 내용을 정렬 wc -l \u0026lt; file.txt # 파일 줄 수 세기 Here Document\n1 2 3 4 5 cat \u0026lt;\u0026lt; EOF \u0026gt; file.txt 여러 줄의 텍스트를 입력할 수 있습니다 EOF 파이프 **파이프(pipe)**는 리다이렉션의 한 형태로, 명령어 결과 표준 출력을 다른 명령어의 표준 입력으로 보낼 때 사용합니다. 파이프는 | 문자로 나타냅니다.\n기본 사용\n1 2 3 ls -l | grep \u0026#34;.txt\u0026#34; # ls 출력에서 .txt 검색 cat file.txt | wc -l # 파일 줄 수 세기 ps aux | grep nginx # 프로세스 필터링 실전 파이프 활용\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 가장 많이 사용하는 명령어 top 10 history | awk \u0026#39;{print $2}\u0026#39; | sort | uniq -c | sort -rn | head # 특정 프로세스의 메모리 사용량 확인 ps aux | grep nginx | awk \u0026#39;{print $6}\u0026#39; # 로그에서 에러만 필터링하여 개수 확인 cat app.log | grep ERROR | wc -l # 디렉토리별 용량 확인 후 정렬 du -sh */ | sort -h # 가장 큰 파일 10개 찾기 du -ah | sort -rh | head -10 # 특정 확장자 파일 개수 find . -name \u0026#34;*.py\u0026#34; | wc -l # CPU 사용률 높은 프로세스 상위 5개 ps aux | sort -nrk 3 | head -5 # 특정 포트를 사용하는 프로세스 찾기 netstat -tuln | grep :80 # 중복 제거된 정렬된 목록 cat list.txt | sort | uniq # 로그에서 IP 주소 추출 및 빈도 분석 grep -oE \u0026#39;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#39; access.log | sort | uniq -c | sort -rn 권한 유저(user)와 그룹(group) 리눅스에서 유저와 그룹은 리눅스의 권한 시스템을 설명하기 위해 빠뜨릴 수 없는 개념입니다. 리눅스의 각 유저는 이름과 고유한 사용자 ID(UID)를 가지고 있습니다. 그룹은 말 그대로 여러 유저가 속할 수 있는 그룹으로, 이 역시 그룹 이름과 고유한 그룹 ID(GID)를 가지고 있습니다.\n파일이나 디렉토리와 같은 시스템 자원에 유저가 접근하면 유저의 UID와 해당 유저가 속한 그룹의 GID를 확인하여 정당한 권한을 가지고 있는지를 판단해 접근을 제어합니다.\n유저 정보 확인\n/etc/passwd는 리눅스의 유저 정보를 담고 있는 텍스트 파일입니다. 각 사용자의 이름, 사용자 ID, 속해있는 그룹 ID 등의 정보를 포함하고 있습니다.\n1 cat /etc/passwd 각 줄의 형식: username:x:UID:GID:comment:home_directory:shell\n예시:\nroot:x:0:0:root:/root:/bin/bash\ruser:x:1000:1000:user,,,:/home/user:/bin/bash 그룹 정보 확인\n/etc/group은 리눅스의 그룹 정보를 저장하는 텍스트 파일입니다. 각 그룹의 이름, 그룹 ID, 그룹에 속한 유저 목록 등의 정보를 포함하고 있습니다.\n1 cat /etc/group 유저 관련 명령어\n1 2 3 4 whoami # 현재 사용자 이름 id # 현재 사용자의 UID, GID 정보 groups # 현재 사용자가 속한 그룹들 users # 현재 로그인한 사용자들 파일 및 디렉토리 권한 리눅스는 사용자가 파일과 디렉토리에 접근하는 행위에 대해 권한으로 제어합니다. 각 파일과 디렉토리는 **소유자(owner)**와 **소유 그룹(group)**을 가지고 있습니다. 소유자는 파일 또는 디렉토리의 권한을 수정할 수 있는 능력을 가지고 있습니다.\n세 가지 접근 권한\n읽기(Read, r): 파일 또는 디렉토리의 내용을 볼 수 있게 허용합니다.\n파일: 파일 내용을 읽을 수 있음 디렉토리: 디렉토리 내 파일 목록을 볼 수 있음 쓰기(Write, w): 파일 또는 디렉토리의 내용을 수정하거나 삭제하는 것을 허용합니다.\n파일: 파일 내용을 수정하거나 삭제할 수 있음 디렉토리: 디렉토리 내에 파일을 생성하거나 삭제할 수 있음 실행(Execute, x): 파일이 프로그램인 경우 실행할 수 있게 허용합니다.\n파일: 프로그램으로 실행할 수 있음 디렉토리: 디렉토리에 접근(cd)할 수 있음 권한 확인하기\n파일이나 디렉토리의 권한을 보기 위해 ls -l을 사용합니다.\n1 2 3 4 5 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ---------- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world 권한 플래그 해석 1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir 권한 플래그 drwxrwxr-x는 4개 부분으로 나뉩니다:\nd rwx rwx r-x\r│ └┬┘ └┬┘ └┬┘\r│ │ │ └─→ 기타 사용자 권한 (r-x: 읽기, 실행)\r│ │ └─────→ 그룹 권한 (rwx: 읽기, 쓰기, 실행)\r│ └─────────→ 소유자 권한 (rwx: 읽기, 쓰기, 실행)\r└────────────→ 파일 타입 (d: 디렉토리) 파일 타입 (첫 번째 문자)\nd: 디렉토리 (directory) -: 일반 파일 (regular file) l: 심볼릭 링크 (symbolic link) b: 블록 디바이스 (block device) c: 문자 디바이스 (character device) s: 소켓 (socket) p: 파이프 (pipe) 권한 문자\nr: 읽기 권한 (Read) w: 쓰기 권한 (Write) x: 실행 권한 (Execute) -: 해당 권한 없음 권한의 숫자 표현\n권한은 2진수나 10진수로도 표현할 수 있습니다.\n권한 2진수 10진수 의미 --- 000 0 권한 없음 --x 001 1 실행만 -w- 010 2 쓰기만 -wx 011 3 쓰기, 실행 r-- 100 4 읽기만 r-x 101 5 읽기, 실행 rw- 110 6 읽기, 쓰기 rwx 111 7 모든 권한 예시:\nrwx = 111 = 7 rw- = 110 = 6 r-- = 100 = 4 rwxrw-r-- = 764 소유자와 소유 그룹\n1 2 3 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ↑ ↑ 소유자 소유그룹 세 번째 열: 파일/디렉토리의 소유자 네 번째 열: 파일/디렉토리의 소유 그룹 종합 예시\n1 -rwxrw-r-- 1 user user 13 12월 2 13:08 world 해석:\n파일 타입: - (일반 파일) 소유자 권한: rwx (읽기, 쓰기, 실행 가능) 그룹 권한: rw- (읽기, 쓰기 가능, 실행 불가) 기타 권한: r-- (읽기만 가능) 소유자: user 소유 그룹: user 파일 및 디렉토리 권한 명령어 chmod chmod는 파일 권한을 변경하는 명령어입니다. root 유저 혹은 파일의 소유자만 실행할 수 있습니다.\n형식\n1 chmod 권한 파일명 숫자 모드\n1 2 3 4 5 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ---------- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world hello 파일을 rwxrw-r-- (764) 권한으로 변경:\n소유자: rwx = 7 그룹: rw- = 6 기타: r-- = 4 1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ chmod 764 hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxrw-r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world 기호 모드\n대상:\nu: 소유자 (user) g: 그룹 (group) o: 기타 (others) a: 모두 (all) 연산:\n+: 권한 추가 -: 권한 제거 =: 권한 설정 권한 추가:\n1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ chmod g+x hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxrwxr-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world 권한 제거:\n1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ chmod g-wx hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world 유용한 예시\n1 2 3 4 5 6 7 8 chmod 644 file.txt # rw-r--r-- (일반 파일) chmod 755 script.sh # rwxr-xr-x (실행 파일) chmod 700 private.txt # rwx------ (소유자만 접근) chmod 777 public_dir # rwxrwxrwx (모두 접근, 위험!) chmod -R 755 directory/ # 디렉토리와 내부 파일 전체에 적용 chmod u+x script.sh # 소유자에게 실행 권한 추가 chmod a-w file.txt # 모두에게서 쓰기 권한 제거 chmod o-rwx private # 기타 사용자 모든 권한 제거 chown chown은 파일 소유자 혹은 소유 그룹을 변경하는 명령어입니다. root 유저만 실행할 수 있습니다.\n형식\n1 chown 사용자명[:그룹명] 파일명 소유자 변경\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ sudo chown root hello [sudo] password for user: user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ echo \u0026#34;hello\u0026#34; \u0026gt; hello bash: hello: Permission denied 소유자와 그룹 동시 변경\n1 2 3 sudo chown root:root hello # 소유자와 그룹을 root로 sudo chown user:developers file.txt # 특정 사용자와 그룹으로 sudo chown -R user:user directory/ # 디렉토리 전체에 재귀적으로 적용 chgrp chgrp는 소유 그룹만 변경하는 명령어입니다.\n1 2 sudo chgrp developers file.txt # 그룹만 변경 sudo chgrp -R www-data /var/www/ # 디렉토리 전체에 적용 특수 권한 앞서 배운 r, w, x 권한 외에 특수한 권한 3가지가 있습니다.\nsetuid (Set User ID) 일반 사용자가 파일을 실행하면 파일 소유자 권한으로 실행됩니다.\n예시: /bin/passwd\n1 2 user@user-VirtualBox:/bin$ ls -l passwd -rwsr-xr-x 1 root root 59976 11월 24 21:05 passwd 소유자의 실행 권한에 x 대신 s가 표시됩니다. 이는 일반 사용자가 passwd 명령을 실행하면 root 권한으로 실행되어 자신의 비밀번호를 변경할 수 있게 합니다.\ns: setuid가 설정되고 실행 권한도 있음 S: setuid는 설정되었지만 실행 권한이 없음 (의미 없음) setgid (Set Group ID) 일반 사용자가 파일을 실행하면 파일 소유 그룹 권한으로 실행됩니다.\n소유 그룹의 실행 권한에 x 대신 s가 표시됩니다.\n디렉토리에 setgid를 설정하면 해당 디렉토리 내에서 생성되는 모든 파일이 디렉토리의 그룹을 상속받습니다.\n1 drwxr-sr-x 2 user developers 4096 12월 2 13:38 shared_dir s: setgid가 설정되고 실행 권한도 있음 S: setgid는 설정되었지만 실행 권한이 없음 sticky bit 디렉토리에 sticky bit를 설정하면 파일 및 디렉토리 소유자와 root 사용자 외에는 일반 사용자가 파일을 삭제할 수 없습니다. 주로 공용 디렉토리에 사용합니다.\n예시: /tmp 디렉토리\n1 drwxrwxrwt 20 root root 4096 12월 1 14:17 tmp 일반 사용자의 실행 권한에 x 대신 t가 표시됩니다.\nt: sticky bit가 설정되고 실행 권한도 있음 T: sticky bit는 설정되었지만 실행 권한이 없음 특수 권한 설정 특수 권한은 숫자 형식으로 권한 플래그 맨 앞에 붙여 표현합니다:\nsetuid: 4 setgid: 2 sticky bit: 1 숫자 모드\n1 2 3 4 5 6 7 8 9 10 11 12 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ chmod 4775 world user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwsrwxr-x 1 user user 13 12월 2 13:08 world 기호 모드\n1 2 3 4 chmod u+s file # setuid 설정 chmod g+s directory # setgid 설정 chmod o+t directory # sticky bit 설정 chmod u-s file # setuid 제거 조합 예시\n1 2 3 4 chmod 4755 program # rwsr-xr-x (setuid) chmod 2755 shared_dir # rwxr-sr-x (setgid) chmod 1777 /tmp # rwxrwxrwt (sticky bit) chmod 6755 file # rwsr-sr-x (setuid + setgid) 디렉토리 구조 루트 디렉토리 / 루트 디렉토리는 리눅스의 최상위 디렉토리를 말하며, 절대 경로는 /입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 user@user-VirtualBox:~$ ls -l / total 3991632 lrwxrwxrwx 1 root root 7 11월 30 18:15 bin -\u0026gt; usr/bin drwxr-xr-x 4 root root 4096 12월 1 14:10 boot drwxrwxr-x 2 root root 4096 11월 30 18:25 cdrom drwxr-xr-x 19 root root 4180 12월 1 14:25 dev drwxr-xr-x 130 root root 12288 12월 1 14:09 etc drwxr-xr-x 3 root root 4096 11월 30 18:27 home lrwxrwxrwx 1 root root 7 11월 30 18:15 lib -\u0026gt; usr/lib lrwxrwxrwx 1 root root 9 11월 30 18:15 lib32 -\u0026gt; usr/lib32 lrwxrwxrwx 1 root root 9 11월 30 18:15 lib64 -\u0026gt; usr/lib64 lrwxrwxrwx 1 root root 10 11월 30 18:15 libx32 -\u0026gt; usr/libx32 drwx------ 2 root root 16384 11월 30 18:14 lost+found drwxr-xr-x 3 root root 4096 11월 30 19:49 media drwxr-xr-x 2 root root 4096 8월 9 20:48 mnt drwxr-xr-x 3 root root 4096 11월 30 19:55 opt dr-xr-xr-x 257 root root 0 12월 1 14:11 proc drwx------ 4 root root 4096 12월 1 14:17 root drwxr-xr-x 33 root root 900 12월 1 14:12 run lrwxrwxrwx 1 root root 8 11월 30 18:15 sbin -\u0026gt; usr/sbin drwxr-xr-x 11 root root 4096 8월 9 20:55 snap drwxr-xr-x 2 root root 4096 8월 9 20:48 srv -rw------- 1 root root 4087349248 11월 30 18:15 swapfile dr-xr-xr-x 13 root root 0 12월 1 14:11 sys drwxrwxrwt 20 root root 4096 12월 1 14:17 tmp drwxr-xr-x 14 root root 4096 8월 9 20:48 usr drwxr-xr-x 14 root root 4096 8월 9 20:54 var 주요 디렉토리 설명 /bin - 기본 명령어 일반 유저가 사용할 수 있는 기본적인 명령어나 프로그램을 담고 있는 디렉토리입니다.\n1 ls, cp, mv, rm, cat, echo, mkdir, chmod, ps 등 최신 시스템에서는 /usr/bin으로의 심볼릭 링크입니다.\n/boot - 부팅 파일 시스템 부팅에 필요한 파일들을 담고 있는 디렉토리입니다.\n1 커널 이미지, 부트로더 설정 파일, initramfs 등 /dev - 디바이스 파일 컴퓨터에 부착된 물리적인 장치들을 파일 형태로 접근할 수 있게 합니다.\n1 2 3 4 5 /dev/sda # 첫 번째 하드 디스크 /dev/sda1 # 첫 번째 하드 디스크의 첫 번째 파티션 /dev/null # 널 디바이스 (출력 버리기에 사용) /dev/zero # 0을 무한히 생성 /dev/random # 난수 생성기 /etc - 설정 파일 운영체제나 운영체제 위에서 동작하는 서비스의 설정 파일들을 담고 있는 디렉토리입니다.\n1 2 3 4 5 6 7 /etc/passwd # 사용자 정보 /etc/group # 그룹 정보 /etc/hosts # 호스트 이름 매핑 /etc/hostname # 시스템 호스트명 /etc/ssh/ # SSH 서버 설정 /etc/nginx/ # Nginx 웹서버 설정 /etc/apache2/ # Apache 웹서버 설정 /home - 사용자 홈 디렉토리 각 일반 유저의 홈 디렉토리를 담고 있는 디렉토리입니다.\n1 2 /home/user # user 사용자의 홈 디렉토리 /home/dream # dream 사용자의 홈 디렉토리 각 사용자는 자신의 홈 디렉토리에서 완전한 권한을 가집니다.\n/lib, /lib32, /lib64 - 라이브러리 시스템에 필요한 라이브러리 파일들을 담고 있는 디렉토리입니다.\n1 공유 라이브러리, 커널 모듈 등 /bin이나 /sbin의 프로그램이 필요로 하는 동적 라이브러리 파일이 존재합니다.\n/media - 이동식 미디어 이동식 미디어(USB, CD/DVD 등)가 자동으로 마운트되는 디렉토리입니다.\n1 2 /media/user/USB_DRIVE /media/user/CDROM /mnt - 임시 마운트 파일 시스템을 임시로 마운트하는 데 사용하는 디렉토리입니다.\n1 sudo mount /dev/sdb1 /mnt /opt - 선택적 소프트웨어 추가로 설치한 소프트웨어 패키지들을 담는 디렉토리입니다.\n1 2 /opt/google/chrome /opt/teamviewer /proc - 프로세스 정보 리눅스 커널 자원에 접근할 수 있는 가상 파일 시스템입니다. 프로세스와 시스템 정보를 파일 형태로 제공합니다.\n1 2 3 4 /proc/cpuinfo # CPU 정보 /proc/meminfo # 메모리 정보 /proc/[PID]/ # 각 프로세스 정보 /proc/version # 커널 버전 /root - root 사용자 홈 root 유저의 홈 디렉토리입니다. /home/root가 아님에 주의하세요.\n/run - 런타임 데이터 시스템이 부팅된 이후 런타임 데이터를 저장합니다.\n1 PID 파일, 소켓 파일 등 /sbin - 시스템 관리 명령어 /bin 디렉토리와 유사하지만, root 유저가 사용하는 시스템 관리 명령어를 포함합니다.\n1 fdisk, mkfs, shutdown, reboot, iptables 등 /srv - 서비스 데이터 시스템에서 제공하는 서비스의 데이터를 저장하는 디렉토리입니다.\n1 2 /srv/www # 웹 서버 데이터 /srv/ftp # FTP 서버 데이터 /sys - 시스템 정보 커널과 하드웨어 정보를 제공하는 가상 파일 시스템입니다.\n/tmp - 임시 파일 유저나 프로그램이 임시로 파일을 생성할 때 사용하는 디렉토리입니다.\n주의: 시스템 재부팅 시 또는 일정 시간이 지나면 파일이 자동으로 삭제될 수 있습니다.\n1 drwxrwxrwt # sticky bit로 보호됨 /usr - 사용자 프로그램 사용자 바이너리, 문서, 라이브러리, 헤더 파일 등을 담고 있는 디렉토리입니다.\n1 2 3 4 5 6 /usr/bin/ # 사용자 명령어 /usr/sbin/ # 시스템 관리 명령어 /usr/lib/ # 라이브러리 /usr/local/ # 로컬에 설치한 프로그램 /usr/share/ # 아키텍처 독립적인 데이터 /usr/include/ # C 헤더 파일 /var - 가변 데이터 프로그램이나 시스템이 실시간으로 가변적인 파일을 사용하고 저장할 때 활용하는 디렉토리입니다.\n1 2 3 4 5 6 /var/log/ # 각종 로그 파일 /var/www/ # 웹 서버 루트 (보통) /var/mail/ # 메일 스풀 /var/spool/ # 대기열 데이터 (프린터, cron 등) /var/tmp/ # 재부팅 후에도 유지되는 임시 파일 /var/cache/ # 애플리케이션 캐시 ⚠️ 주의사항 및 안전 사용 팁 위험한 명령어들 절대 실행하지 마세요!\n1 2 3 4 5 6 rm -rf / # 시스템 전체 삭제 (현대 시스템은 보호됨) rm -rf /* # 루트 디렉토리의 모든 내용 삭제 chmod 777 -R / # 모든 파일 권한 열기 (심각한 보안 위험) dd if=/dev/zero of=/dev/sda # 디스크 전체 초기화 mkfs.ext4 /dev/sda # 파티션 포맷 (데이터 삭제) :(){ :|:\u0026amp; };: # Fork bomb (시스템 멈춤) 안전한 사용 습관 1. 삭제 전 항상 확인\n1 2 ls -l file* # 먼저 어떤 파일이 매칭되는지 확인 rm -i file* # 삭제 전 각 파일마다 확인 2. 중요한 작업 전 백업\n1 2 cp important.txt important.txt.backup tar -czf backup_$(date +%Y%m%d).tar.gz /important/directory/ 3. sudo 사용 시 신중하게\n1 2 3 4 5 6 # 나쁜 예 sudo rm -rf /tmp ../file # 경로 실수 시 위험 # 좋은 예 ls -l /tmp ../file # 먼저 확인 sudo rm -rf /tmp ../file # 확인 후 실행 4. 와일드카드 사용 시 주의\n1 2 3 4 5 6 # 나쁜 예 rm * .txt # 모든 파일 삭제 후 .txt 삭제 시도 # 좋은 예 rm *.txt # .txt 파일만 삭제 ls *.txt # 먼저 무엇이 삭제될지 확인 5. 절대 경로 vs 상대 경로\n1 2 3 4 5 6 # 현재 위치를 항상 확인 pwd # 중요한 작업은 절대 경로 사용 rm -rf /home/user/old_project # 명확함 # rm -rf ../../../old_project # 위험할 수 있음 유용한 팁과 트릭 명령어 히스토리 1 2 3 4 5 history # 명령어 이력 보기 !100 # 100번째 명령어 실행 !! # 마지막 명령어 실행 !grep # grep으로 시작하는 마지막 명령어 실행 Ctrl + R # 명령어 이력 검색 (interactive) 단축키 터미널 조작\nCtrl + C # 현재 실행 중인 프로세스 중단\rCtrl + Z # 현재 프로세스 일시 중지\rCtrl + D # 로그아웃 / EOF 전송\rCtrl + L # 화면 지우기 (clear 명령어와 동일) 커서 이동\nCtrl + A # 줄의 시작으로\rCtrl + E # 줄의 끝으로\rCtrl + U # 커서부터 앞쪽 전체 삭제\rCtrl + K # 커서부터 뒷쪽 전체 삭제\rCtrl + W # 커서 앞의 단어 삭제 Tab 자동완성\nTab # 파일명/명령어 자동완성\rTab Tab # 가능한 모든 옵션 표시 별칭(Alias) 설정 자주 사용하는 명령어를 짧게 만들 수 있습니다.\n1 2 3 4 5 6 7 8 9 # 임시 별칭 (현재 세션만) alias ll=\u0026#39;ls -alh\u0026#39; alias ..=\u0026#39;cd ..\u0026#39; alias ...=\u0026#39;cd ../..\u0026#39; alias grep=\u0026#39;grep --color=auto\u0026#39; # 영구 별칭 (~/.bashrc 또는 ~/.zshrc에 추가) echo \u0026#34;alias ll=\u0026#39;ls -alh\u0026#39;\u0026#34; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc 환경 변수 1 2 3 4 5 6 7 8 9 10 11 echo $PATH # PATH 환경 변수 확인 echo $HOME # 홈 디렉토리 echo $USER # 현재 사용자 echo $SHELL # 현재 셸 # 환경 변수 설정 export MY_VAR=\u0026#34;value\u0026#34; echo $MY_VAR # 영구 설정 (~/.bashrc에 추가) echo \u0026#39;export PATH=$PATH:/my/custom/path\u0026#39; \u0026gt;\u0026gt; ~/.bashrc 작업 관리 1 2 3 4 5 command \u0026amp; # 백그라운드에서 실행 jobs # 백그라운드 작업 목록 fg %1 # 1번 작업을 포그라운드로 bg %1 # 1번 작업을 백그라운드로 nohup command \u0026amp; # 로그아웃 후에도 계속 실행 파일 찾기 고급 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 최근 수정된 파일 찾기 find . -mtime -7 # 7일 이내 find . -mmin -60 # 60분 이내 # 파일 크기로 찾기 find . -size +100M # 100MB 이상 find . -size -1k # 1KB 이하 # 찾은 파일에 명령 실행 find . -name \u0026#34;*.log\u0026#34; -exec rm {} \\; find . -type f -name \u0026#34;*.txt\u0026#34; -exec grep \u0026#34;error\u0026#34; {} + # 여러 조건 조합 find . -type f -name \u0026#34;*.py\u0026#34; -size +1M -mtime -30 텍스트 처리 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 줄 번호 표시 cat -n file.txt nl file.txt # 중복 제거 sort file.txt | uniq sort -u file.txt # 컬럼 추출 awk \u0026#39;{print $1}\u0026#39; file.txt # 첫 번째 컬럼 cut -d\u0026#39;:\u0026#39; -f1 /etc/passwd # : 구분자로 첫 번째 필드 # 문자열 치환 sed \u0026#39;s/old/new/\u0026#39; file.txt # 첫 번째 매치만 sed \u0026#39;s/old/new/g\u0026#39; file.txt # 모든 매치 sed -i \u0026#39;s/old/new/g\u0026#39; file.txt # 파일 직접 수정 시스템 모니터링 1 2 3 4 5 6 7 8 9 10 11 12 # 디스크 I/O iostat iotop # 실시간 I/O 모니터링 # 네트워크 netstat -tuln # 리스닝 포트 ss -tuln # 현대적인 대체 lsof -i :80 # 특정 포트 사용 프로세스 # 메모리 free -h # 메모리 사용량 vmstat # 가상 메모리 통계 실전 시나리오 시나리오 1: 디스크 공간 확보 상황: 디스크 공간이 부족합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 1. 디스크 사용량 확인 df -h # 2. 큰 파일/디렉토리 찾기 du -sh /* | sort -h # 3. 특정 디렉토리 상세 분석 du -h --max-depth=1 /home | sort -h # 4. 100MB 이상 파일 찾기 find / -type f -size +100M 2\u0026gt;/dev/null # 5. 오래된 로그 파일 정리 find /var/log -name \u0026#34;*.log\u0026#34; -mtime +30 -delete # 6. 임시 파일 정리 sudo apt clean # 패키지 캐시 rm -rf ~/.cache/* # 사용자 캐시 시나리오 2: 시스템 느림 진단 상황: 시스템이 갑자기 느려졌습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 1. CPU 사용률 확인 top # 또는 htop # 2. CPU 사용 상위 프로세스 ps aux --sort=-%cpu | head # 3. 메모리 사용 상위 프로세스 ps aux --sort=-%mem | head # 4. 디스크 I/O 확인 iostat -x 1 # 5. 특정 프로세스 종료 kill -9 [PID] 시나리오 3: 로그 분석 상황: 웹 서버에 문제가 있어 로그를 분석해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1. 최근 에러 확인 tail -f /var/log/nginx/error.log # 2. 특정 시간대 로그 grep \u0026#34;2026-01-12 14:\u0026#34; /var/log/nginx/access.log # 3. 404 에러 개수 grep \u0026#34;404\u0026#34; /var/log/nginx/access.log | wc -l # 4. IP별 요청 횟수 awk \u0026#39;{print $1}\u0026#39; /var/log/nginx/access.log | sort | uniq -c | sort -rn # 5. 가장 많이 요청된 URL awk \u0026#39;{print $7}\u0026#39; /var/log/nginx/access.log | sort | uniq -c | sort -rn | head # 6. 에러 로그를 파일로 저장 grep \u0026#34;error\u0026#34; /var/log/nginx/error.log \u0026gt; errors_$(date +%Y%m%d).log 시나리오 4: 백업 및 복원 상황: 프로젝트 파일을 백업하고 싶습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1. 압축 백업 생성 tar -czf backup_$(date +%Y%m%d_%H%M%S).tar.gz /path/to/project # 2. 원격 서버로 전송 scp backup_*.tar.gz user@remote:/backup/ # 3. 백업에서 복원 tar -xzf backup_20260112_143000.tar.gz # 4. 특정 파일만 추출 tar -xzf backup.tar.gz path/to/specific/file # 5. 증분 백업 (rsync 사용) rsync -avz --delete /source/ /backup/ # 6. 원격 동기화 rsync -avz -e ssh /local/path/ user@remote:/remote/path/ 시나리오 5: 권한 문제 해결 상황: 웹 서버가 특정 파일에 접근하지 못합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 1. 파일 권한 확인 ls -l /var/www/html/ # 2. 소유자 확인 stat /var/www/html/index.html # 3. 웹 서버 사용자 확인 (nginx 예시) ps aux | grep nginx # 4. 소유자 변경 sudo chown -R www-data:www-data /var/www/html/ # 5. 권한 설정 sudo find /var/www/html -type d -exec chmod 755 {} \\; sudo find /var/www/html -type f -exec chmod 644 {} \\; # 6. 특수 권한이 필요한 경우 sudo chmod u+s /usr/bin/special_program 실전 문제 풀이 1 2 3 4 5 ls # 현재 디렉토리 파일 확인 cat hint.txt # 힌트 파일 읽기 cat /dream/hack/hello/flag.txt # 힌트에 나온 경로의 플래그 읽기 cat app.py # 추가 파일 확인 cat ./dream/hack/hello/f*ag.txt # 와일드카드로 플래그 파일 읽기 Details 플래그: DH{671ce26c70829e716fae26c7c71a33823feb479f2562891f64605bf68f60ae54}\n","permalink":"http://localhost:1313/posts/2026-01-08/","summary":"리눅스 사용법 정리글 - 개선판","title":"리눅스 사용법 완벽 가이드"},{"content":"1. 개요 (Intro) 안녕하세요, AlwaysHyeon의 보안 블로그입니다. 이 글은 GitHub Pages와 Hugo PaperMod 테마가 정상적으로 연동되었는지 확인하기 위한 테스트 포스트입니다.\n테스트 환경 Generator: Hugo Theme: PaperMod Hosting: GitHub Pages 2. 기능 테스트 (Feature Test) 2.1. 코드 하이라이팅 (Code Block) Python 코드가 예쁘게 나오는지 확인합니다.\n1 2 3 4 5 6 7 8 import os def check_security(): print(\u0026#34;System Secure... maybe?\u0026#34;) return True if __name__ == \u0026#34;__main__\u0026#34;: check_security() ","permalink":"http://localhost:1313/posts/test-post/","summary":"Hugo PaperMod 테마 적용 테스트 글입니다. 마크다운 문법과 코드 하이라이팅이 잘 적용되는지 확인합니다.","title":"블로그 테스트 및 첫 번째 글 (Hello World)"},{"content":"셸(Shell) 셸은 유저가 리눅스 시스템을 이용할 수 있는 인터페이스입니다. 사용자와 커널 사이에서 명령어를 해석하고 실행하는 중요한 역할을 합니다.\n터미널 실행 단축키 Windows/Linux: Ctrl + Alt + T macOS: Control + Option + T 또는 Command + Space로 Spotlight 실행 후 \u0026ldquo;Terminal\u0026rdquo; 입력 셸 프롬프트(Shell Prompt) 셸이 입력을 받을 준비가 되었을 때 다음과 같은 프롬프트가 표시됩니다:\n1 user@user-VirtualBox:~$ 프롬프트 구조:\nuser: 현재 로그인한 사용자 이름 user-VirtualBox: 호스트(컴퓨터) 이름 ~: 현재 위치한 디렉토리 (~는 홈 디렉토리를 의미) $: 일반 사용자 (#는 root 사용자를 의미) id 명령어 현재 유저의 사용자 ID(UID)와 해당 유저가 속해 있는 그룹 ID(GID)를 확인합니다.\n1 2 3 user@user-VirtualBox:~$ id uid=1000(user) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),134(lxd),135(sambashare) user@user-VirtualBox:~$ 기본 명령어 시스템 정보 및 관리 1. sudo apt update apt 명령어로 설치 가능한 소프트웨어 패키지 목록을 업데이트합니다. 각 소프트웨어별로 설치 가능한 버전 정보도 함께 업데이트합니다.\n1 sudo apt update 2. sudo apt upgrade 리눅스에 설치된 소프트웨어 패키지의 버전을 업그레이드합니다.\n1 sudo apt upgrade 3. id 리눅스는 권한을 기반으로 파일을 읽고 쓸 수 있기 때문에 주로 자신이 해당하는 권한을 가지고 있는지 확인하기 위해서 사용하는 명령어입니다.\n1 id 디렉토리 탐색 4. pwd Print Working Directory의 줄임말로 현재 작업 중인 디렉토리의 경로를 출력합니다.\n1 2 user@user-VirtualBox:~$ pwd /home/user 5. ls List의 줄임말로 디렉토리의 내용을 출력하는 명령어입니다.\n기본 사용법:\n1 2 ls # 현재 디렉토리 내용 ls /home # 특정 디렉토리 내용 유용한 옵션:\n1 2 3 4 5 6 ls -l # 상세 정보 포함 ls -a # 숨김 파일 포함 ls -lh # 사람이 읽기 쉬운 파일 크기 ls -lt # 수정 시간순 정렬 ls -lS # 파일 크기순 정렬 ls -lR # 하위 디렉토리까지 재귀적으로 표시 6. cd Change Directory의 줄임말로 작업 중인 디렉토리를 변경하는 명령어입니다.\n구분 기호/명령어 설명 예시 절대 경로 / 시작 루트 디렉토리(/)를 시작으로 모든 경로를 전부 적어서 표현하는 방식 cd /home/user 상대 경로 .. 등 현재 디렉토리를 기준으로 상위 또는 하위 디렉토리로 뻗어 나가는 방식 cd .. (현재 위치에서 부모 디렉토리로 이동) 홈 디렉토리 ~ 현재 로그인한 유저의 홈 디렉토리 cd ~ 또는 cd (내 홈 폴더로 이동) 이전 경로 - 직전에 위치했던 디렉토리 (바로 전 경로) cd - (이전 작업 위치로 복귀) 현재 디렉토리 . 현재 디렉토리 cd . (변화 없음, 주로 상대 경로에 활용) 파일 및 디렉토리 생성 7. mkdir Make Directory의 줄임말로 디렉토리를 생성하는 명령어입니다.\n1 2 3 mkdir new_dir # 단일 디렉토리 생성 mkdir dir1 dir2 dir3 # 여러 디렉토리 동시 생성 mkdir -p parent/child/grandchild # 상위 디렉토리까지 자동 생성 /home/user 디렉토리에 위치할 때 mkdir new_dir 명령어로 new_dir 디렉토리를 생성하면, new_dir가 새롭게 추가됩니다.\n8. touch 비어있는 새로운 파일을 만드는 데 사용합니다. 파일이 이미 존재하는 경우 수정 시간을 현재 시간으로 업데이트합니다.\n1 2 3 4 user@user-VirtualBox:~/new_dir$ ls -l user@user-VirtualBox:~/new_dir$ touch new_file user@user-VirtualBox:~/new_dir$ ls -l -rw-rw-r-- 1 user user 0 12월 2 13:05 new_file 여러 파일 동시 생성:\n1 touch file1.txt file2.txt file3.txt 파일 및 디렉토리 조작 9. mv Move의 줄임말로 파일이나 디렉토리의 위치를 옮기거나 이름을 변경할 때 사용하는 명령어입니다.\n이름 변경:\n1 mv old_name new_name 파일 이동:\n1 2 3 4 5 6 7 8 9 10 user@user-VirtualBox:~/new_dir$ ls old_file user@user-VirtualBox:~/new_dir$ ls .. Desktop Downloads new_dir Public Templates Documents Music Pictures snap Videos user@user-VirtualBox:~/new_dir$ mv old_file .. user@user-VirtualBox:~/new_dir$ ls user@user-VirtualBox:~/new_dir$ ls .. Desktop Downloads new_dir Pictures snap Videos Documents Music old_file Public Templates 여러 파일을 디렉토리로 이동:\n1 mv file1.txt file2.txt file3.txt /destination/ 10. cp Copy의 줄임말로 파일이나 디렉토리를 복사하는 명령어입니다.\n파일 복사:\n1 2 3 4 5 6 7 8 9 10 user@user-VirtualBox:~/new_dir$ ls -l total 4 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello user@user-VirtualBox:~/new_dir$ cp hello world user@user-VirtualBox:~/new_dir$ ls -l total 8 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello -rw-rw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ cat world Hello world! 디렉토리 복사:\n1 2 cp -r source_dir destination_dir # 디렉토리 전체 복사 cp -r dir1/ dir2/ # dir1의 내용을 dir2로 복사 유용한 옵션:\n1 2 3 cp -i file1 file2 # 덮어쓰기 전 확인 cp -v file1 file2 # 복사 과정 표시 cp -u file1 file2 # 더 최신 파일만 복사 11. rm Remove의 줄임말로 파일이나 디렉토리를 삭제하는 명령어입니다.\n파일 삭제:\n1 rm file.txt 디렉토리 삭제:\n1 rm -r directory_name # 디렉토리와 내용물 전체 삭제 유용한 옵션:\n1 2 3 rm -i file.txt # 삭제 전 확인 rm -f file.txt # 강제 삭제 (확인 없이) rm -rf directory/ # 디렉토리 강제 삭제 (주의!) 파일 내용 보기 12. cat 파일의 내용을 출력하는 명령어입니다. cat 파일경로 형식으로 사용할 수 있습니다.\n1 2 3 4 5 6 7 user@user-VirtualBox:~/new_dir$ cat /etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin ... (생략) user:x:1000:1000:user,,,:/home/user:/bin/bash 여러 파일 연결:\n1 cat file1.txt file2.txt \u0026gt; combined.txt 13. head / tail 파일의 처음 또는 끝 부분만 출력합니다.\n1 2 3 4 5 head file.txt # 처음 10줄 head -n 20 file.txt # 처음 20줄 tail file.txt # 마지막 10줄 tail -n 50 file.txt # 마지막 50줄 tail -f log.txt # 실시간 로그 모니터링 (매우 유용!) 14. less / more 파일 내용을 페이지 단위로 보여줍니다.\n1 2 less large_file.txt # 위아래 스크롤 가능, 검색 가능 (추천) more large_file.txt # 한 방향으로만 스크롤 less 명령어 내부에서:\nSpace: 다음 페이지 b: 이전 페이지 /word: 단어 검색 q: 종료 15. file 파일의 유형을 출력하는 명령어입니다.\n1 2 user@user-VirtualBox:~$ file /bin/ls /bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=897f49cafa98c11d63e619e7e40352f855249c13, for GNU/Linux 3.2.0, stripped 다양한 파일 타입 확인:\n1 2 3 file document.pdf # PDF document file image.jpg # JPEG image data file script.sh # Bourne-Again shell script 텍스트 출력 및 생성 16. echo 셸에 유저가 입력한 텍스트를 출력합니다.\n1 2 user@user-VirtualBox:~/new_dir$ echo \u0026#34;Hello world!\u0026#34; Hello world! 파일로 리다이렉션:\n1 2 3 4 5 6 7 8 user@user-VirtualBox:~/new_dir$ ls -l total 0 user@user-VirtualBox:~/new_dir$ echo \u0026#34;Hello world!\u0026#34; \u0026gt; hello user@user-VirtualBox:~/new_dir$ ls -l total 4 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello user@user-VirtualBox:~/new_dir$ cat hello Hello world! 파일에 추가:\n1 echo \u0026#34;Another line\u0026#34; \u0026gt;\u0026gt; hello 변수 출력:\n1 2 3 echo $HOME # 홈 디렉토리 경로 echo $PATH # PATH 환경 변수 echo $USER # 현재 사용자 이름 검색 및 필터링 17. grep 전체에서 특정 문자열을 찾을 때 사용합니다. grep 문자열 파일 형식으로 사용할 수 있습니다.\n기본 사용:\n1 2 3 user@user-VirtualBox:~/new_dir$ grep root /etc/passwd root:x:0:0:root:/root:/bin/bash nm-openvpn:x:121:127:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin 유용한 옵션:\n1 2 3 4 5 6 7 grep -i \u0026#34;error\u0026#34; log.txt # 대소문자 구분 없이 검색 grep -r \u0026#34;TODO\u0026#34; . # 현재 디렉토리에서 재귀 검색 grep -n \u0026#34;function\u0026#34; script.py # 줄 번호 포함 grep -v \u0026#34;comment\u0026#34; file.txt # 패턴과 일치하지 않는 줄 grep -c \u0026#34;error\u0026#34; log.txt # 일치하는 줄 개수만 출력 grep -A 3 \u0026#34;error\u0026#34; log.txt # 일치 줄 + 다음 3줄 grep -B 2 \u0026#34;error\u0026#34; log.txt # 일치 줄 + 이전 2줄 18. find 파일과 디렉토리를 검색하는 강력한 명령어입니다.\n1 2 3 4 5 6 7 find /home -name \u0026#34;*.txt\u0026#34; # 이름으로 검색 find . -type f -name \u0026#34;test*\u0026#34; # 파일만 검색 find . -type d -name \u0026#34;backup\u0026#34; # 디렉토리만 검색 find . -mtime -7 # 최근 7일 수정된 파일 find . -size +100M # 100MB 이상 파일 find . -name \u0026#34;*.log\u0026#34; -delete # 찾은 파일 삭제 find . -name \u0026#34;*.sh\u0026#34; -exec chmod +x {} \\; # 찾은 파일에 명령 실행 19. which / whereis 명령어나 프로그램의 위치를 찾습니다.\n1 2 3 which python # python 명령어의 실행 파일 위치 which gcc # gcc 컴파일러 위치 whereis ls # ls 명령어의 바이너리, 소스, 매뉴얼 위치 프로세스 관리 20. ps 현재 실행 중인 프로세스를 확인합니다.\n1 2 3 4 ps # 현재 터미널의 프로세스 ps aux # 모든 프로세스 상세 정보 ps aux | grep nginx # 특정 프로세스 찾기 ps -ef # 전체 프로세스 (다른 포맷) 21. top / htop 실시간으로 시스템 리소스와 프로세스를 모니터링합니다.\n1 2 top # 기본 모니터링 htop # 향상된 인터페이스 (설치 필요: sudo apt install htop) top 내부 명령:\nq: 종료 k: 프로세스 종료 M: 메모리 사용량 정렬 P: CPU 사용량 정렬 22. kill 프로세스를 종료합니다.\n1 2 3 kill 1234 # PID 1234 프로세스 종료 kill -9 1234 # 강제 종료 killall nginx # 이름으로 모든 nginx 프로세스 종료 도움말 23. man Manual의 줄임말로 특정 명령어의 매뉴얼을 보여주는 명령어입니다.\n1 2 3 man ls # ls 명령어 매뉴얼 man grep # grep 명령어 매뉴얼 man 5 passwd # /etc/passwd 파일 형식 매뉴얼 man 페이지 탐색:\nSpace: 다음 페이지 b: 이전 페이지 /word: 검색 q: 종료 24. help / \u0026ndash;help 간단한 도움말을 출력합니다.\n1 2 3 ls --help cp --help help cd # 내장 명령어 네트워크 25. curl client URL의 줄임말로 서버에 데이터를 보내거나 서버로부터 받는 데이터 전송 명령어입니다. HTTP, HTTPS, FTP 등 다양한 프로토콜을 지원합니다.\n기본 사용:\n1 curl https://example.com # 웹 페이지 내용 가져오기 주요 옵션:\n1 2 3 4 curl -o file.html https://example.com # 파일로 저장 curl -O https://example.com/file.zip # 원본 이름으로 저장 curl -i https://example.com # 응답 헤더 포함 curl -L https://example.com # 리다이렉트 따라가기 HTTP 메소드:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # GET 요청 (기본) curl https://api.example.com/users # POST 요청 curl -X POST https://api.example.com/data \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;,\u0026#34;age\u0026#34;:30}\u0026#39; # PUT 요청 curl -X PUT https://api.example.com/users/1 \\ -d \u0026#34;name=Jane\u0026#34; # DELETE 요청 curl -X DELETE https://api.example.com/users/1 워게임에서의 활용:\n1 2 3 4 5 # 명령어 실행 결과를 서버로 전송 curl \u0026#34;http://myserver.com\u0026#34; -d \u0026#34;`cat /flag`\u0026#34; # 파일 내용 전송 curl -X POST http://myserver.com -d \u0026#34;@/etc/passwd\u0026#34; 26. wget 파일을 다운로드하는 명령어입니다.\n1 2 3 4 wget https://example.com/file.zip # 파일 다운로드 wget -O custom_name.zip https://... # 다른 이름으로 저장 wget -c https://example.com/large.iso # 중단된 다운로드 이어받기 wget -r https://example.com # 웹사이트 전체 다운로드 압축 및 아카이브 27. tar 파일을 묶고 압축하는 명령어입니다.\n1 2 3 4 5 tar -cvf archive.tar files/ # 묶기 tar -czvf archive.tar.gz files/ # 묶고 gzip 압축 tar -xvf archive.tar # 풀기 tar -xzvf archive.tar.gz # gzip 압축 해제하며 풀기 tar -tvf archive.tar # 내용 확인 옵션 의미:\nc: create (생성) x: extract (추출) v: verbose (과정 표시) f: file (파일 지정) z: gzip 압축/해제 j: bzip2 압축/해제 28. zip / unzip zip 형식으로 압축합니다.\n1 2 3 4 zip archive.zip file1 file2 # 압축 zip -r archive.zip directory/ # 디렉토리 압축 unzip archive.zip # 압축 해제 unzip -l archive.zip # 내용만 확인 디스크 사용량 29. du 디렉토리와 파일의 디스크 사용량을 확인합니다.\n1 2 3 4 du -h # 사람이 읽기 쉬운 형식 du -sh * # 현재 디렉토리의 각 항목 크기 du -sh /home/user # 특정 디렉토리 전체 크기 du -h --max-depth=1 # 1단계 깊이까지만 30. df 파일 시스템의 디스크 공간 사용량을 확인합니다.\n1 2 df -h # 모든 파일 시스템 df -h /home # 특정 디렉토리가 속한 파일 시스템 고급 기능 와일드카드 **와일드카드(wildcards)**는 리눅스에서 임의의 다른 문자를 나타낐 수 있는 특수 문자들을 의미합니다. 주로 명령어를 다른 문자열로 대체하기 위해 사용합니다.\n기본 와일드카드\n? - 임의의 1개 문자\na-z, 0-9 범위 내 임의의 1개 문자로 대체됩니다. 1 2 ls file?.txt # file1.txt, fileA.txt 등 매칭 ls test? # test1, testa 등 매칭 * - 임의의 0개 이상 문자\na-z, 0-9 범위 내 임의의 0개 이상 문자로 대체됩니다. 1 2 3 ls *.txt # 모든 .txt 파일 ls test* # test로 시작하는 모든 파일 ls *backup* # backup이 포함된 모든 파일 [] - 범위 지정\n[문자1-문자2] 혹은 [문자1, 문자2, …] 형태로 범위를 지정합니다. 1 2 3 ls file[1-3].txt # file1.txt, file2.txt, file3.txt ls [abc]* # a, b, c로 시작하는 파일 ls *.[ch] # .c 또는 .h로 끝나는 파일 실전 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # .txt로 끝나는 모든 파일 삭제 rm *.txt # file1, file2, file3... file9 선택 ls file[1-9] # 이름이 정확히 3글자인 모든 파일 ls ??? # test로 시작하는 모든 파일을 /backup/으로 복사 cp test* /backup/ # 2024년 로그 파일 전체 보기 cat log-2024-*.txt # JPG 또는 PNG 이미지 파일 이동 mv *.{jpg,png} images/ 리다이렉션 **리다이렉션(redirection)**은 모니터에 나타나는 표준 출력 혹은 키보드로 입력하는 표준 입력을 다른 곳으로 변경하는 작업입니다.\n표준 스트림\n표준 입력 (stdin): 0번, 키보드로부터의 입력 표준 출력 (stdout): 1번, 화면으로의 정상 출력 표준 에러 (stderr): 2번, 화면으로의 에러 메시지 출력 리다이렉션\n명령어 \u0026gt; 파일\n명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 덮어씁니다. 1 2 ls -l \u0026gt; file_list.txt # 출력을 파일에 저장 (덮어쓰기) echo \u0026#34;Hello\u0026#34; \u0026gt; greeting.txt 명령어 \u0026gt;\u0026gt; 파일\n명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 이어서 씁니다. 1 2 3 echo \u0026#34;Line 1\u0026#34; \u0026gt; log.txt # 새로 생성 echo \u0026#34;Line 2\u0026#34; \u0026gt;\u0026gt; log.txt # 추가 echo \u0026#34;Line 3\u0026#34; \u0026gt;\u0026gt; log.txt # 추가 명령어 2\u0026gt; 파일\n에러 메시지만 파일로 저장합니다. 1 2 3 4 command 2\u0026gt; error.log # 에러만 파일에 저장 command \u0026gt; output.txt 2\u0026gt; error.log # 출력과 에러 분리 command \u0026gt; output.txt 2\u0026gt;\u0026amp;1 # 출력과 에러를 같은 파일에 command \u0026amp;\u0026gt; all.log # 출력과 에러를 같은 파일에 (축약형) 입력 리다이렉션\n명령어 \u0026lt; 파일\n명령어 표준 입력을 파일로 변경합니다. 파일로부터 표준 입력을 받아 명령어를 수행합니다. 1 2 sort \u0026lt; unsorted.txt # 파일 내용을 정렬 wc -l \u0026lt; file.txt # 파일 줄 수 세기 Here Document\n1 2 3 4 5 cat \u0026lt;\u0026lt; EOF \u0026gt; file.txt 여러 줄의 텍스트를 입력할 수 있습니다 EOF 파이프 **파이프(pipe)**는 리다이렉션의 한 형태로, 명령어 결과 표준 출력을 다른 명령어의 표준 입력으로 보낼 때 사용합니다. 파이프는 | 문자로 나타냅니다.\n기본 사용\n1 2 3 ls -l | grep \u0026#34;.txt\u0026#34; # ls 출력에서 .txt 검색 cat file.txt | wc -l # 파일 줄 수 세기 ps aux | grep nginx # 프로세스 필터링 실전 파이프 활용\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 가장 많이 사용하는 명령어 top 10 history | awk \u0026#39;{print $2}\u0026#39; | sort | uniq -c | sort -rn | head # 특정 프로세스의 메모리 사용량 확인 ps aux | grep nginx | awk \u0026#39;{print $6}\u0026#39; # 로그에서 에러만 필터링하여 개수 확인 cat app.log | grep ERROR | wc -l # 디렉토리별 용량 확인 후 정렬 du -sh */ | sort -h # 가장 큰 파일 10개 찾기 du -ah | sort -rh | head -10 # 특정 확장자 파일 개수 find . -name \u0026#34;*.py\u0026#34; | wc -l # CPU 사용률 높은 프로세스 상위 5개 ps aux | sort -nrk 3 | head -5 # 특정 포트를 사용하는 프로세스 찾기 netstat -tuln | grep :80 # 중복 제거된 정렬된 목록 cat list.txt | sort | uniq # 로그에서 IP 주소 추출 및 빈도 분석 grep -oE \u0026#39;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#39; access.log | sort | uniq -c | sort -rn 권한 유저(user)와 그룹(group) 리눅스에서 유저와 그룹은 리눅스의 권한 시스템을 설명하기 위해 빠뜨릴 수 없는 개념입니다. 리눅스의 각 유저는 이름과 고유한 사용자 ID(UID)를 가지고 있습니다. 그룹은 말 그대로 여러 유저가 속할 수 있는 그룹으로, 이 역시 그룹 이름과 고유한 그룹 ID(GID)를 가지고 있습니다.\n파일이나 디렉토리와 같은 시스템 자원에 유저가 접근하면 유저의 UID와 해당 유저가 속한 그룹의 GID를 확인하여 정당한 권한을 가지고 있는지를 판단해 접근을 제어합니다.\n유저 정보 확인\n/etc/passwd는 리눅스의 유저 정보를 담고 있는 텍스트 파일입니다. 각 사용자의 이름, 사용자 ID, 속해있는 그룹 ID 등의 정보를 포함하고 있습니다.\n1 cat /etc/passwd 각 줄의 형식: username:x:UID:GID:comment:home_directory:shell\n예시:\nroot:x:0:0:root:/root:/bin/bash\ruser:x:1000:1000:user,,,:/home/user:/bin/bash 그룹 정보 확인\n/etc/group은 리눅스의 그룹 정보를 저장하는 텍스트 파일입니다. 각 그룹의 이름, 그룹 ID, 그룹에 속한 유저 목록 등의 정보를 포함하고 있습니다.\n1 cat /etc/group 유저 관련 명령어\n1 2 3 4 whoami # 현재 사용자 이름 id # 현재 사용자의 UID, GID 정보 groups # 현재 사용자가 속한 그룹들 users # 현재 로그인한 사용자들 파일 및 디렉토리 권한 리눅스는 사용자가 파일과 디렉토리에 접근하는 행위에 대해 권한으로 제어합니다. 각 파일과 디렉토리는 **소유자(owner)**와 **소유 그룹(group)**을 가지고 있습니다. 소유자는 파일 또는 디렉토리의 권한을 수정할 수 있는 능력을 가지고 있습니다.\n세 가지 접근 권한\n읽기(Read, r): 파일 또는 디렉토리의 내용을 볼 수 있게 허용합니다.\n파일: 파일 내용을 읽을 수 있음 디렉토리: 디렉토리 내 파일 목록을 볼 수 있음 쓰기(Write, w): 파일 또는 디렉토리의 내용을 수정하거나 삭제하는 것을 허용합니다.\n파일: 파일 내용을 수정하거나 삭제할 수 있음 디렉토리: 디렉토리 내에 파일을 생성하거나 삭제할 수 있음 실행(Execute, x): 파일이 프로그램인 경우 실행할 수 있게 허용합니다.\n파일: 프로그램으로 실행할 수 있음 디렉토리: 디렉토리에 접근(cd)할 수 있음 권한 확인하기\n파일이나 디렉토리의 권한을 보기 위해 ls -l을 사용합니다.\n1 2 3 4 5 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ---------- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world 권한 플래그 해석 1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir 권한 플래그 drwxrwxr-x는 4개 부분으로 나뉩니다:\nd rwx rwx r-x\r│ └┬┘ └┬┘ └┬┘\r│ │ │ └─→ 기타 사용자 권한 (r-x: 읽기, 실행)\r│ │ └─────→ 그룹 권한 (rwx: 읽기, 쓰기, 실행)\r│ └─────────→ 소유자 권한 (rwx: 읽기, 쓰기, 실행)\r└────────────→ 파일 타입 (d: 디렉토리) 파일 타입 (첫 번째 문자)\nd: 디렉토리 (directory) -: 일반 파일 (regular file) l: 심볼릭 링크 (symbolic link) b: 블록 디바이스 (block device) c: 문자 디바이스 (character device) s: 소켓 (socket) p: 파이프 (pipe) 권한 문자\nr: 읽기 권한 (Read) w: 쓰기 권한 (Write) x: 실행 권한 (Execute) -: 해당 권한 없음 권한의 숫자 표현\n권한은 2진수나 10진수로도 표현할 수 있습니다.\n권한 2진수 10진수 의미 --- 000 0 권한 없음 --x 001 1 실행만 -w- 010 2 쓰기만 -wx 011 3 쓰기, 실행 r-- 100 4 읽기만 r-x 101 5 읽기, 실행 rw- 110 6 읽기, 쓰기 rwx 111 7 모든 권한 예시:\nrwx = 111 = 7 rw- = 110 = 6 r-- = 100 = 4 rwxrw-r-- = 764 소유자와 소유 그룹\n1 2 3 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ↑ ↑ 소유자 소유그룹 세 번째 열: 파일/디렉토리의 소유자 네 번째 열: 파일/디렉토리의 소유 그룹 종합 예시\n1 -rwxrw-r-- 1 user user 13 12월 2 13:08 world 해석:\n파일 타입: - (일반 파일) 소유자 권한: rwx (읽기, 쓰기, 실행 가능) 그룹 권한: rw- (읽기, 쓰기 가능, 실행 불가) 기타 권한: r-- (읽기만 가능) 소유자: user 소유 그룹: user 파일 및 디렉토리 권한 명령어 chmod chmod는 파일 권한을 변경하는 명령어입니다. root 유저 혹은 파일의 소유자만 실행할 수 있습니다.\n형식\n1 chmod 권한 파일명 숫자 모드\n1 2 3 4 5 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ---------- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world hello 파일을 rwxrw-r-- (764) 권한으로 변경:\n소유자: rwx = 7 그룹: rw- = 6 기타: r-- = 4 1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ chmod 764 hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxrw-r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world 기호 모드\n대상:\nu: 소유자 (user) g: 그룹 (group) o: 기타 (others) a: 모두 (all) 연산:\n+: 권한 추가 -: 권한 제거 =: 권한 설정 권한 추가:\n1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ chmod g+x hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxrwxr-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world 권한 제거:\n1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ chmod g-wx hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world 유용한 예시\n1 2 3 4 5 6 7 8 chmod 644 file.txt # rw-r--r-- (일반 파일) chmod 755 script.sh # rwxr-xr-x (실행 파일) chmod 700 private.txt # rwx------ (소유자만 접근) chmod 777 public_dir # rwxrwxrwx (모두 접근, 위험!) chmod -R 755 directory/ # 디렉토리와 내부 파일 전체에 적용 chmod u+x script.sh # 소유자에게 실행 권한 추가 chmod a-w file.txt # 모두에게서 쓰기 권한 제거 chmod o-rwx private # 기타 사용자 모든 권한 제거 chown chown은 파일 소유자 혹은 소유 그룹을 변경하는 명령어입니다. root 유저만 실행할 수 있습니다.\n형식\n1 chown 사용자명[:그룹명] 파일명 소유자 변경\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ sudo chown root hello [sudo] password for user: user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ echo \u0026#34;hello\u0026#34; \u0026gt; hello bash: hello: Permission denied 소유자와 그룹 동시 변경\n1 2 3 sudo chown root:root hello # 소유자와 그룹을 root로 sudo chown user:developers file.txt # 특정 사용자와 그룹으로 sudo chown -R user:user directory/ # 디렉토리 전체에 재귀적으로 적용 chgrp chgrp는 소유 그룹만 변경하는 명령어입니다.\n1 2 sudo chgrp developers file.txt # 그룹만 변경 sudo chgrp -R www-data /var/www/ # 디렉토리 전체에 적용 특수 권한 앞서 배운 r, w, x 권한 외에 특수한 권한 3가지가 있습니다.\nsetuid (Set User ID) 일반 사용자가 파일을 실행하면 파일 소유자 권한으로 실행됩니다.\n예시: /bin/passwd\n1 2 user@user-VirtualBox:/bin$ ls -l passwd -rwsr-xr-x 1 root root 59976 11월 24 21:05 passwd 소유자의 실행 권한에 x 대신 s가 표시됩니다. 이는 일반 사용자가 passwd 명령을 실행하면 root 권한으로 실행되어 자신의 비밀번호를 변경할 수 있게 합니다.\ns: setuid가 설정되고 실행 권한도 있음 S: setuid는 설정되었지만 실행 권한이 없음 (의미 없음) setgid (Set Group ID) 일반 사용자가 파일을 실행하면 파일 소유 그룹 권한으로 실행됩니다.\n소유 그룹의 실행 권한에 x 대신 s가 표시됩니다.\n디렉토리에 setgid를 설정하면 해당 디렉토리 내에서 생성되는 모든 파일이 디렉토리의 그룹을 상속받습니다.\n1 drwxr-sr-x 2 user developers 4096 12월 2 13:38 shared_dir s: setgid가 설정되고 실행 권한도 있음 S: setgid는 설정되었지만 실행 권한이 없음 sticky bit 디렉토리에 sticky bit를 설정하면 파일 및 디렉토리 소유자와 root 사용자 외에는 일반 사용자가 파일을 삭제할 수 없습니다. 주로 공용 디렉토리에 사용합니다.\n예시: /tmp 디렉토리\n1 drwxrwxrwt 20 root root 4096 12월 1 14:17 tmp 일반 사용자의 실행 권한에 x 대신 t가 표시됩니다.\nt: sticky bit가 설정되고 실행 권한도 있음 T: sticky bit는 설정되었지만 실행 권한이 없음 특수 권한 설정 특수 권한은 숫자 형식으로 권한 플래그 맨 앞에 붙여 표현합니다:\nsetuid: 4 setgid: 2 sticky bit: 1 숫자 모드\n1 2 3 4 5 6 7 8 9 10 11 12 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ chmod 4775 world user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwsrwxr-x 1 user user 13 12월 2 13:08 world 기호 모드\n1 2 3 4 chmod u+s file # setuid 설정 chmod g+s directory # setgid 설정 chmod o+t directory # sticky bit 설정 chmod u-s file # setuid 제거 조합 예시\n1 2 3 4 chmod 4755 program # rwsr-xr-x (setuid) chmod 2755 shared_dir # rwxr-sr-x (setgid) chmod 1777 /tmp # rwxrwxrwt (sticky bit) chmod 6755 file # rwsr-sr-x (setuid + setgid) 디렉토리 구조 루트 디렉토리 / 루트 디렉토리는 리눅스의 최상위 디렉토리를 말하며, 절대 경로는 /입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 user@user-VirtualBox:~$ ls -l / total 3991632 lrwxrwxrwx 1 root root 7 11월 30 18:15 bin -\u0026gt; usr/bin drwxr-xr-x 4 root root 4096 12월 1 14:10 boot drwxrwxr-x 2 root root 4096 11월 30 18:25 cdrom drwxr-xr-x 19 root root 4180 12월 1 14:25 dev drwxr-xr-x 130 root root 12288 12월 1 14:09 etc drwxr-xr-x 3 root root 4096 11월 30 18:27 home lrwxrwxrwx 1 root root 7 11월 30 18:15 lib -\u0026gt; usr/lib lrwxrwxrwx 1 root root 9 11월 30 18:15 lib32 -\u0026gt; usr/lib32 lrwxrwxrwx 1 root root 9 11월 30 18:15 lib64 -\u0026gt; usr/lib64 lrwxrwxrwx 1 root root 10 11월 30 18:15 libx32 -\u0026gt; usr/libx32 drwx------ 2 root root 16384 11월 30 18:14 lost+found drwxr-xr-x 3 root root 4096 11월 30 19:49 media drwxr-xr-x 2 root root 4096 8월 9 20:48 mnt drwxr-xr-x 3 root root 4096 11월 30 19:55 opt dr-xr-xr-x 257 root root 0 12월 1 14:11 proc drwx------ 4 root root 4096 12월 1 14:17 root drwxr-xr-x 33 root root 900 12월 1 14:12 run lrwxrwxrwx 1 root root 8 11월 30 18:15 sbin -\u0026gt; usr/sbin drwxr-xr-x 11 root root 4096 8월 9 20:55 snap drwxr-xr-x 2 root root 4096 8월 9 20:48 srv -rw------- 1 root root 4087349248 11월 30 18:15 swapfile dr-xr-xr-x 13 root root 0 12월 1 14:11 sys drwxrwxrwt 20 root root 4096 12월 1 14:17 tmp drwxr-xr-x 14 root root 4096 8월 9 20:48 usr drwxr-xr-x 14 root root 4096 8월 9 20:54 var 주요 디렉토리 설명 /bin - 기본 명령어 일반 유저가 사용할 수 있는 기본적인 명령어나 프로그램을 담고 있는 디렉토리입니다.\n1 ls, cp, mv, rm, cat, echo, mkdir, chmod, ps 등 최신 시스템에서는 /usr/bin으로의 심볼릭 링크입니다.\n/boot - 부팅 파일 시스템 부팅에 필요한 파일들을 담고 있는 디렉토리입니다.\n1 커널 이미지, 부트로더 설정 파일, initramfs 등 /dev - 디바이스 파일 컴퓨터에 부착된 물리적인 장치들을 파일 형태로 접근할 수 있게 합니다.\n1 2 3 4 5 /dev/sda # 첫 번째 하드 디스크 /dev/sda1 # 첫 번째 하드 디스크의 첫 번째 파티션 /dev/null # 널 디바이스 (출력 버리기에 사용) /dev/zero # 0을 무한히 생성 /dev/random # 난수 생성기 /etc - 설정 파일 운영체제나 운영체제 위에서 동작하는 서비스의 설정 파일들을 담고 있는 디렉토리입니다.\n1 2 3 4 5 6 7 /etc/passwd # 사용자 정보 /etc/group # 그룹 정보 /etc/hosts # 호스트 이름 매핑 /etc/hostname # 시스템 호스트명 /etc/ssh/ # SSH 서버 설정 /etc/nginx/ # Nginx 웹서버 설정 /etc/apache2/ # Apache 웹서버 설정 /home - 사용자 홈 디렉토리 각 일반 유저의 홈 디렉토리를 담고 있는 디렉토리입니다.\n1 2 /home/user # user 사용자의 홈 디렉토리 /home/dream # dream 사용자의 홈 디렉토리 각 사용자는 자신의 홈 디렉토리에서 완전한 권한을 가집니다.\n/lib, /lib32, /lib64 - 라이브러리 시스템에 필요한 라이브러리 파일들을 담고 있는 디렉토리입니다.\n1 공유 라이브러리, 커널 모듈 등 /bin이나 /sbin의 프로그램이 필요로 하는 동적 라이브러리 파일이 존재합니다.\n/media - 이동식 미디어 이동식 미디어(USB, CD/DVD 등)가 자동으로 마운트되는 디렉토리입니다.\n1 2 /media/user/USB_DRIVE /media/user/CDROM /mnt - 임시 마운트 파일 시스템을 임시로 마운트하는 데 사용하는 디렉토리입니다.\n1 sudo mount /dev/sdb1 /mnt /opt - 선택적 소프트웨어 추가로 설치한 소프트웨어 패키지들을 담는 디렉토리입니다.\n1 2 /opt/google/chrome /opt/teamviewer /proc - 프로세스 정보 리눅스 커널 자원에 접근할 수 있는 가상 파일 시스템입니다. 프로세스와 시스템 정보를 파일 형태로 제공합니다.\n1 2 3 4 /proc/cpuinfo # CPU 정보 /proc/meminfo # 메모리 정보 /proc/[PID]/ # 각 프로세스 정보 /proc/version # 커널 버전 /root - root 사용자 홈 root 유저의 홈 디렉토리입니다. /home/root가 아님에 주의하세요.\n/run - 런타임 데이터 시스템이 부팅된 이후 런타임 데이터를 저장합니다.\n1 PID 파일, 소켓 파일 등 /sbin - 시스템 관리 명령어 /bin 디렉토리와 유사하지만, root 유저가 사용하는 시스템 관리 명령어를 포함합니다.\n1 fdisk, mkfs, shutdown, reboot, iptables 등 /srv - 서비스 데이터 시스템에서 제공하는 서비스의 데이터를 저장하는 디렉토리입니다.\n1 2 /srv/www # 웹 서버 데이터 /srv/ftp # FTP 서버 데이터 /sys - 시스템 정보 커널과 하드웨어 정보를 제공하는 가상 파일 시스템입니다.\n/tmp - 임시 파일 유저나 프로그램이 임시로 파일을 생성할 때 사용하는 디렉토리입니다.\n주의: 시스템 재부팅 시 또는 일정 시간이 지나면 파일이 자동으로 삭제될 수 있습니다.\n1 drwxrwxrwt # sticky bit로 보호됨 /usr - 사용자 프로그램 사용자 바이너리, 문서, 라이브러리, 헤더 파일 등을 담고 있는 디렉토리입니다.\n1 2 3 4 5 6 /usr/bin/ # 사용자 명령어 /usr/sbin/ # 시스템 관리 명령어 /usr/lib/ # 라이브러리 /usr/local/ # 로컬에 설치한 프로그램 /usr/share/ # 아키텍처 독립적인 데이터 /usr/include/ # C 헤더 파일 /var - 가변 데이터 프로그램이나 시스템이 실시간으로 가변적인 파일을 사용하고 저장할 때 활용하는 디렉토리입니다.\n1 2 3 4 5 6 /var/log/ # 각종 로그 파일 /var/www/ # 웹 서버 루트 (보통) /var/mail/ # 메일 스풀 /var/spool/ # 대기열 데이터 (프린터, cron 등) /var/tmp/ # 재부팅 후에도 유지되는 임시 파일 /var/cache/ # 애플리케이션 캐시 ⚠️ 주의사항 및 안전 사용 팁 위험한 명령어들 절대 실행하지 마세요!\n1 2 3 4 5 6 rm -rf / # 시스템 전체 삭제 (현대 시스템은 보호됨) rm -rf /* # 루트 디렉토리의 모든 내용 삭제 chmod 777 -R / # 모든 파일 권한 열기 (심각한 보안 위험) dd if=/dev/zero of=/dev/sda # 디스크 전체 초기화 mkfs.ext4 /dev/sda # 파티션 포맷 (데이터 삭제) :(){ :|:\u0026amp; };: # Fork bomb (시스템 멈춤) 안전한 사용 습관 1. 삭제 전 항상 확인\n1 2 ls -l file* # 먼저 어떤 파일이 매칭되는지 확인 rm -i file* # 삭제 전 각 파일마다 확인 2. 중요한 작업 전 백업\n1 2 cp important.txt important.txt.backup tar -czf backup_$(date +%Y%m%d).tar.gz /important/directory/ 3. sudo 사용 시 신중하게\n1 2 3 4 5 6 # 나쁜 예 sudo rm -rf /tmp ../file # 경로 실수 시 위험 # 좋은 예 ls -l /tmp ../file # 먼저 확인 sudo rm -rf /tmp ../file # 확인 후 실행 4. 와일드카드 사용 시 주의\n1 2 3 4 5 6 # 나쁜 예 rm * .txt # 모든 파일 삭제 후 .txt 삭제 시도 # 좋은 예 rm *.txt # .txt 파일만 삭제 ls *.txt # 먼저 무엇이 삭제될지 확인 5. 절대 경로 vs 상대 경로\n1 2 3 4 5 6 # 현재 위치를 항상 확인 pwd # 중요한 작업은 절대 경로 사용 rm -rf /home/user/old_project # 명확함 # rm -rf ../../../old_project # 위험할 수 있음 유용한 팁과 트릭 명령어 히스토리 1 2 3 4 5 history # 명령어 이력 보기 !100 # 100번째 명령어 실행 !! # 마지막 명령어 실행 !grep # grep으로 시작하는 마지막 명령어 실행 Ctrl + R # 명령어 이력 검색 (interactive) 단축키 터미널 조작\nCtrl + C # 현재 실행 중인 프로세스 중단\rCtrl + Z # 현재 프로세스 일시 중지\rCtrl + D # 로그아웃 / EOF 전송\rCtrl + L # 화면 지우기 (clear 명령어와 동일) 커서 이동\nCtrl + A # 줄의 시작으로\rCtrl + E # 줄의 끝으로\rCtrl + U # 커서부터 앞쪽 전체 삭제\rCtrl + K # 커서부터 뒷쪽 전체 삭제\rCtrl + W # 커서 앞의 단어 삭제 Tab 자동완성\nTab # 파일명/명령어 자동완성\rTab Tab # 가능한 모든 옵션 표시 별칭(Alias) 설정 자주 사용하는 명령어를 짧게 만들 수 있습니다.\n1 2 3 4 5 6 7 8 9 # 임시 별칭 (현재 세션만) alias ll=\u0026#39;ls -alh\u0026#39; alias ..=\u0026#39;cd ..\u0026#39; alias ...=\u0026#39;cd ../..\u0026#39; alias grep=\u0026#39;grep --color=auto\u0026#39; # 영구 별칭 (~/.bashrc 또는 ~/.zshrc에 추가) echo \u0026#34;alias ll=\u0026#39;ls -alh\u0026#39;\u0026#34; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc 환경 변수 1 2 3 4 5 6 7 8 9 10 11 echo $PATH # PATH 환경 변수 확인 echo $HOME # 홈 디렉토리 echo $USER # 현재 사용자 echo $SHELL # 현재 셸 # 환경 변수 설정 export MY_VAR=\u0026#34;value\u0026#34; echo $MY_VAR # 영구 설정 (~/.bashrc에 추가) echo \u0026#39;export PATH=$PATH:/my/custom/path\u0026#39; \u0026gt;\u0026gt; ~/.bashrc 작업 관리 1 2 3 4 5 command \u0026amp; # 백그라운드에서 실행 jobs # 백그라운드 작업 목록 fg %1 # 1번 작업을 포그라운드로 bg %1 # 1번 작업을 백그라운드로 nohup command \u0026amp; # 로그아웃 후에도 계속 실행 파일 찾기 고급 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 최근 수정된 파일 찾기 find . -mtime -7 # 7일 이내 find . -mmin -60 # 60분 이내 # 파일 크기로 찾기 find . -size +100M # 100MB 이상 find . -size -1k # 1KB 이하 # 찾은 파일에 명령 실행 find . -name \u0026#34;*.log\u0026#34; -exec rm {} \\; find . -type f -name \u0026#34;*.txt\u0026#34; -exec grep \u0026#34;error\u0026#34; {} + # 여러 조건 조합 find . -type f -name \u0026#34;*.py\u0026#34; -size +1M -mtime -30 텍스트 처리 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 줄 번호 표시 cat -n file.txt nl file.txt # 중복 제거 sort file.txt | uniq sort -u file.txt # 컬럼 추출 awk \u0026#39;{print $1}\u0026#39; file.txt # 첫 번째 컬럼 cut -d\u0026#39;:\u0026#39; -f1 /etc/passwd # : 구분자로 첫 번째 필드 # 문자열 치환 sed \u0026#39;s/old/new/\u0026#39; file.txt # 첫 번째 매치만 sed \u0026#39;s/old/new/g\u0026#39; file.txt # 모든 매치 sed -i \u0026#39;s/old/new/g\u0026#39; file.txt # 파일 직접 수정 시스템 모니터링 1 2 3 4 5 6 7 8 9 10 11 12 # 디스크 I/O iostat iotop # 실시간 I/O 모니터링 # 네트워크 netstat -tuln # 리스닝 포트 ss -tuln # 현대적인 대체 lsof -i :80 # 특정 포트 사용 프로세스 # 메모리 free -h # 메모리 사용량 vmstat # 가상 메모리 통계 실전 시나리오 시나리오 1: 디스크 공간 확보 상황: 디스크 공간이 부족합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 1. 디스크 사용량 확인 df -h # 2. 큰 파일/디렉토리 찾기 du -sh /* | sort -h # 3. 특정 디렉토리 상세 분석 du -h --max-depth=1 /home | sort -h # 4. 100MB 이상 파일 찾기 find / -type f -size +100M 2\u0026gt;/dev/null # 5. 오래된 로그 파일 정리 find /var/log -name \u0026#34;*.log\u0026#34; -mtime +30 -delete # 6. 임시 파일 정리 sudo apt clean # 패키지 캐시 rm -rf ~/.cache/* # 사용자 캐시 시나리오 2: 시스템 느림 진단 상황: 시스템이 갑자기 느려졌습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 1. CPU 사용률 확인 top # 또는 htop # 2. CPU 사용 상위 프로세스 ps aux --sort=-%cpu | head # 3. 메모리 사용 상위 프로세스 ps aux --sort=-%mem | head # 4. 디스크 I/O 확인 iostat -x 1 # 5. 특정 프로세스 종료 kill -9 [PID] 시나리오 3: 로그 분석 상황: 웹 서버에 문제가 있어 로그를 분석해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1. 최근 에러 확인 tail -f /var/log/nginx/error.log # 2. 특정 시간대 로그 grep \u0026#34;2026-01-12 14:\u0026#34; /var/log/nginx/access.log # 3. 404 에러 개수 grep \u0026#34;404\u0026#34; /var/log/nginx/access.log | wc -l # 4. IP별 요청 횟수 awk \u0026#39;{print $1}\u0026#39; /var/log/nginx/access.log | sort | uniq -c | sort -rn # 5. 가장 많이 요청된 URL awk \u0026#39;{print $7}\u0026#39; /var/log/nginx/access.log | sort | uniq -c | sort -rn | head # 6. 에러 로그를 파일로 저장 grep \u0026#34;error\u0026#34; /var/log/nginx/error.log \u0026gt; errors_$(date +%Y%m%d).log 시나리오 4: 백업 및 복원 상황: 프로젝트 파일을 백업하고 싶습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1. 압축 백업 생성 tar -czf backup_$(date +%Y%m%d_%H%M%S).tar.gz /path/to/project # 2. 원격 서버로 전송 scp backup_*.tar.gz user@remote:/backup/ # 3. 백업에서 복원 tar -xzf backup_20260112_143000.tar.gz # 4. 특정 파일만 추출 tar -xzf backup.tar.gz path/to/specific/file # 5. 증분 백업 (rsync 사용) rsync -avz --delete /source/ /backup/ # 6. 원격 동기화 rsync -avz -e ssh /local/path/ user@remote:/remote/path/ 시나리오 5: 권한 문제 해결 상황: 웹 서버가 특정 파일에 접근하지 못합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 1. 파일 권한 확인 ls -l /var/www/html/ # 2. 소유자 확인 stat /var/www/html/index.html # 3. 웹 서버 사용자 확인 (nginx 예시) ps aux | grep nginx # 4. 소유자 변경 sudo chown -R www-data:www-data /var/www/html/ # 5. 권한 설정 sudo find /var/www/html -type d -exec chmod 755 {} \\; sudo find /var/www/html -type f -exec chmod 644 {} \\; # 6. 특수 권한이 필요한 경우 sudo chmod u+s /usr/bin/special_program 실전 문제 풀이 1 2 3 4 5 ls # 현재 디렉토리 파일 확인 cat hint.txt # 힌트 파일 읽기 cat /dream/hack/hello/flag.txt # 힌트에 나온 경로의 플래그 읽기 cat app.py # 추가 파일 확인 cat ./dream/hack/hello/f*ag.txt # 와일드카드로 플래그 파일 읽기 Details 플래그: DH{671ce26c70829e716fae26c7c71a33823feb479f2562891f64605bf68f60ae54}\n","permalink":"http://localhost:1313/posts/2026-01-08/","summary":"리눅스 사용법 정리글","title":"리눅스 사용법 완벽 가이드"},{"content":"1. 개요 (Intro) 안녕하세요, AlwaysHyeon의 보안 블로그입니다. 이 글은 GitHub Pages와 Hugo PaperMod 테마가 정상적으로 연동되었는지 확인하기 위한 테스트 포스트입니다.\n테스트 환경 Generator: Hugo Theme: PaperMod Hosting: GitHub Pages 2. 기능 테스트 (Feature Test) 2.1. 코드 하이라이팅 (Code Block) Python 코드가 예쁘게 나오는지 확인합니다.\n1 2 3 4 5 6 7 8 import os def check_security(): print(\u0026#34;System Secure... maybe?\u0026#34;) return True if __name__ == \u0026#34;__main__\u0026#34;: check_security() ","permalink":"http://localhost:1313/posts/test-post/","summary":"Hugo PaperMod 테마 적용 테스트 글입니다. 마크다운 문법과 코드 하이라이팅이 잘 적용되는지 확인합니다.","title":"블로그 테스트 및 첫 번째 글 (Hello World)"},{"content":"셸(Shell) 셸은 유저가 리눅스 시스템을 이용할 수 있는 인터페이스입니다. 사용자와 커널 사이에서 명령어를 해석하고 실행하는 중요한 역할을 합니다.\n터미널 실행 단축키 Windows/Linux: Ctrl + Alt + T macOS: Control + Option + T 또는 Command + Space로 Spotlight 실행 후 \u0026ldquo;Terminal\u0026rdquo; 입력 셸 프롬프트(Shell Prompt) 셸이 입력을 받을 준비가 되었을 때 다음과 같은 프롬프트가 표시됩니다:\n1 user@user-VirtualBox:~$ 프롬프트 구조:\nuser: 현재 로그인한 사용자 이름 user-VirtualBox: 호스트(컴퓨터) 이름 ~: 현재 위치한 디렉토리 (~는 홈 디렉토리를 의미) $: 일반 사용자 (#는 root 사용자를 의미) id 명령어 현재 유저의 사용자 ID(UID)와 해당 유저가 속해 있는 그룹 ID(GID)를 확인합니다.\n1 2 3 user@user-VirtualBox:~$ id uid=1000(user) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),134(lxd),135(sambashare) user@user-VirtualBox:~$ 기본 명령어 시스템 정보 및 관리 1. sudo apt update apt 명령어로 설치 가능한 소프트웨어 패키지 목록을 업데이트합니다. 각 소프트웨어별로 설치 가능한 버전 정보도 함께 업데이트합니다.\n1 sudo apt update 2. sudo apt upgrade 리눅스에 설치된 소프트웨어 패키지의 버전을 업그레이드합니다.\n1 sudo apt upgrade 3. id 리눅스는 권한을 기반으로 파일을 읽고 쓸 수 있기 때문에 주로 자신이 해당하는 권한을 가지고 있는지 확인하기 위해서 사용하는 명령어입니다.\n1 id 디렉토리 탐색 4. pwd Print Working Directory의 줄임말로 현재 작업 중인 디렉토리의 경로를 출력합니다.\n1 2 user@user-VirtualBox:~$ pwd /home/user 5. ls List의 줄임말로 디렉토리의 내용을 출력하는 명령어입니다.\n기본 사용법:\n1 2 ls # 현재 디렉토리 내용 ls /home # 특정 디렉토리 내용 유용한 옵션:\n1 2 3 4 5 6 ls -l # 상세 정보 포함 ls -a # 숨김 파일 포함 ls -lh # 사람이 읽기 쉬운 파일 크기 ls -lt # 수정 시간순 정렬 ls -lS # 파일 크기순 정렬 ls -lR # 하위 디렉토리까지 재귀적으로 표시 6. cd Change Directory의 줄임말로 작업 중인 디렉토리를 변경하는 명령어입니다.\n구분 기호/명령어 설명 예시 절대 경로 / 시작 루트 디렉토리(/)를 시작으로 모든 경로를 전부 적어서 표현하는 방식 cd /home/user 상대 경로 .. 등 현재 디렉토리를 기준으로 상위 또는 하위 디렉토리로 뻗어 나가는 방식 cd .. (현재 위치에서 부모 디렉토리로 이동) 홈 디렉토리 ~ 현재 로그인한 유저의 홈 디렉토리 cd ~ 또는 cd (내 홈 폴더로 이동) 이전 경로 - 직전에 위치했던 디렉토리 (바로 전 경로) cd - (이전 작업 위치로 복귀) 현재 디렉토리 . 현재 디렉토리 cd . (변화 없음, 주로 상대 경로에 활용) 파일 및 디렉토리 생성 7. mkdir Make Directory의 줄임말로 디렉토리를 생성하는 명령어입니다.\n1 2 3 mkdir new_dir # 단일 디렉토리 생성 mkdir dir1 dir2 dir3 # 여러 디렉토리 동시 생성 mkdir -p parent/child/grandchild # 상위 디렉토리까지 자동 생성 /home/user 디렉토리에 위치할 때 mkdir new_dir 명령어로 new_dir 디렉토리를 생성하면, new_dir가 새롭게 추가됩니다.\n8. touch 비어있는 새로운 파일을 만드는 데 사용합니다. 파일이 이미 존재하는 경우 수정 시간을 현재 시간으로 업데이트합니다.\n1 2 3 4 user@user-VirtualBox:~/new_dir$ ls -l user@user-VirtualBox:~/new_dir$ touch new_file user@user-VirtualBox:~/new_dir$ ls -l -rw-rw-r-- 1 user user 0 12월 2 13:05 new_file 여러 파일 동시 생성:\n1 touch file1.txt file2.txt file3.txt 파일 및 디렉토리 조작 9. mv Move의 줄임말로 파일이나 디렉토리의 위치를 옮기거나 이름을 변경할 때 사용하는 명령어입니다.\n이름 변경:\n1 mv old_name new_name 파일 이동:\n1 2 3 4 5 6 7 8 9 10 user@user-VirtualBox:~/new_dir$ ls old_file user@user-VirtualBox:~/new_dir$ ls .. Desktop Downloads new_dir Public Templates Documents Music Pictures snap Videos user@user-VirtualBox:~/new_dir$ mv old_file .. user@user-VirtualBox:~/new_dir$ ls user@user-VirtualBox:~/new_dir$ ls .. Desktop Downloads new_dir Pictures snap Videos Documents Music old_file Public Templates 여러 파일을 디렉토리로 이동:\n1 mv file1.txt file2.txt file3.txt /destination/ 10. cp Copy의 줄임말로 파일이나 디렉토리를 복사하는 명령어입니다.\n파일 복사:\n1 2 3 4 5 6 7 8 9 10 user@user-VirtualBox:~/new_dir$ ls -l total 4 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello user@user-VirtualBox:~/new_dir$ cp hello world user@user-VirtualBox:~/new_dir$ ls -l total 8 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello -rw-rw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ cat world Hello world! 디렉토리 복사:\n1 2 cp -r source_dir destination_dir # 디렉토리 전체 복사 cp -r dir1/ dir2/ # dir1의 내용을 dir2로 복사 유용한 옵션:\n1 2 3 cp -i file1 file2 # 덮어쓰기 전 확인 cp -v file1 file2 # 복사 과정 표시 cp -u file1 file2 # 더 최신 파일만 복사 11. rm Remove의 줄임말로 파일이나 디렉토리를 삭제하는 명령어입니다.\n파일 삭제:\n1 rm file.txt 디렉토리 삭제:\n1 rm -r directory_name # 디렉토리와 내용물 전체 삭제 유용한 옵션:\n1 2 3 rm -i file.txt # 삭제 전 확인 rm -f file.txt # 강제 삭제 (확인 없이) rm -rf directory/ # 디렉토리 강제 삭제 (주의!) 파일 내용 보기 12. cat 파일의 내용을 출력하는 명령어입니다. cat 파일경로 형식으로 사용할 수 있습니다.\n1 2 3 4 5 6 7 user@user-VirtualBox:~/new_dir$ cat /etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin ... (생략) user:x:1000:1000:user,,,:/home/user:/bin/bash 여러 파일 연결:\n1 cat file1.txt file2.txt \u0026gt; combined.txt 13. head / tail 파일의 처음 또는 끝 부분만 출력합니다.\n1 2 3 4 5 head file.txt # 처음 10줄 head -n 20 file.txt # 처음 20줄 tail file.txt # 마지막 10줄 tail -n 50 file.txt # 마지막 50줄 tail -f log.txt # 실시간 로그 모니터링 (매우 유용!) 14. less / more 파일 내용을 페이지 단위로 보여줍니다.\n1 2 less large_file.txt # 위아래 스크롤 가능, 검색 가능 (추천) more large_file.txt # 한 방향으로만 스크롤 less 명령어 내부에서:\nSpace: 다음 페이지 b: 이전 페이지 /word: 단어 검색 q: 종료 15. file 파일의 유형을 출력하는 명령어입니다.\n1 2 user@user-VirtualBox:~$ file /bin/ls /bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=897f49cafa98c11d63e619e7e40352f855249c13, for GNU/Linux 3.2.0, stripped 다양한 파일 타입 확인:\n1 2 3 file document.pdf # PDF document file image.jpg # JPEG image data file script.sh # Bourne-Again shell script 텍스트 출력 및 생성 16. echo 셸에 유저가 입력한 텍스트를 출력합니다.\n1 2 user@user-VirtualBox:~/new_dir$ echo \u0026#34;Hello world!\u0026#34; Hello world! 파일로 리다이렉션:\n1 2 3 4 5 6 7 8 user@user-VirtualBox:~/new_dir$ ls -l total 0 user@user-VirtualBox:~/new_dir$ echo \u0026#34;Hello world!\u0026#34; \u0026gt; hello user@user-VirtualBox:~/new_dir$ ls -l total 4 -rw-rw-r-- 1 user user 13 12월 2 13:05 hello user@user-VirtualBox:~/new_dir$ cat hello Hello world! 파일에 추가:\n1 echo \u0026#34;Another line\u0026#34; \u0026gt;\u0026gt; hello 변수 출력:\n1 2 3 echo $HOME # 홈 디렉토리 경로 echo $PATH # PATH 환경 변수 echo $USER # 현재 사용자 이름 검색 및 필터링 17. grep 전체에서 특정 문자열을 찾을 때 사용합니다. grep 문자열 파일 형식으로 사용할 수 있습니다.\n기본 사용:\n1 2 3 user@user-VirtualBox:~/new_dir$ grep root /etc/passwd root:x:0:0:root:/root:/bin/bash nm-openvpn:x:121:127:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin 유용한 옵션:\n1 2 3 4 5 6 7 grep -i \u0026#34;error\u0026#34; log.txt # 대소문자 구분 없이 검색 grep -r \u0026#34;TODO\u0026#34; . # 현재 디렉토리에서 재귀 검색 grep -n \u0026#34;function\u0026#34; script.py # 줄 번호 포함 grep -v \u0026#34;comment\u0026#34; file.txt # 패턴과 일치하지 않는 줄 grep -c \u0026#34;error\u0026#34; log.txt # 일치하는 줄 개수만 출력 grep -A 3 \u0026#34;error\u0026#34; log.txt # 일치 줄 + 다음 3줄 grep -B 2 \u0026#34;error\u0026#34; log.txt # 일치 줄 + 이전 2줄 18. find 파일과 디렉토리를 검색하는 강력한 명령어입니다.\n1 2 3 4 5 6 7 find /home -name \u0026#34;*.txt\u0026#34; # 이름으로 검색 find . -type f -name \u0026#34;test*\u0026#34; # 파일만 검색 find . -type d -name \u0026#34;backup\u0026#34; # 디렉토리만 검색 find . -mtime -7 # 최근 7일 수정된 파일 find . -size +100M # 100MB 이상 파일 find . -name \u0026#34;*.log\u0026#34; -delete # 찾은 파일 삭제 find . -name \u0026#34;*.sh\u0026#34; -exec chmod +x {} \\; # 찾은 파일에 명령 실행 19. which / whereis 명령어나 프로그램의 위치를 찾습니다.\n1 2 3 which python # python 명령어의 실행 파일 위치 which gcc # gcc 컴파일러 위치 whereis ls # ls 명령어의 바이너리, 소스, 매뉴얼 위치 프로세스 관리 20. ps 현재 실행 중인 프로세스를 확인합니다.\n1 2 3 4 ps # 현재 터미널의 프로세스 ps aux # 모든 프로세스 상세 정보 ps aux | grep nginx # 특정 프로세스 찾기 ps -ef # 전체 프로세스 (다른 포맷) 21. top / htop 실시간으로 시스템 리소스와 프로세스를 모니터링합니다.\n1 2 top # 기본 모니터링 htop # 향상된 인터페이스 (설치 필요: sudo apt install htop) top 내부 명령:\nq: 종료 k: 프로세스 종료 M: 메모리 사용량 정렬 P: CPU 사용량 정렬 22. kill 프로세스를 종료합니다.\n1 2 3 kill 1234 # PID 1234 프로세스 종료 kill -9 1234 # 강제 종료 killall nginx # 이름으로 모든 nginx 프로세스 종료 도움말 23. man Manual의 줄임말로 특정 명령어의 매뉴얼을 보여주는 명령어입니다.\n1 2 3 man ls # ls 명령어 매뉴얼 man grep # grep 명령어 매뉴얼 man 5 passwd # /etc/passwd 파일 형식 매뉴얼 man 페이지 탐색:\nSpace: 다음 페이지 b: 이전 페이지 /word: 검색 q: 종료 24. help / \u0026ndash;help 간단한 도움말을 출력합니다.\n1 2 3 ls --help cp --help help cd # 내장 명령어 네트워크 25. curl client URL의 줄임말로 서버에 데이터를 보내거나 서버로부터 받는 데이터 전송 명령어입니다. HTTP, HTTPS, FTP 등 다양한 프로토콜을 지원합니다.\n기본 사용:\n1 curl https://example.com # 웹 페이지 내용 가져오기 주요 옵션:\n1 2 3 4 curl -o file.html https://example.com # 파일로 저장 curl -O https://example.com/file.zip # 원본 이름으로 저장 curl -i https://example.com # 응답 헤더 포함 curl -L https://example.com # 리다이렉트 따라가기 HTTP 메소드:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # GET 요청 (기본) curl https://api.example.com/users # POST 요청 curl -X POST https://api.example.com/data \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;,\u0026#34;age\u0026#34;:30}\u0026#39; # PUT 요청 curl -X PUT https://api.example.com/users/1 \\ -d \u0026#34;name=Jane\u0026#34; # DELETE 요청 curl -X DELETE https://api.example.com/users/1 워게임에서의 활용:\n1 2 3 4 5 # 명령어 실행 결과를 서버로 전송 curl \u0026#34;http://myserver.com\u0026#34; -d \u0026#34;`cat /flag`\u0026#34; # 파일 내용 전송 curl -X POST http://myserver.com -d \u0026#34;@/etc/passwd\u0026#34; 26. wget 파일을 다운로드하는 명령어입니다.\n1 2 3 4 wget https://example.com/file.zip # 파일 다운로드 wget -O custom_name.zip https://... # 다른 이름으로 저장 wget -c https://example.com/large.iso # 중단된 다운로드 이어받기 wget -r https://example.com # 웹사이트 전체 다운로드 압축 및 아카이브 27. tar 파일을 묶고 압축하는 명령어입니다.\n1 2 3 4 5 tar -cvf archive.tar files/ # 묶기 tar -czvf archive.tar.gz files/ # 묶고 gzip 압축 tar -xvf archive.tar # 풀기 tar -xzvf archive.tar.gz # gzip 압축 해제하며 풀기 tar -tvf archive.tar # 내용 확인 옵션 의미:\nc: create (생성) x: extract (추출) v: verbose (과정 표시) f: file (파일 지정) z: gzip 압축/해제 j: bzip2 압축/해제 28. zip / unzip zip 형식으로 압축합니다.\n1 2 3 4 zip archive.zip file1 file2 # 압축 zip -r archive.zip directory/ # 디렉토리 압축 unzip archive.zip # 압축 해제 unzip -l archive.zip # 내용만 확인 디스크 사용량 29. du 디렉토리와 파일의 디스크 사용량을 확인합니다.\n1 2 3 4 du -h # 사람이 읽기 쉬운 형식 du -sh * # 현재 디렉토리의 각 항목 크기 du -sh /home/user # 특정 디렉토리 전체 크기 du -h --max-depth=1 # 1단계 깊이까지만 30. df 파일 시스템의 디스크 공간 사용량을 확인합니다.\n1 2 df -h # 모든 파일 시스템 df -h /home # 특정 디렉토리가 속한 파일 시스템 고급 기능 와일드카드 **와일드카드(wildcards)**는 리눅스에서 임의의 다른 문자를 나타낐 수 있는 특수 문자들을 의미합니다. 주로 명령어를 다른 문자열로 대체하기 위해 사용합니다.\n기본 와일드카드\n? - 임의의 1개 문자\na-z, 0-9 범위 내 임의의 1개 문자로 대체됩니다. 1 2 ls file?.txt # file1.txt, fileA.txt 등 매칭 ls test? # test1, testa 등 매칭 * - 임의의 0개 이상 문자\na-z, 0-9 범위 내 임의의 0개 이상 문자로 대체됩니다. 1 2 3 ls *.txt # 모든 .txt 파일 ls test* # test로 시작하는 모든 파일 ls *backup* # backup이 포함된 모든 파일 [] - 범위 지정\n[문자1-문자2] 혹은 [문자1, 문자2, …] 형태로 범위를 지정합니다. 1 2 3 ls file[1-3].txt # file1.txt, file2.txt, file3.txt ls [abc]* # a, b, c로 시작하는 파일 ls *.[ch] # .c 또는 .h로 끝나는 파일 실전 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # .txt로 끝나는 모든 파일 삭제 rm *.txt # file1, file2, file3... file9 선택 ls file[1-9] # 이름이 정확히 3글자인 모든 파일 ls ??? # test로 시작하는 모든 파일을 /backup/으로 복사 cp test* /backup/ # 2024년 로그 파일 전체 보기 cat log-2024-*.txt # JPG 또는 PNG 이미지 파일 이동 mv *.{jpg,png} images/ 리다이렉션 **리다이렉션(redirection)**은 모니터에 나타나는 표준 출력 혹은 키보드로 입력하는 표준 입력을 다른 곳으로 변경하는 작업입니다.\n표준 스트림\n표준 입력 (stdin): 0번, 키보드로부터의 입력 표준 출력 (stdout): 1번, 화면으로의 정상 출력 표준 에러 (stderr): 2번, 화면으로의 에러 메시지 출력 리다이렉션\n명령어 \u0026gt; 파일\n명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 덮어씁니다. 1 2 ls -l \u0026gt; file_list.txt # 출력을 파일에 저장 (덮어쓰기) echo \u0026#34;Hello\u0026#34; \u0026gt; greeting.txt 명령어 \u0026gt;\u0026gt; 파일\n명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 이어서 씁니다. 1 2 3 echo \u0026#34;Line 1\u0026#34; \u0026gt; log.txt # 새로 생성 echo \u0026#34;Line 2\u0026#34; \u0026gt;\u0026gt; log.txt # 추가 echo \u0026#34;Line 3\u0026#34; \u0026gt;\u0026gt; log.txt # 추가 명령어 2\u0026gt; 파일\n에러 메시지만 파일로 저장합니다. 1 2 3 4 command 2\u0026gt; error.log # 에러만 파일에 저장 command \u0026gt; output.txt 2\u0026gt; error.log # 출력과 에러 분리 command \u0026gt; output.txt 2\u0026gt;\u0026amp;1 # 출력과 에러를 같은 파일에 command \u0026amp;\u0026gt; all.log # 출력과 에러를 같은 파일에 (축약형) 입력 리다이렉션\n명령어 \u0026lt; 파일\n명령어 표준 입력을 파일로 변경합니다. 파일로부터 표준 입력을 받아 명령어를 수행합니다. 1 2 sort \u0026lt; unsorted.txt # 파일 내용을 정렬 wc -l \u0026lt; file.txt # 파일 줄 수 세기 Here Document\n1 2 3 4 5 cat \u0026lt;\u0026lt; EOF \u0026gt; file.txt 여러 줄의 텍스트를 입력할 수 있습니다 EOF 파이프 **파이프(pipe)**는 리다이렉션의 한 형태로, 명령어 결과 표준 출력을 다른 명령어의 표준 입력으로 보낼 때 사용합니다. 파이프는 | 문자로 나타냅니다.\n기본 사용\n1 2 3 ls -l | grep \u0026#34;.txt\u0026#34; # ls 출력에서 .txt 검색 cat file.txt | wc -l # 파일 줄 수 세기 ps aux | grep nginx # 프로세스 필터링 실전 파이프 활용\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 가장 많이 사용하는 명령어 top 10 history | awk \u0026#39;{print $2}\u0026#39; | sort | uniq -c | sort -rn | head # 특정 프로세스의 메모리 사용량 확인 ps aux | grep nginx | awk \u0026#39;{print $6}\u0026#39; # 로그에서 에러만 필터링하여 개수 확인 cat app.log | grep ERROR | wc -l # 디렉토리별 용량 확인 후 정렬 du -sh */ | sort -h # 가장 큰 파일 10개 찾기 du -ah | sort -rh | head -10 # 특정 확장자 파일 개수 find . -name \u0026#34;*.py\u0026#34; | wc -l # CPU 사용률 높은 프로세스 상위 5개 ps aux | sort -nrk 3 | head -5 # 특정 포트를 사용하는 프로세스 찾기 netstat -tuln | grep :80 # 중복 제거된 정렬된 목록 cat list.txt | sort | uniq # 로그에서 IP 주소 추출 및 빈도 분석 grep -oE \u0026#39;\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\u0026#39; access.log | sort | uniq -c | sort -rn 권한 유저(user)와 그룹(group) 리눅스에서 유저와 그룹은 리눅스의 권한 시스템을 설명하기 위해 빠뜨릴 수 없는 개념입니다. 리눅스의 각 유저는 이름과 고유한 사용자 ID(UID)를 가지고 있습니다. 그룹은 말 그대로 여러 유저가 속할 수 있는 그룹으로, 이 역시 그룹 이름과 고유한 그룹 ID(GID)를 가지고 있습니다.\n파일이나 디렉토리와 같은 시스템 자원에 유저가 접근하면 유저의 UID와 해당 유저가 속한 그룹의 GID를 확인하여 정당한 권한을 가지고 있는지를 판단해 접근을 제어합니다.\n유저 정보 확인\n/etc/passwd는 리눅스의 유저 정보를 담고 있는 텍스트 파일입니다. 각 사용자의 이름, 사용자 ID, 속해있는 그룹 ID 등의 정보를 포함하고 있습니다.\n1 cat /etc/passwd 각 줄의 형식: username:x:UID:GID:comment:home_directory:shell\n예시:\nroot:x:0:0:root:/root:/bin/bash\ruser:x:1000:1000:user,,,:/home/user:/bin/bash 그룹 정보 확인\n/etc/group은 리눅스의 그룹 정보를 저장하는 텍스트 파일입니다. 각 그룹의 이름, 그룹 ID, 그룹에 속한 유저 목록 등의 정보를 포함하고 있습니다.\n1 cat /etc/group 유저 관련 명령어\n1 2 3 4 whoami # 현재 사용자 이름 id # 현재 사용자의 UID, GID 정보 groups # 현재 사용자가 속한 그룹들 users # 현재 로그인한 사용자들 파일 및 디렉토리 권한 리눅스는 사용자가 파일과 디렉토리에 접근하는 행위에 대해 권한으로 제어합니다. 각 파일과 디렉토리는 **소유자(owner)**와 **소유 그룹(group)**을 가지고 있습니다. 소유자는 파일 또는 디렉토리의 권한을 수정할 수 있는 능력을 가지고 있습니다.\n세 가지 접근 권한\n읽기(Read, r): 파일 또는 디렉토리의 내용을 볼 수 있게 허용합니다.\n파일: 파일 내용을 읽을 수 있음 디렉토리: 디렉토리 내 파일 목록을 볼 수 있음 쓰기(Write, w): 파일 또는 디렉토리의 내용을 수정하거나 삭제하는 것을 허용합니다.\n파일: 파일 내용을 수정하거나 삭제할 수 있음 디렉토리: 디렉토리 내에 파일을 생성하거나 삭제할 수 있음 실행(Execute, x): 파일이 프로그램인 경우 실행할 수 있게 허용합니다.\n파일: 프로그램으로 실행할 수 있음 디렉토리: 디렉토리에 접근(cd)할 수 있음 권한 확인하기\n파일이나 디렉토리의 권한을 보기 위해 ls -l을 사용합니다.\n1 2 3 4 5 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ---------- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world 권한 플래그 해석 1 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir 권한 플래그 drwxrwxr-x는 4개 부분으로 나뉩니다:\nd rwx rwx r-x\r│ └┬┘ └┬┘ └┬┘\r│ │ │ └─→ 기타 사용자 권한 (r-x: 읽기, 실행)\r│ │ └─────→ 그룹 권한 (rwx: 읽기, 쓰기, 실행)\r│ └─────────→ 소유자 권한 (rwx: 읽기, 쓰기, 실행)\r└────────────→ 파일 타입 (d: 디렉토리) 파일 타입 (첫 번째 문자)\nd: 디렉토리 (directory) -: 일반 파일 (regular file) l: 심볼릭 링크 (symbolic link) b: 블록 디바이스 (block device) c: 문자 디바이스 (character device) s: 소켓 (socket) p: 파이프 (pipe) 권한 문자\nr: 읽기 권한 (Read) w: 쓰기 권한 (Write) x: 실행 권한 (Execute) -: 해당 권한 없음 권한의 숫자 표현\n권한은 2진수나 10진수로도 표현할 수 있습니다.\n권한 2진수 10진수 의미 --- 000 0 권한 없음 --x 001 1 실행만 -w- 010 2 쓰기만 -wx 011 3 쓰기, 실행 r-- 100 4 읽기만 r-x 101 5 읽기, 실행 rw- 110 6 읽기, 쓰기 rwx 111 7 모든 권한 예시:\nrwx = 111 = 7 rw- = 110 = 6 r-- = 100 = 4 rwxrw-r-- = 764 소유자와 소유 그룹\n1 2 3 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ↑ ↑ 소유자 소유그룹 세 번째 열: 파일/디렉토리의 소유자 네 번째 열: 파일/디렉토리의 소유 그룹 종합 예시\n1 -rwxrw-r-- 1 user user 13 12월 2 13:08 world 해석:\n파일 타입: - (일반 파일) 소유자 권한: rwx (읽기, 쓰기, 실행 가능) 그룹 권한: rw- (읽기, 쓰기 가능, 실행 불가) 기타 권한: r-- (읽기만 가능) 소유자: user 소유 그룹: user 파일 및 디렉토리 권한 명령어 chmod chmod는 파일 권한을 변경하는 명령어입니다. root 유저 혹은 파일의 소유자만 실행할 수 있습니다.\n형식\n1 chmod 권한 파일명 숫자 모드\n1 2 3 4 5 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir ---------- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world hello 파일을 rwxrw-r-- (764) 권한으로 변경:\n소유자: rwx = 7 그룹: rw- = 6 기타: r-- = 4 1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ chmod 764 hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxrw-r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world 기호 모드\n대상:\nu: 소유자 (user) g: 그룹 (group) o: 기타 (others) a: 모두 (all) 연산:\n+: 권한 추가 -: 권한 제거 =: 권한 설정 권한 추가:\n1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ chmod g+x hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxrwxr-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world 권한 제거:\n1 2 3 4 5 6 user@user-VirtualBox:~/new_dir$ chmod g-wx hello user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world 유용한 예시\n1 2 3 4 5 6 7 8 chmod 644 file.txt # rw-r--r-- (일반 파일) chmod 755 script.sh # rwxr-xr-x (실행 파일) chmod 700 private.txt # rwx------ (소유자만 접근) chmod 777 public_dir # rwxrwxrwx (모두 접근, 위험!) chmod -R 755 directory/ # 디렉토리와 내부 파일 전체에 적용 chmod u+x script.sh # 소유자에게 실행 권한 추가 chmod a-w file.txt # 모두에게서 쓰기 권한 제거 chmod o-rwx private # 기타 사용자 모든 권한 제거 chown chown은 파일 소유자 혹은 소유 그룹을 변경하는 명령어입니다. root 유저만 실행할 수 있습니다.\n형식\n1 chown 사용자명[:그룹명] 파일명 소유자 변경\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 user user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ sudo chown root hello [sudo] password for user: user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ echo \u0026#34;hello\u0026#34; \u0026gt; hello bash: hello: Permission denied 소유자와 그룹 동시 변경\n1 2 3 sudo chown root:root hello # 소유자와 그룹을 root로 sudo chown user:developers file.txt # 특정 사용자와 그룹으로 sudo chown -R user:user directory/ # 디렉토리 전체에 재귀적으로 적용 chgrp chgrp는 소유 그룹만 변경하는 명령어입니다.\n1 2 sudo chgrp developers file.txt # 그룹만 변경 sudo chgrp -R www-data /var/www/ # 디렉토리 전체에 적용 특수 권한 앞서 배운 r, w, x 권한 외에 특수한 권한 3가지가 있습니다.\nsetuid (Set User ID) 일반 사용자가 파일을 실행하면 파일 소유자 권한으로 실행됩니다.\n예시: /bin/passwd\n1 2 user@user-VirtualBox:/bin$ ls -l passwd -rwsr-xr-x 1 root root 59976 11월 24 21:05 passwd 소유자의 실행 권한에 x 대신 s가 표시됩니다. 이는 일반 사용자가 passwd 명령을 실행하면 root 권한으로 실행되어 자신의 비밀번호를 변경할 수 있게 합니다.\ns: setuid가 설정되고 실행 권한도 있음 S: setuid는 설정되었지만 실행 권한이 없음 (의미 없음) setgid (Set Group ID) 일반 사용자가 파일을 실행하면 파일 소유 그룹 권한으로 실행됩니다.\n소유 그룹의 실행 권한에 x 대신 s가 표시됩니다.\n디렉토리에 setgid를 설정하면 해당 디렉토리 내에서 생성되는 모든 파일이 디렉토리의 그룹을 상속받습니다.\n1 drwxr-sr-x 2 user developers 4096 12월 2 13:38 shared_dir s: setgid가 설정되고 실행 권한도 있음 S: setgid는 설정되었지만 실행 권한이 없음 sticky bit 디렉토리에 sticky bit를 설정하면 파일 및 디렉토리 소유자와 root 사용자 외에는 일반 사용자가 파일을 삭제할 수 없습니다. 주로 공용 디렉토리에 사용합니다.\n예시: /tmp 디렉토리\n1 drwxrwxrwt 20 root root 4096 12월 1 14:17 tmp 일반 사용자의 실행 권한에 x 대신 t가 표시됩니다.\nt: sticky bit가 설정되고 실행 권한도 있음 T: sticky bit는 설정되었지만 실행 권한이 없음 특수 권한 설정 특수 권한은 숫자 형식으로 권한 플래그 맨 앞에 붙여 표현합니다:\nsetuid: 4 setgid: 2 sticky bit: 1 숫자 모드\n1 2 3 4 5 6 7 8 9 10 11 12 user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwxrw-r-- 1 user user 13 12월 2 13:08 world user@user-VirtualBox:~/new_dir$ chmod 4775 world user@user-VirtualBox:~/new_dir$ ls -l total 12 drwxrwxr-x 2 user user 4096 12월 2 13:38 dir -rwxr--r-- 1 root user 13 12월 2 13:05 hello -rwsrwxr-x 1 user user 13 12월 2 13:08 world 기호 모드\n1 2 3 4 chmod u+s file # setuid 설정 chmod g+s directory # setgid 설정 chmod o+t directory # sticky bit 설정 chmod u-s file # setuid 제거 조합 예시\n1 2 3 4 chmod 4755 program # rwsr-xr-x (setuid) chmod 2755 shared_dir # rwxr-sr-x (setgid) chmod 1777 /tmp # rwxrwxrwt (sticky bit) chmod 6755 file # rwsr-sr-x (setuid + setgid) 디렉토리 구조 루트 디렉토리 / 루트 디렉토리는 리눅스의 최상위 디렉토리를 말하며, 절대 경로는 /입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 user@user-VirtualBox:~$ ls -l / total 3991632 lrwxrwxrwx 1 root root 7 11월 30 18:15 bin -\u0026gt; usr/bin drwxr-xr-x 4 root root 4096 12월 1 14:10 boot drwxrwxr-x 2 root root 4096 11월 30 18:25 cdrom drwxr-xr-x 19 root root 4180 12월 1 14:25 dev drwxr-xr-x 130 root root 12288 12월 1 14:09 etc drwxr-xr-x 3 root root 4096 11월 30 18:27 home lrwxrwxrwx 1 root root 7 11월 30 18:15 lib -\u0026gt; usr/lib lrwxrwxrwx 1 root root 9 11월 30 18:15 lib32 -\u0026gt; usr/lib32 lrwxrwxrwx 1 root root 9 11월 30 18:15 lib64 -\u0026gt; usr/lib64 lrwxrwxrwx 1 root root 10 11월 30 18:15 libx32 -\u0026gt; usr/libx32 drwx------ 2 root root 16384 11월 30 18:14 lost+found drwxr-xr-x 3 root root 4096 11월 30 19:49 media drwxr-xr-x 2 root root 4096 8월 9 20:48 mnt drwxr-xr-x 3 root root 4096 11월 30 19:55 opt dr-xr-xr-x 257 root root 0 12월 1 14:11 proc drwx------ 4 root root 4096 12월 1 14:17 root drwxr-xr-x 33 root root 900 12월 1 14:12 run lrwxrwxrwx 1 root root 8 11월 30 18:15 sbin -\u0026gt; usr/sbin drwxr-xr-x 11 root root 4096 8월 9 20:55 snap drwxr-xr-x 2 root root 4096 8월 9 20:48 srv -rw------- 1 root root 4087349248 11월 30 18:15 swapfile dr-xr-xr-x 13 root root 0 12월 1 14:11 sys drwxrwxrwt 20 root root 4096 12월 1 14:17 tmp drwxr-xr-x 14 root root 4096 8월 9 20:48 usr drwxr-xr-x 14 root root 4096 8월 9 20:54 var 주요 디렉토리 설명 /bin - 기본 명령어 일반 유저가 사용할 수 있는 기본적인 명령어나 프로그램을 담고 있는 디렉토리입니다.\n1 ls, cp, mv, rm, cat, echo, mkdir, chmod, ps 등 최신 시스템에서는 /usr/bin으로의 심볼릭 링크입니다.\n/boot - 부팅 파일 시스템 부팅에 필요한 파일들을 담고 있는 디렉토리입니다.\n1 커널 이미지, 부트로더 설정 파일, initramfs 등 /dev - 디바이스 파일 컴퓨터에 부착된 물리적인 장치들을 파일 형태로 접근할 수 있게 합니다.\n1 2 3 4 5 /dev/sda # 첫 번째 하드 디스크 /dev/sda1 # 첫 번째 하드 디스크의 첫 번째 파티션 /dev/null # 널 디바이스 (출력 버리기에 사용) /dev/zero # 0을 무한히 생성 /dev/random # 난수 생성기 /etc - 설정 파일 운영체제나 운영체제 위에서 동작하는 서비스의 설정 파일들을 담고 있는 디렉토리입니다.\n1 2 3 4 5 6 7 /etc/passwd # 사용자 정보 /etc/group # 그룹 정보 /etc/hosts # 호스트 이름 매핑 /etc/hostname # 시스템 호스트명 /etc/ssh/ # SSH 서버 설정 /etc/nginx/ # Nginx 웹서버 설정 /etc/apache2/ # Apache 웹서버 설정 /home - 사용자 홈 디렉토리 각 일반 유저의 홈 디렉토리를 담고 있는 디렉토리입니다.\n1 2 /home/user # user 사용자의 홈 디렉토리 /home/dream # dream 사용자의 홈 디렉토리 각 사용자는 자신의 홈 디렉토리에서 완전한 권한을 가집니다.\n/lib, /lib32, /lib64 - 라이브러리 시스템에 필요한 라이브러리 파일들을 담고 있는 디렉토리입니다.\n1 공유 라이브러리, 커널 모듈 등 /bin이나 /sbin의 프로그램이 필요로 하는 동적 라이브러리 파일이 존재합니다.\n/media - 이동식 미디어 이동식 미디어(USB, CD/DVD 등)가 자동으로 마운트되는 디렉토리입니다.\n1 2 /media/user/USB_DRIVE /media/user/CDROM /mnt - 임시 마운트 파일 시스템을 임시로 마운트하는 데 사용하는 디렉토리입니다.\n1 sudo mount /dev/sdb1 /mnt /opt - 선택적 소프트웨어 추가로 설치한 소프트웨어 패키지들을 담는 디렉토리입니다.\n1 2 /opt/google/chrome /opt/teamviewer /proc - 프로세스 정보 리눅스 커널 자원에 접근할 수 있는 가상 파일 시스템입니다. 프로세스와 시스템 정보를 파일 형태로 제공합니다.\n1 2 3 4 /proc/cpuinfo # CPU 정보 /proc/meminfo # 메모리 정보 /proc/[PID]/ # 각 프로세스 정보 /proc/version # 커널 버전 /root - root 사용자 홈 root 유저의 홈 디렉토리입니다. /home/root가 아님에 주의하세요.\n/run - 런타임 데이터 시스템이 부팅된 이후 런타임 데이터를 저장합니다.\n1 PID 파일, 소켓 파일 등 /sbin - 시스템 관리 명령어 /bin 디렉토리와 유사하지만, root 유저가 사용하는 시스템 관리 명령어를 포함합니다.\n1 fdisk, mkfs, shutdown, reboot, iptables 등 /srv - 서비스 데이터 시스템에서 제공하는 서비스의 데이터를 저장하는 디렉토리입니다.\n1 2 /srv/www # 웹 서버 데이터 /srv/ftp # FTP 서버 데이터 /sys - 시스템 정보 커널과 하드웨어 정보를 제공하는 가상 파일 시스템입니다.\n/tmp - 임시 파일 유저나 프로그램이 임시로 파일을 생성할 때 사용하는 디렉토리입니다.\n주의: 시스템 재부팅 시 또는 일정 시간이 지나면 파일이 자동으로 삭제될 수 있습니다.\n1 drwxrwxrwt # sticky bit로 보호됨 /usr - 사용자 프로그램 사용자 바이너리, 문서, 라이브러리, 헤더 파일 등을 담고 있는 디렉토리입니다.\n1 2 3 4 5 6 /usr/bin/ # 사용자 명령어 /usr/sbin/ # 시스템 관리 명령어 /usr/lib/ # 라이브러리 /usr/local/ # 로컬에 설치한 프로그램 /usr/share/ # 아키텍처 독립적인 데이터 /usr/include/ # C 헤더 파일 /var - 가변 데이터 프로그램이나 시스템이 실시간으로 가변적인 파일을 사용하고 저장할 때 활용하는 디렉토리입니다.\n1 2 3 4 5 6 /var/log/ # 각종 로그 파일 /var/www/ # 웹 서버 루트 (보통) /var/mail/ # 메일 스풀 /var/spool/ # 대기열 데이터 (프린터, cron 등) /var/tmp/ # 재부팅 후에도 유지되는 임시 파일 /var/cache/ # 애플리케이션 캐시 ⚠️ 주의사항 및 안전 사용 팁 위험한 명령어들 절대 실행하지 마세요!\n1 2 3 4 5 6 rm -rf / # 시스템 전체 삭제 (현대 시스템은 보호됨) rm -rf /* # 루트 디렉토리의 모든 내용 삭제 chmod 777 -R / # 모든 파일 권한 열기 (심각한 보안 위험) dd if=/dev/zero of=/dev/sda # 디스크 전체 초기화 mkfs.ext4 /dev/sda # 파티션 포맷 (데이터 삭제) :(){ :|:\u0026amp; };: # Fork bomb (시스템 멈춤) 안전한 사용 습관 1. 삭제 전 항상 확인\n1 2 ls -l file* # 먼저 어떤 파일이 매칭되는지 확인 rm -i file* # 삭제 전 각 파일마다 확인 2. 중요한 작업 전 백업\n1 2 cp important.txt important.txt.backup tar -czf backup_$(date +%Y%m%d).tar.gz /important/directory/ 3. sudo 사용 시 신중하게\n1 2 3 4 5 6 # 나쁜 예 sudo rm -rf /tmp ../file # 경로 실수 시 위험 # 좋은 예 ls -l /tmp ../file # 먼저 확인 sudo rm -rf /tmp ../file # 확인 후 실행 4. 와일드카드 사용 시 주의\n1 2 3 4 5 6 # 나쁜 예 rm * .txt # 모든 파일 삭제 후 .txt 삭제 시도 # 좋은 예 rm *.txt # .txt 파일만 삭제 ls *.txt # 먼저 무엇이 삭제될지 확인 5. 절대 경로 vs 상대 경로\n1 2 3 4 5 6 # 현재 위치를 항상 확인 pwd # 중요한 작업은 절대 경로 사용 rm -rf /home/user/old_project # 명확함 # rm -rf ../../../old_project # 위험할 수 있음 유용한 팁과 트릭 명령어 히스토리 1 2 3 4 5 history # 명령어 이력 보기 !100 # 100번째 명령어 실행 !! # 마지막 명령어 실행 !grep # grep으로 시작하는 마지막 명령어 실행 Ctrl + R # 명령어 이력 검색 (interactive) 단축키 터미널 조작\nCtrl + C # 현재 실행 중인 프로세스 중단\rCtrl + Z # 현재 프로세스 일시 중지\rCtrl + D # 로그아웃 / EOF 전송\rCtrl + L # 화면 지우기 (clear 명령어와 동일) 커서 이동\nCtrl + A # 줄의 시작으로\rCtrl + E # 줄의 끝으로\rCtrl + U # 커서부터 앞쪽 전체 삭제\rCtrl + K # 커서부터 뒷쪽 전체 삭제\rCtrl + W # 커서 앞의 단어 삭제 Tab 자동완성\nTab # 파일명/명령어 자동완성\rTab Tab # 가능한 모든 옵션 표시 별칭(Alias) 설정 자주 사용하는 명령어를 짧게 만들 수 있습니다.\n1 2 3 4 5 6 7 8 9 # 임시 별칭 (현재 세션만) alias ll=\u0026#39;ls -alh\u0026#39; alias ..=\u0026#39;cd ..\u0026#39; alias ...=\u0026#39;cd ../..\u0026#39; alias grep=\u0026#39;grep --color=auto\u0026#39; # 영구 별칭 (~/.bashrc 또는 ~/.zshrc에 추가) echo \u0026#34;alias ll=\u0026#39;ls -alh\u0026#39;\u0026#34; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc 환경 변수 1 2 3 4 5 6 7 8 9 10 11 echo $PATH # PATH 환경 변수 확인 echo $HOME # 홈 디렉토리 echo $USER # 현재 사용자 echo $SHELL # 현재 셸 # 환경 변수 설정 export MY_VAR=\u0026#34;value\u0026#34; echo $MY_VAR # 영구 설정 (~/.bashrc에 추가) echo \u0026#39;export PATH=$PATH:/my/custom/path\u0026#39; \u0026gt;\u0026gt; ~/.bashrc 작업 관리 1 2 3 4 5 command \u0026amp; # 백그라운드에서 실행 jobs # 백그라운드 작업 목록 fg %1 # 1번 작업을 포그라운드로 bg %1 # 1번 작업을 백그라운드로 nohup command \u0026amp; # 로그아웃 후에도 계속 실행 파일 찾기 고급 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 최근 수정된 파일 찾기 find . -mtime -7 # 7일 이내 find . -mmin -60 # 60분 이내 # 파일 크기로 찾기 find . -size +100M # 100MB 이상 find . -size -1k # 1KB 이하 # 찾은 파일에 명령 실행 find . -name \u0026#34;*.log\u0026#34; -exec rm {} \\; find . -type f -name \u0026#34;*.txt\u0026#34; -exec grep \u0026#34;error\u0026#34; {} + # 여러 조건 조합 find . -type f -name \u0026#34;*.py\u0026#34; -size +1M -mtime -30 텍스트 처리 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 줄 번호 표시 cat -n file.txt nl file.txt # 중복 제거 sort file.txt | uniq sort -u file.txt # 컬럼 추출 awk \u0026#39;{print $1}\u0026#39; file.txt # 첫 번째 컬럼 cut -d\u0026#39;:\u0026#39; -f1 /etc/passwd # : 구분자로 첫 번째 필드 # 문자열 치환 sed \u0026#39;s/old/new/\u0026#39; file.txt # 첫 번째 매치만 sed \u0026#39;s/old/new/g\u0026#39; file.txt # 모든 매치 sed -i \u0026#39;s/old/new/g\u0026#39; file.txt # 파일 직접 수정 시스템 모니터링 1 2 3 4 5 6 7 8 9 10 11 12 # 디스크 I/O iostat iotop # 실시간 I/O 모니터링 # 네트워크 netstat -tuln # 리스닝 포트 ss -tuln # 현대적인 대체 lsof -i :80 # 특정 포트 사용 프로세스 # 메모리 free -h # 메모리 사용량 vmstat # 가상 메모리 통계 실전 시나리오 시나리오 1: 디스크 공간 확보 상황: 디스크 공간이 부족합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 1. 디스크 사용량 확인 df -h # 2. 큰 파일/디렉토리 찾기 du -sh /* | sort -h # 3. 특정 디렉토리 상세 분석 du -h --max-depth=1 /home | sort -h # 4. 100MB 이상 파일 찾기 find / -type f -size +100M 2\u0026gt;/dev/null # 5. 오래된 로그 파일 정리 find /var/log -name \u0026#34;*.log\u0026#34; -mtime +30 -delete # 6. 임시 파일 정리 sudo apt clean # 패키지 캐시 rm -rf ~/.cache/* # 사용자 캐시 시나리오 2: 시스템 느림 진단 상황: 시스템이 갑자기 느려졌습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 1. CPU 사용률 확인 top # 또는 htop # 2. CPU 사용 상위 프로세스 ps aux --sort=-%cpu | head # 3. 메모리 사용 상위 프로세스 ps aux --sort=-%mem | head # 4. 디스크 I/O 확인 iostat -x 1 # 5. 특정 프로세스 종료 kill -9 [PID] 시나리오 3: 로그 분석 상황: 웹 서버에 문제가 있어 로그를 분석해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1. 최근 에러 확인 tail -f /var/log/nginx/error.log # 2. 특정 시간대 로그 grep \u0026#34;2026-01-12 14:\u0026#34; /var/log/nginx/access.log # 3. 404 에러 개수 grep \u0026#34;404\u0026#34; /var/log/nginx/access.log | wc -l # 4. IP별 요청 횟수 awk \u0026#39;{print $1}\u0026#39; /var/log/nginx/access.log | sort | uniq -c | sort -rn # 5. 가장 많이 요청된 URL awk \u0026#39;{print $7}\u0026#39; /var/log/nginx/access.log | sort | uniq -c | sort -rn | head # 6. 에러 로그를 파일로 저장 grep \u0026#34;error\u0026#34; /var/log/nginx/error.log \u0026gt; errors_$(date +%Y%m%d).log 시나리오 4: 백업 및 복원 상황: 프로젝트 파일을 백업하고 싶습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1. 압축 백업 생성 tar -czf backup_$(date +%Y%m%d_%H%M%S).tar.gz /path/to/project # 2. 원격 서버로 전송 scp backup_*.tar.gz user@remote:/backup/ # 3. 백업에서 복원 tar -xzf backup_20260112_143000.tar.gz # 4. 특정 파일만 추출 tar -xzf backup.tar.gz path/to/specific/file # 5. 증분 백업 (rsync 사용) rsync -avz --delete /source/ /backup/ # 6. 원격 동기화 rsync -avz -e ssh /local/path/ user@remote:/remote/path/ 시나리오 5: 권한 문제 해결 상황: 웹 서버가 특정 파일에 접근하지 못합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 1. 파일 권한 확인 ls -l /var/www/html/ # 2. 소유자 확인 stat /var/www/html/index.html # 3. 웹 서버 사용자 확인 (nginx 예시) ps aux | grep nginx # 4. 소유자 변경 sudo chown -R www-data:www-data /var/www/html/ # 5. 권한 설정 sudo find /var/www/html -type d -exec chmod 755 {} \\; sudo find /var/www/html -type f -exec chmod 644 {} \\; # 6. 특수 권한이 필요한 경우 sudo chmod u+s /usr/bin/special_program 실전 문제 풀이 1 2 3 4 5 ls # 현재 디렉토리 파일 확인 cat hint.txt # 힌트 파일 읽기 cat /dream/hack/hello/flag.txt # 힌트에 나온 경로의 플래그 읽기 cat app.py # 추가 파일 확인 cat ./dream/hack/hello/f*ag.txt # 와일드카드로 플래그 파일 읽기 Details 플래그: DH{671ce26c70829e716fae26c7c71a33823feb479f2562891f64605bf68f60ae54}\n","permalink":"http://localhost:1313/posts/2026-01-08/","summary":"리눅스 사용법 정리글","title":"리눅스 사용법 한 눈에 살펴보기"},{"content":"1. 개요 (Intro) 안녕하세요, AlwaysHyeon의 보안 블로그입니다. 이 글은 GitHub Pages와 Hugo PaperMod 테마가 정상적으로 연동되었는지 확인하기 위한 테스트 포스트입니다.\n테스트 환경 Generator: Hugo Theme: PaperMod Hosting: GitHub Pages 2. 기능 테스트 (Feature Test) 2.1. 코드 하이라이팅 (Code Block) Python 코드가 예쁘게 나오는지 확인합니다.\n1 2 3 4 5 6 7 8 import os def check_security(): print(\u0026#34;System Secure... maybe?\u0026#34;) return True if __name__ == \u0026#34;__main__\u0026#34;: check_security() ","permalink":"http://localhost:1313/posts/test-post/","summary":"Hugo PaperMod 테마 적용 테스트 글입니다. 마크다운 문법과 코드 하이라이팅이 잘 적용되는지 확인합니다.","title":"블로그 테스트 및 첫 번째 글 (Hello World)"}]